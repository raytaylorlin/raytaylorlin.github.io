<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《看门狗》网络绕接玩法的实现</title>
      <link href="/tech/complex/project/watch-dog-network-bypass/"/>
      <url>/tech/complex/project/watch-dog-network-bypass/</url>
      
        <content type="html"><![CDATA[<p>《看门狗》系列游戏中，网络绕接（Network Bypass）是其中一种解谜小玩法，其目标是通过旋转一些通路节点来打通通路，最终解锁目标节点。下图展示了一个游戏中的示例，看一遍应该就能明白。</p><video src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/project/%E3%80%8A%E7%9C%8B%E9%97%A8%E7%8B%97%E3%80%8B%E7%BD%91%E7%BB%9C%E7%BB%95%E6%8E%A5%E7%8E%A9%E6%B3%95%E7%A4%BA%E4%BE%8B.mp4" type="video/mp4" controls="controls" width="100%" height="100%"></video><p>鉴于这个玩法非常简单，闲暇时正好拿来作为练手项目。本文描述了该项目大致的设计思路。<a href="https://github.com/raytaylorlin/NetworkBypassPuzzle" target="_blank" rel="noopener">Github项目地址</a></p><a id="more"></a><h1 id="1-设计"><a href="#1-设计" class="headerlink" title="1. 设计"></a>1. 设计</h1><h2 id="1-1-节点类型"><a href="#1-1-节点类型" class="headerlink" title="1.1 节点类型"></a>1.1 节点类型</h2><ul><li>起始节点（StartNode）：每个网络绕接玩法至少会有一个，这是所有网路通路的开端</li><li>终止节点（EndNode）：每个网络绕接玩法至少会有一个，且必定带锁，玩法的目标就是解开这个节点的锁</li><li>连接节点（ConnectionNode）：起到变向网络流的功能，给定一个方向的输入，会有其他方向的输出<ul><li>直角型节点（RightAngleConnectionNode）</li><li>直线型节点（StraightConnectionNode）</li><li>T型节点（TConnectionNode）</li><li>十字型节点（CrossConnectionNode）</li></ul></li><li>转接节点（TransitionNode）：用于改变网络流的流动方向</li></ul><h2 id="1-2-节点共性"><a href="#1-2-节点共性" class="headerlink" title="1.2 节点共性"></a>1.2 节点共性</h2><p>下面一级列表列出各种节点的共同特性（父类）。一些特殊节点（子类）的具体实现方式列在二级列表。</p><ul><li>每个节点都有上下左右4个邻居节点（可空）</li><li>连接节点有4种旋转方向<ul><li>像十字型无论怎么转都一样，直线型只有两种方向，但4个旋转方向对它们来说依旧适用</li></ul></li><li>4个方向都可能有输入和输出<ul><li>Start节点只有输出</li><li>End节点只有输入</li><li>连接节点根据自身旋转方向和输入方向，来确定朝哪个方向输出</li></ul></li><li>都可以被激活或反激活<ul><li>当连接节点的某个管道有输入时，即被激活</li><li>带锁节点（包括终止节点）的所有锁口有输入时，即被激活</li><li>当转接节点某个方向有输入时，即被激活</li></ul></li></ul><h2 id="1-3-装饰器"><a href="#1-3-装饰器" class="headerlink" title="1.3 装饰器"></a>1.3 装饰器</h2><p>装饰器是用来给节点添加额外功能的，最常用的就是加锁（也是项目目前实现的唯一一种装饰器）。在实际的《看门狗》游戏中，还存在两种装饰器：倒计时装饰器（所装饰的节点被激活时开始倒计时，计时结束则重置整个网络绕接谜题，强迫玩家在限定时间内完成谜题），打乱装饰器（当某种条件达成时，例如某个节点被激活，则打乱所装饰节点的旋转方向，起到一种干扰作用）。</p><p>锁装饰器对于连接节点是可选的，但对于终止节点是强制要有的。锁也是定义了4个方向，当没有解锁之前，上了锁的节点会阻断其他输入流，当所有锁都解开时，其原本的节点功能才会恢复。</p><p>利用Unity天然的组件系统，各种装饰器可以轻松地做成Component并附加在节点上。</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="2-1-核心算法"><a href="#2-1-核心算法" class="headerlink" title="2.1 核心算法"></a>2.1 核心算法</h2><p>网络绕接的实现可以说是一个遍历有向图的过程。核心思想是从起始节点出发，沿着网络流广度优先遍历图的边。算法的伪代码如下：</p><pre><code>void Init(){    遍历所有节点，在邻居节点之间创建NetworkFlow（边）;    初始化所有节点，并注册相关事件;}private Queue&lt;NetworkFlow&gt; flowQueue = new Queue&lt;NetworkFlow&gt;();// 遍历网络流，在玩法开始时执行一次，随后每次节点执行一次操作则再执行该方法void TraverseNetworkFlow(){    将所有的NetworkNode和NetworkFlow都清理一下（反激活）;    将起始节点周边有输出的通路，入队flowQueue;    while (flowQueue.Count &gt; 0)    {        NetworkFlow flow = flowQueue.Dequeue();  // 当前处理的网络流        NetworkNode node = flow.FirstNode;       // node可理解为当前处理的节点        NetworkNode neighbor = flow.SecondNode;        激活flow;        设置neighbor的输入状态;        // 第一趟查找        将neighbor周边有输出的**没有被访问过的**通路，**而且该通路从来没有走过**，则入队flowQueue;        if (第一趟查找没有找到任何flow)        {            将neighbor周边有输出的通路，**而且仅被访问过一次（说明这一次是的流向是反向的）**，入队flowQueue;        }    }}</code></pre><h2 id="2-2-谜题编辑器"><a href="#2-2-谜题编辑器" class="headerlink" title="2.2 谜题编辑器"></a>2.2 谜题编辑器</h2><p>要实现这个玩法规则本身并不是很难，但此外还有一个要重点考虑的是如何让策划高效地编辑和测试各种谜题。为此特意对各种节点类型定制了Inspector，如下图所示，其作用应该也是一目了然。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/project/%E7%BD%91%E7%BB%9C%E7%BB%95%E6%8E%A5%E7%8E%A9%E6%B3%95%EF%BC%9A%E8%8A%82%E7%82%B9%E5%AE%9A%E5%88%B6%E7%9A%84Inspector.jpg" alt="网络绕接玩法：节点定制的Inspector"></p><p>下面的示意图演示了如何创建节点，摆放节点，以及给节点连线和设置参数。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/project/%E7%BD%91%E7%BB%9C%E7%BB%95%E6%8E%A5%E7%8E%A9%E6%B3%95%EF%BC%9A%E5%88%9B%E5%BB%BA%EF%BC%8C%E6%91%86%E6%94%BE%E8%8A%82%E7%82%B9.gif" alt="网络绕接玩法：创建，摆放节点"></p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/project/%E7%BD%91%E7%BB%9C%E7%BB%95%E6%8E%A5%E7%8E%A9%E6%B3%95%EF%BC%9A%E7%BB%99%E8%8A%82%E7%82%B9%E8%BF%9E%E7%BA%BF%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0.gif" alt="网络绕接玩法：给节点连线和设置参数"></p><p>2.3 网络通路的噪声效果<br>最开始的实现是直接用一个Line Renderer实现的。后来尝试做出原版游戏的那种噪声效果，在网上找了一个随机生成雪花点的Shader，并自己修改成一个Shader动画，其Pass代码如下：</p><pre><code>CGPROGRAM#pragma vertex vert_img#pragma fragment frag#include &quot;UnityCG.cginc&quot;// 这三个参数影响雪花点的分布，经我测试三个均使用5000可达到比较好的效果float _Factor1;float _Factor2;float _Factor3;// 雪花点闪烁的速度float _Speed;fixed4 _Color;float noise(half2 uv){    float t = _Speed * _Time.y;    return frac(sin(dot(uv, float2(t * _Factor1, t * _Factor2))) * t * _Factor3);}fixed4 frag (v2f_img i) : SV_Target{    fixed4 col = noise(i.uv);    col.rgb *= _Color.rgb;    return col;}ENDCG</code></pre><p>最终效果如下：</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/project/%E5%99%AA%E5%A3%B0Shader%E5%8A%A8%E7%94%BB.gif" alt="噪声Shader动画"></p><p>最后放一个比较复杂的且支持3D的案例演示：</p><video src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/project/%E7%BD%91%E7%BB%9C%E7%BB%95%E6%8E%A5%E7%8E%A9%E6%B3%95%EF%BC%9A%E5%A4%8D%E6%9D%82%E7%9A%843D%E7%A4%BA%E4%BE%8B.mp4" type="video/mp4" controls="controls" width="100%" height="100%"></video>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 看门狗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Sublime编辑器打印高亮代码</title>
      <link href="/tech/tool/IDE/print-hightlight-code/"/>
      <url>/tech/tool/IDE/print-hightlight-code/</url>
      
        <content type="html"><![CDATA[<p>Sublime Text 3编辑器的代码高亮（主题）效果不错，本文介绍如何使用ST3将其打印成PDF。</p><a id="more"></a><h1 id="Sublime-Text-3打印代码"><a href="#Sublime-Text-3打印代码" class="headerlink" title="Sublime Text 3打印代码"></a>Sublime Text 3打印代码</h1><p>ST3打印代码的原理是将代码（含样式）先转换成HTMl，再从浏览器中打印。</p><ul><li>安装<a href="https://github.com/facelessuser/ExportHtml" target="_blank" rel="noopener">ExportHtml</a>插件</li><li>菜单<code>Preferences-&gt;Package Settings-&gt;ExportHtml-&gt;Settings</code>，在右侧添加如下自定义设置并保存</li></ul><pre><code>{    &quot;html_panel&quot;: [        {            &quot;Browser Print - Custom&quot;: {                &quot;numbers&quot;: true,                &quot;wrap&quot;: 900,                &quot;browser_print&quot;: true,                &quot;multi_select&quot;: true,                &quot;color_scheme&quot;: &quot;Packages/Color Scheme - Default/Monokai.tmTheme&quot;,  // 使用ST默认的Monokai主题，这里可以换成自己安装的其他主题路径                &quot;style_gutter&quot;: true,                &quot;diable_nbsp&quot;: true            }        }    ]}</code></pre><ul><li><code>Ctrl-Shift-P</code>，<code>Export To HTML: Show Export Menu</code>选择上面自定义的选项，这时会弹开浏览器的打印页，HTMl已经生成</li><li>按下图设置打印选项，可以打印得更美观</li></ul><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/IDE/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%8D%B0%E8%AE%BE%E7%BD%AE.png" alt="Chrome浏览器打印设置"></p><h2 id="优化选项"><a href="#优化选项" class="headerlink" title="优化选项"></a>优化选项</h2><p>默认导出的HTML会带文件名，如果想要将其隐藏，可以修改插件的导出CSS：</p><ul><li>找到ExportHtml插件的路径：<code>Sublime Text Build 3143 x64\Data\Installed Packages\ExportHtml.sublime-package</code>，将插件文件当做压缩包解压出来</li><li><p>将解压出来的<code>ExportHtml\css\export.css</code>复制到其他地方，例如<code>Sublime Text Build 3143 x64\Data\Packages\User</code>，在文件末尾加上一行代码：</p><p>  #file_info { display: none; }</p></li></ul><p>修改上面的插件设置，使用自定义的CSS：</p><pre><code>{    &quot;export_css&quot;: &quot;Packages/User/export.css&quot;,  // 这里填自定义的CSS路径    &quot;html_panel&quot;: [        // 保持原样，省略......    ]}</code></pre><p>重新导出，会发现烦人的文件名不显示了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime </tag>
            
            <tag> 打印高亮代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGUI源码学习——UISprite</title>
      <link href="/tech/game/unity/ngui-code-uisprite/"/>
      <url>/tech/game/unity/ngui-code-uisprite/</url>
      
        <content type="html"><![CDATA[<p>UISprite是NGUI最基本的图片显示控件之一。它的基类UIBasicSprite承载了绝大多数的显示逻辑，本文记录其各种填充方法的原理。要显示一个sprite，必定会有一个管理sprite的图集，最后会记录UIAtlas的一些基本要点。</p><p>【参考版本：NGUI 3.6.9】</p><a id="more"></a><h1 id="1-基类UIBasicSprite-UIWidget"><a href="#1-基类UIBasicSprite-UIWidget" class="headerlink" title="1. 基类UIBasicSprite : UIWidget"></a>1. 基类UIBasicSprite : UIWidget</h1><p>核心是提供了一个总控Fill和一系列类型Fill方法（分为Simple、Sliced、Filled、Tiled、Advanced），供子类调用。Fill方法接收geometry的顶点、UV和颜色列表并填充相应数据。该方法会在UIWidget.UpdateGemoetry中调用OnFill时调用。</p><ul><li>flip属性：有水平、垂直、两者皆翻转，通过交换uv坐标的位置来实现</li><li><code>SimpleFill</code>：获取drawingDimensions，drawingUVs，drawingColor属性，直接填充4个顶点、uv和颜色</li><li><code>SlicedFill</code>：九宫格填充，所以会绘制9个区域。核心填充方法见下图和代码。其中<code>mTempPos</code>为图中所标4个点，通过左下角、右上角点和border计算所得；<code>mTempUVs</code>为图中所标4个点的UV，通过outer和inner矩形及一个简单的工具方法<code>NGUIMath.ConvertToTexCoords</code>计算所得。</li></ul><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/Unity/SlicedFill%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%A1%AB%E5%85%85%E5%8E%9F%E7%90%86.jpg" alt="SlicedFill九宫格填充原理"></p><pre><code>for (int x = 0; x &lt; 3; ++x){    int x2 = x + 1;    for (int y = 0; y &lt; 3; ++y)    {        if (centerType == AdvancedType.Invisible &amp;&amp; x == 1 &amp;&amp; y == 1) continue;        int y2 = y + 1;        // 分别填充顶点，UV，颜色        verts.Add(new Vector3(mTempPos[x].x, mTempPos[y].y));        verts.Add(new Vector3(mTempPos[x].x, mTempPos[y2].y));        verts.Add(new Vector3(mTempPos[x2].x, mTempPos[y2].y));        verts.Add(new Vector3(mTempPos[x2].x, mTempPos[y].y));        uvs.Add(new Vector2(mTempUVs[x].x, mTempUVs[y].y));        uvs.Add(new Vector2(mTempUVs[x].x, mTempUVs[y2].y));        uvs.Add(new Vector2(mTempUVs[x2].x, mTempUVs[y2].y));        uvs.Add(new Vector2(mTempUVs[x2].x, mTempUVs[y].y));        cols.Add(c);        cols.Add(c);        cols.Add(c);        cols.Add(c);    }}</code></pre><ul><li><code>TiledFill</code>：平铺填充。通过两层while循环，使用inner矩形（即九宫格的中间区域）一行一行地平铺填充</li><li><code>FilledFill</code>：主要由mfillDirection（填充方式）、mfillAmount（填充量，范围0-1代表0-90°）和mInvert（是否反转）来控制填充的效果，见下图示例。其中的计算涉及各种三角函数计算（<code>RadialCut</code>方法），不赘述。Radial 180需要分左右画2个矩形，而Radial 360则需要分四块画4个矩形。显然，Radial 360可以实现类似技能CD的效果。</li></ul><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/Unity/%E5%90%84%E7%A7%8DFilledFill%E7%B1%BB%E5%9E%8B%E5%AF%B9%E6%AF%94.jpg" alt="各种FilledFill类型对比"></p><ul><li><code>AdvancedFill</code>：高级填充，可以对上下左右中分别单独设置</li></ul><p>而UISprite除了drawingDimesions这个属性有一些将宽高处理为偶数（pixel-perfect）的逻辑之外，本身没有什么特别的功能，绝大多数功能都在UIBasicSprite中。</p><h1 id="2-UIAtlas"><a href="#2-UIAtlas" class="headerlink" title="2. UIAtlas"></a>2. UIAtlas</h1><p>每个sprite都是显示图集atlas中的一块，因此总会持有mAtlas的引用以便用mSpriteName快速获取UISpriteData数据。<code>UISpriteData</code>类是个简单的数据结构，包含名字、图集所在坐标和尺寸、border（九宫格相关）、padding。</p><p>该类维护了一个<code>List&lt;UISpriteData&gt; mSprites</code>和<code>Dictionary&lt;string, int&gt; mSpriteIndices</code>（sprite名到index的映射）。<code>GetSprite</code>方法会优先在字典中查索引，否则在mSprites列表中查。途中如果字典和列表不一致或查找不到时，调用<code>MarkSpriteListAsChanged</code>，用mSprites去重建字典的索引。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> NGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGUI </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGUI源码学习——UIInput</title>
      <link href="/tech/game/unity/ngui-code-uiinput/"/>
      <url>/tech/game/unity/ngui-code-uiinput/</url>
      
        <content type="html"><![CDATA[<p>UIInput是NGUI的输入控件，其在PC端表现为一个文本框，而在手机端则会拉起系统的键盘。本文主要记录其基本用法和原理，以及一些重要的实现和工具方法。</p><p>【参考版本：NGUI 3.6.9】</p><a id="more"></a><h1 id="1-基本用法和原理"><a href="#1-基本用法和原理" class="headerlink" title="1. 基本用法和原理"></a>1. 基本用法和原理</h1><p>必须和一个UILabel联动使用，用于显示输入的文字。在手机上，实际上封装了对<code>UnityEngine.TouchScreenKeyboard mKeyboard</code>的引用用于控制操作系统的虚拟键盘，用MOBILE宏隔开（在非手机设备上用这个类会编译错误）。</p><p>UIInput在使用时一般还需要挂一个collider，以便响应UICamera的OnPress和OnDrag事件。这两个事件都是通过<code>GetCharUnderMouse()</code>来获取字符索引位置，并更新selectionStart和selectionEnd，没有其他逻辑。</p><h1 id="2-重要方法"><a href="#2-重要方法" class="headerlink" title="2. 重要方法"></a>2. 重要方法</h1><ul><li><code>Validate</code>：验证字符串（逐字符检查）并返回处理过的字符串。若设置了onValidate，则用它来验证，否则根据validation属性（有整形、浮点数、用户名等等选项）用内置的算法来检查字符。字符不合法则跳过该字符，最后根据characterLimit属性检查限制长度。</li><li><code>Update</code>：<strong>当被选中时，才执行以下逻辑</strong><ul><li>等待mKeyboard.active</li><li>在input被激活时mSelectMe记录帧数，确保下面一步【打开键盘】操作只会被执行一次</li><li><strong>打开键盘</strong>：若在手机平台上，获取TouchScreenKeyboardType、InputType、当前值等并调用<a href="https://docs.unity3d.com/ScriptReference/TouchScreenKeyboard.Open.html" target="_blank" rel="noopener">TouchScreenKeyboard.Open</a>打开与操作系统相关的键盘；若不在手机平台，则开启<a href="https://docs.unity3d.com/ScriptReference/Input-imeCompositionMode.html" target="_blank" rel="noopener">Input.imeCompositionMode</a>。最后return。</li><li><strong>手机上获取输入字符</strong>：手机上通过<code>TouchScreenKeyboard.text</code>来获取虚拟键盘中的字符，并调用Insert/DoBackspace方法【见下方具体算法】。接着再通过mKeyboard的API确定是否调用Submit方法。</li><li><strong>PC上获取输入字符</strong>：一般通过<code>Input.inputString</code>来获取输入的字符，并调用Insert方法显示。当使用输入法时，会用到<a href="https://docs.unity3d.com/ScriptReference/Input-compositionString.html" target="_blank" rel="noopener">Input.compositionString</a>ime来更新用户已键入的字符并显示出来。（例如输出“呵呵”要输入“hehe”，后者即为ime）</li><li><strong>光标动画</strong>：一个简单的时间判断，每0.5s切换一次mCaret的显示状态</li></ul></li><li><code>UpdateLabel</code>：<strong>核心方法</strong>，更新label的显示，最终要显示的字符串存储在processed变量中<ul><li>若input值为空，则<code>processed = selected ? &quot;&quot; : mDefaultText;</code></li><li>若inputType为密码形式，则processed为相同字符数量的星号</li><li>处理label为ClampContent且限制为1行的情况：在这种模式下，移动光标或选区超出范围会可以自动滚动字符（类似scrollView）。通过<code>label.CalculateOffsetToFit(processed)</code>计算label尺寸可以容纳下的字符偏移，再通过一些逻辑计算裁剪掉processed</li><li>创建（更新）选区和光标：先代码创建一个2×2的白色纹理，赋给挂在label底下的（也是代码创建）Highlight和Caret（均挂了UITexture）。最后调用<code>label.PrintOverlay(start, end, mCaret.geometry, mHighlight.geometry, caretColor, selectionColor);</code>来绘制出选区和光标矩形，其中涉及到geometry添加顶点，算法逻辑较为复杂。</li></ul></li></ul><h1 id="3-工具方法"><a href="#3-工具方法" class="headerlink" title="3. 工具方法"></a>3. 工具方法</h1><ul><li><code>Insert(string text)</code>：先获取选取当前选区（或光标）左侧串left和右侧串right，再遍历text的每个字符，处理退格、characterLimit和validate的情况。最后还要再对right进行validate<strong>（防止插入的text破坏了后面的合法性）</strong></li><li><code>DoBackspace()</code>：原理是<code>Insert(&quot;&quot;)</code>，最终所得字符串为当前selection左侧字符串+空串+右侧字符串，等价于删掉了selection所在的字符，方法非常巧妙</li><li><code>ProcessEvent(Event ev)</code>：处理各种特殊按键事件，如箭头、退格、回车等等，绝大多数都是mSelectionStart和mSelectionEnd的逻辑处理，算法较为简单</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> NGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGUI </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGUI源码学习——UIScrollView</title>
      <link href="/tech/game/unity/ngui-code-uiscrollview/"/>
      <url>/tech/game/unity/ngui-code-uiscrollview/</url>
      
        <content type="html"><![CDATA[<p>UIScrollView是NGUI支持滚动和拖拽的内容容器，可以和scroll bar联动。本文主要记录其相对滚动原理和核心方法，以及如何利用UIWrapContent优化滚动。了解了UIWrapContent的实现原理之后，可以在其上扩展和封装游戏UI中常见的数据展示控件。</p><p>【参考版本：NGUI 3.6.9】</p><a id="more"></a><h1 id="1-基础要点"><a href="#1-基础要点" class="headerlink" title="1. 基础要点"></a>1. 基础要点</h1><p>UIScrollView依赖于UIPanel，必须和UIPanel绑在同一个go上。注意scrollView的内容物需要挂UIDragScrollView脚本，该脚本主要是接收OnPress和OnDrag事件，并转到UIScrollView中处理。</p><p><strong>相对滚动原理（<code>MoveRelative</code>为核心方法，所有的内容滚动最终都会调用到这里）：scrollView自身transform位置加偏移，同时panel的clipOffset减去相等的偏移量</strong>（见下方代码）。这是因为一正一负的抵消可以让panel的位置保持不动，但由于panel offset的变化导致裁剪之后看上去物体好像被移动了一样。Panel的clipOffset属性使得在滚动的时候不用重建geometry，极大地提升滚动的效率。</p><pre><code>public virtual void MoveRelative (Vector3 relative){    mTrans.localPosition += relative;    Vector2 co = mPanel.clipOffset;    co.x -= relative.x;    co.y -= relative.y;    mPanel.clipOffset = co;    // Update the scroll bars    UpdateScrollbars(false);}</code></pre><h2 id="1-1-核心方法"><a href="#1-1-核心方法" class="headerlink" title="1.1 核心方法"></a>1.1 核心方法</h2><ul><li><code>LateUpdate</code>：更新scrollBar（如果有）的一些透明度数值；<strong>若没有press</strong>（即执行一些惯性动画的过程），则计算动量mMomentum（用于缓动）并插值出mScroll和offset值，利用<code>MoveAbsolute(offset)</code>来逐帧执行spring动画。最后根据restrictWithinPanel属性检测内容有没有超出边界，若有则调用<code>RestrictWithinBounds</code></li><li><code>Press</code>：由挂了UIDragScrollView的go接收<code>OnPress</code>事件后通知UIScrollView，主要用于设置一些状态。按下时，mMomentum和mScroll清零，禁用Spring脚本，截掉tranform位置和panel offset的小数点（保持pixel-perfect），创建一个平面供drag投射用；松开时，限制bounds并触发一些回调。</li><li><code>Drag</code>：根据当前按下的点对上面的平面做投射，若有交点则计算拖拽产生的偏移，并使用<code>MoveAbsolute</code>和<code>RestrictWithinBounds</code>【见下方】方法来移动内容。</li></ul><p>Awake时做一些属性自动调整。例如若panel的clipping为None会改为ConstrainButDontClip（即必须给panel限定一个范围）；自动调整Movement类型等等。</p><p>该类除了上面这些方法之外，主要就剩下一些和Scrollbar联动相关的代码，此处不赘述。</p><h2 id="1-2-工具方法"><a href="#1-2-工具方法" class="headerlink" title="1.2 工具方法"></a>1.2 工具方法</h2><ul><li><code>RestrictWithinBounds</code>：将内容限制到scrollView的边界内。该方法会根据所有widget的内容包围盒以及panel的finalClipRegion，调用<code>NGUIMath.ConstrainRect(minRect, maxRect, minArea, maxArea)</code>计算出将内容rect限制到视口area所需的偏移。<ul><li>若用了<code>DragEffect.MomentumAndSpring</code>，则调用<code>SpringPanel.Begin</code>设置要移动的目标位置并启用动画</li><li>否则直接MoveRelative移动内容</li></ul></li></ul><h1 id="2-使用UIWrapContent优化滚动效率"><a href="#2-使用UIWrapContent优化滚动效率" class="headerlink" title="2. 使用UIWrapContent优化滚动效率"></a>2. 使用UIWrapContent优化滚动效率</h1><p>NGUI 3.7.x以上版本，有个新组件UIWrapContent，当列表内容很多时（甚至内容有无限多，或者循环滚动），可以用它来优化。用法很简单，和UIGrid或UITable等挂在同一层级下，包裹住内容即可。</p><p>注册<code>panel.onClipMove</code>事件（clipOffset改变时，基本上就是在滚动时触发）为<code>WrapContent</code>这个核心方法，其主要完成以下工作：</p><ol><li>根据UIScrollView的方向分为水平和垂直两种处理方式，两者原理一模一样，下面以水平为例。</li><li>获取panel的本地corner坐标，令min=左下角-itemSize，max=右上角+itemSize，遍历每个孩子t进行如下处理：</li></ol><pre><code>// max和min是panel尺寸加减一个物体尺寸的上下限float min = corners[0].x - itemSize;float max = corners[2].x + itemSize;Vector3 center = Vector3.Lerp(corners[0], corners[2], 0.5f);Transform t = mChildren[i];float distance = t.localPosition.x - center.x;// extents为所有内容bounds的半长，ext2即为尺寸if (distance &lt; -extents){    Vector3 pos = t.localPosition;    // 加上尺寸长度，移动到另一端【我们将这种操作称为item的跳转】    pos.x += ext2;    distance = pos.x - center.x;    int realIndex = Mathf.RoundToInt(pos.x / itemSize);    // 在设置面板中，min和max决定了滚动的上下限（可以为负，代表向左滚动的下限），两者相等则无限滚动    if (minIndex == maxIndex || (minIndex &lt;= realIndex &amp;&amp; realIndex &lt;= maxIndex))    {        t.localPosition = pos;        UpdateItem(t, i);        t.name = realIndex.ToString();    }    else allWithinRange = false;}/* 省略向右的情况...... */// 该选项决定是否剔除物体（实际上就是将超出范围的物体隐藏，将范围内的物体显示）以提高性能if (cullContent){    distance += mPanel.clipOffset.x - mTrans.localPosition.x;    if (!UICamera.IsPressed(t.gameObject))        NGUITools.SetActive(t.gameObject, (distance &gt; min &amp;&amp; distance &lt; max), false);}protected virtual void UpdateItem (Transform item, int index){    if (onInitializeItem != null)    {        int realIndex = (mScroll.movement == UIScrollView.Movement.Vertical) ?            Mathf.RoundToInt(item.localPosition.y / itemSize) :            Mathf.RoundToInt(item.localPosition.x / itemSize);        // 调用回调，其中index为物体在孩子列表中的索引，realIndex是物体最终位置所在的索引        onInitializeItem(item.gameObject, index, realIndex);    }}</code></pre><p>下图是以1-9个数字方格为例的UIWrapContent滚动原理</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/Unity/UIWrapContent%E5%90%91%E5%B7%A6%E6%BB%9A%E5%8A%A8%E5%8E%9F%E7%90%86.jpg" alt="UIWrapContent向左滚动原理"></p><p>当滑动列表，每次有item跳转的时候，就会调用<code>onInitializeItem</code>回调（绑定你自定义的设置数据方法），此时就可以根据realIndex从你的数据列表中取得对应的数据，再将数据设置到go上（例如获取go的UILabel并设置其text等等）。</p><h2 id="2-1-需要注意的点"><a href="#2-1-需要注意的点" class="headerlink" title="2.1 需要注意的点"></a>2.1 需要注意的点</h2><ul><li>如果列表是vertical的，由于坐标轴是上正下负，计算出来的realIndex从上到下是对应0到负数。<strong>所以纵向列表取数据时，要将realIndex取绝对值再取数据。</strong></li><li>以vertical为例，要确保wrapContent的孩子个数为<code>panelHeight / itemHeight + 1</code>个，滚动设置自定义数据的行为才是正确的</li><li>参考设置：横向滚动时，<code>minIndex = 0, maxIndex = m_Data.Count</code>；纵向滚动时，<code>minIndex = 1 - m_Data.Count, maxIndex = 0</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> NGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGUI </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGUI源码学习——UILabel</title>
      <link href="/tech/game/unity/ngui-code-uilabel/"/>
      <url>/tech/game/unity/ngui-code-uilabel/</url>
      
        <content type="html"><![CDATA[<p>UILabel是NGUI中用于显示文字的控件。其核心思想是遍历每个字符，将其转化为字体贴图的数据。本篇会抛开BBCode解析，表情符symbol解析，特殊效果（阴影、描边等）等细节，只记录几个渲染字体的核心方法。NGUI有独立的一套BMFont管理工具和类，等以后再另开篇章讲解。</p><p>【参考版本：NGUI 3.6.9】</p><a id="more"></a><h1 id="1-基础要点"><a href="#1-基础要点" class="headerlink" title="1. 基础要点"></a>1. 基础要点</h1><ul><li>基本上只要设置了某个属性，都会使shouldBeProcessed变成true。在必要的时候，例如设置text、fontSize、fontStyle、alignment、OnValidate()，或者在获取父类UIWidget的一些属性，如localSize、drawingDimensions、worldCorners等等，才会根据shouldBeProcessed去调用<code>ProcessText</code>重绘字体。</li><li>NGUIText作为中转处理的静态类，包含了大量的公共静态属性供缓存</li><li>字体方案有两种：Unity自带的动态字体（TTF）和NGUI的BitmapFont（即图字<a href="http://www.angelcode.com/products/bmfont/" target="_blank" rel="noopener">BMFont</a>）。后者在获取glyph信息时会多考虑当前字符与上一个字符的字距。</li></ul><h1 id="2-核心方法"><a href="#2-核心方法" class="headerlink" title="2. 核心方法"></a>2. 核心方法</h1><h2 id="2-1-ProcessText-bool-legacyMode-bool-full"><a href="#2-1-ProcessText-bool-legacyMode-bool-full" class="headerlink" title="2.1 ProcessText(bool legacyMode, bool full)"></a>2.1 ProcessText(bool legacyMode, bool full)</h2><ul><li><code>NGUIText.Update(false)</code>：计算最终字体尺寸、space大小、行高</li><li><code>NGUIText.WrapText</code>：根据rectHeight、maxLines、finalLineHeight算出在widget最多可以容纳多少行。遍历每个字符，依旧获取glyph信息，并维护剩余宽度remainingWidth来决定是否截断显示字符串。该方法还会对空格和换行做一些特殊处理。最后输出fits表示rect是否能容纳得下应该显示的字符串，finalText表示最终显示的字符串</li><li><code>NGUIText.CalculatePrintedSize(mProcessedText)</code>：计算最终字符显示的区域大小，结果可从printedSize属性获取（小于等于rect大小）</li></ul><p>几种Overflow模式的基本原理：</p><ul><li>ShrinkContent缩放原理：循环从ps = mPrintedSize = defaultFontSize开始往下递减，直到ps可以满足在当前rect里容纳显示所有字符。例如当一个240×30的label不能一行显示字号为60的“New\nlabel”，则ps可能会递减到30左右，<code>NGUIText.WrapText</code>计算出可以fit整个rect了，才停止循环。</li><li>ClampContent裁切原理：实际上这种方式没有做任何处理，因为在<code>NGUIText.WrapText</code>的时候就已经按rect大小做截断了</li><li>ResizeFreely自适应原理：一开始先把rect和region设得足够大，WrapText之后再重算printedSize</li><li>ResizeHeight：同ResizeFreely，但只会重设高度，不会重设宽度</li></ul><h2 id="2-2-OnFill-BetterList-verts-BetterList-uvs-BetterList-cols"><a href="#2-2-OnFill-BetterList-verts-BetterList-uvs-BetterList-cols" class="headerlink" title="2.2 OnFill(BetterList verts, BetterList uvs, BetterList cols)"></a>2.2 OnFill(BetterList<vector3> verts, BetterList<vector2> uvs, BetterList<color32> cols)</color32></vector2></vector3></h2><p>在UIWidget调用UpdateGeometry时用到。</p><ul><li><code>UpdateNGUIText</code>：将label的各种属性复制到NGUIText的公共静态属性中</li><li><code>NGUIText.Print(text, verts, uvs, cols)</code>将文本内容输出到列表中。</li><li><code>ApplyOffset</code>用偏移值变换顶点：原理是根据pivotOffset（锚点相对偏移，右上角为(1,1)）和label的宽高插值出offset，然后应用到顶点列表的每个顶点，最后返回offset</li><li>如果有开启阴影，则调用一次ApplyShadow【增加一些顶点】；如果开启描边，则再调用3次ApplyShadow，实质上就是用四个方向的阴影包围来模拟描边</li></ul><h2 id="2-3-NGUIText-Print-text-verts-uvs-cols"><a href="#2-3-NGUIText-Print-text-verts-uvs-cols" class="headerlink" title="2.3 NGUIText.Print(text, verts, uvs, cols)"></a>2.3 NGUIText.Print(text, verts, uvs, cols)</h2><ul><li><code>Prepare(text)</code>：当使用动态字体时，调用Unity API <code>Font.RequestCharactersInTexture</code>刷新所需字符的纹理</li><li>遍历text的每个字符 =&gt;</li><li>处理换行符号，略过非法字符</li><li><code>ParseSymbol</code>解析BBCode，该函数有很多ref参数，用于存放解析结果（如加粗、斜体、下划线等等）</li><li><code>GetSymbol(text, i, textLength)</code>获取有没有图字符号（新版本NGUI label支持表情符解析），有符号走符号分支，否则进入普通字符分支。【下面只讲解普通字符分支】</li><li>处理alignment为居中或右侧的情况</li></ul><p>普通字符处理：</p><ul><li><code>GetGlyph(ch, prev)</code>：根据当前字符ch和上一个字符prev，会根据使用的是位图字体还是动态字体，计算出对应的UV坐标。【得到的GlyphInfo数据结构见下方解释】</li><li>计算subscriptMode不为0（即上标或下标）的情况，算法：glyph.v0和glyph.v1乘以sizeShrinkage常量，然后根据上下标情况，上下偏移y坐标</li><li>若x + w &gt; regionWidth，则将字符换行</li><li>若字符为空格：若BBCode对应是下划线，则替换为“下划线”；若对应中划线，则替换为“减号”；都不对应，则continue</li><li>处理纹理坐标</li><li>根据glyph.channel以不同方式计算顶点颜色</li><li>处理粗体和斜体的情况</li><li>处理下划线或中划线的情况</li><li><strong>该方法最终会为每个字符，在uvs、cols、verts添加4个顶点数据，顺序为左下、左上、右上、右下</strong></li></ul><pre><code>public class GlyphInfo{    public Vector2 v0;          // 字形在生成的text mesh中左下角屏幕坐标    public Vector2 v1;          // 字形在生成的text mesh中的右上角屏幕坐标    public Vector2 u0;          // UV左下角坐标    public Vector2 u1;          // UV右上角坐标    public float advance = 0f;  // 从本字符到下个字符的步进宽度    public int channel = 0;     // RGBA通道值，通常为15（1+2+4+8）}</code></pre><p>注意在输出顶点数据前，已经调用<code>UpdateNGUIText</code>确保NGUIText中已保存所需的数据。</p><h1 id="3-一些要注意的点"><a href="#3-一些要注意的点" class="headerlink" title="3. 一些要注意的点"></a>3. 一些要注意的点</h1><ul><li>使用动态字体时，Unity会生成要用到的字符的纹理，可能一开始是128×128的FontTexture就够了。若后面纹理不够用会重新生成一张新的更大的，触发<a href="https://docs.unity3d.com/460/Documentation/ScriptReference/Font-textureRebuildCallback.html" target="_blank" rel="noopener">textureRebuildCallback</a>，对应到<code>UILabel.OnFontTextureChanged</code>。这个方法会将所有引用到的label的字符，通过font.<a href="https://docs.unity3d.com/460/Documentation/ScriptReference/Font.RequestCharactersInTexture.html" target="_blank" rel="noopener">RequestCharactersInTexture</a>这个API去把所有字符都推到新的字体纹理中。接着再把所有label从panel移除再添加回去。【字体破碎现象很可能就是因为字体纹理重建引起的）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> NGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGUI </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGUI源码学习——UICamera</title>
      <link href="/tech/game/unity/ngui-code-uicamera/"/>
      <url>/tech/game/unity/ngui-code-uicamera/</url>
      
        <content type="html"><![CDATA[<p>UICamera是NGUI中专门用于捕获和分发交互事件的脚本，和UI渲染无关，需要挂在UI摄像机上。其核心思想是在Update中检测Input的各种输入情况，并对屏幕做raycast投射，以决定是哪个go的collider触发事件，最终将事件分发出去。</p><p>【参考版本：NGUI 3.8.1】</p><a id="more"></a><h1 id="1-核心数据结构或类型"><a href="#1-核心数据结构或类型" class="headerlink" title="1. 核心数据结构或类型"></a>1. 核心数据结构或类型</h1><p>有许多公共静态属性，如currentXXX，用于存放当前触发事件的摄像机、ray等等。</p><ul><li>EventType：分World_3D、UI_3D、World_2D、UI_2D，其中3D用<code>Physics.Raycast</code>实现，2D用<code>Physics.OverlapPoint</code>实现；World会根据触发点的世界距离排序（常用于游戏摄像机），UI会根据widget depth排序（常用于UI界面）</li><li><code>enum ControlScheme</code>：有鼠标、触摸、手柄三种类型，触发事件时会根据这个类型做相应的调整（如hover或selected事件的分发在不同设备是不一样的）</li><li>MouseOrTouch数据结构：在事件触发之前会设置一些鼠标或触摸信息</li></ul><pre><code>public class MouseOrTouch{    public Vector2 pos;               // 当前鼠标或触摸的位置    public Vector2 lastPos;           // 上一次鼠标或触摸的位置    public Vector2 delta;             // 当前帧与上一帧的偏移    public Vector2 totalDelta;        // delta的累积，通常用于drag事件    public Camera pressedCam;         // OnPress(true)触发时对应的捕获事件的摄像机    public GameObject last;           // 上一个触发触摸或鼠标事件的go    public GameObject current;        // 当前触发触摸或鼠标事件的go    public GameObject pressed;        // 上一个接收OnPress的go    public GameObject dragged;        // 正在被拖拽的go    public float clickTime = 0f;      // 上一次click事件的时间（通常用于判断doubleClick）    public ClickNotification clickNotification = ClickNotification.Always;  // OnClick的触发条件，None为不触发，Always为总是触发，BasedOnDelta为根据位置移动的偏移量来决定是否发生（偏移量和Thresholds参数有关）    public bool touchBegan = true;    // Touch模式下标识一个触摸是否为开始    public bool pressStarted = false; // 标识是否开始按住    public bool dragStarted = false;  // 标识是否开始拖拽}</code></pre><p>下图为UICamera脚本的配置。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/unity/UICamera%E8%84%9A%E6%9C%AC%E7%9A%84%E9%85%8D%E7%BD%AE.jpg" alt="UICamera脚本的配置"></p><h1 id="2-核心方法"><a href="#2-核心方法" class="headerlink" title="2. 核心方法"></a>2. 核心方法</h1><h2 id="2-1-Notify-GameObject-go-string-funcName-object-obj"><a href="#2-1-Notify-GameObject-go-string-funcName-object-obj" class="headerlink" title="2.1 Notify(GameObject go, string funcName, object obj)"></a>2.1 Notify(GameObject go, string funcName, object obj)</h2><p>本质上是调用<code>go.SendMessage(funcName, obj)</code>，这样就能<strong>触发到具体的UI控件中与funcName同名的方法</strong>（正因为是通过这种特殊方式来调用，所以控件源码中一部分方法会查找不到引用，和反射的道理类似）。</p><p>同时也会发一份消息到genericEventHandler这个用户自己设置的全局go，相当于一个全局的事件接收器。</p><h2 id="2-2-Update"><a href="#2-2-Update" class="headerlink" title="2.2 Update"></a>2.2 Update</h2><p>本质上是对UnityEngine.Input的封装和处理。</p><ol><li>根据useTouch或useMouse标记（在Awake中根据当前平台设置，如手机只有touch），选择执行<code>ProcessTouches</code>或<code>ProcessMouse</code></li><li>调用用户自定义的委托<code>onCustomInput</code></li><li><code>ProcessOthers</code>处理键盘和手柄</li><li>处理tooltip相关逻辑</li></ol><p>以<code>ProcessTouches</code>为例，该方法中用<code>Input.GetTouch</code>获取每个touch分别做如下处理：</p><ul><li>创建MouseOrTouch结构并设置数据</li><li>调用<code>ProcessTouch</code>分发事件</li><li>若touch数目为0，则转为<code>ProcessMouse</code>或<code>ProcessFakeTouches</code>（用于编辑器用鼠标模拟触摸）</li><li><code>ProcessTouch</code>：根据传入的pressed，向<code>currentTouch.pressed</code>分发OnPress事件；根据<code>currentTouch.delta</code>或touch前后go是否不同，向<code>currentTouch.dragged</code>和<code>currentTouch.last</code>分发OnDragStart和OnDragOver事件；后续还有一段处理各种drag start、over、out的逻辑。根据传入的unpressed，分发OnClick、OnSelect、OnHover等事件。</li><li><code>ProcessOthers</code>：处理submit（如回车和手柄的按键）、方向键、返回键、tab键的情况，并对mCurrentSelection分发OnKey事件</li></ul><h2 id="2-3-RayCast（Vector3-inPos）"><a href="#2-3-RayCast（Vector3-inPos）" class="headerlink" title="2.3 RayCast（Vector3 inPos）"></a>2.3 RayCast（Vector3 inPos）</h2><p>给定位置判断有没有与控件产生交互，最终要得到hoveredObject这个结果。</p><ul><li><code>currentCamera.ScreenToViewportPoint(inPos)</code>算出viewport的坐标，并排除一些异常情况<ul><li>【注：屏幕坐标左下角是(0,0)，右上角是(pixelWidth,pixelHeight)】，viewport坐标右上角是(1,1)】</li></ul></li><li><code>currentCamera.ScreenPointToRay(inPos)</code>将屏幕坐标转换为ray。UICamera有个表示射线长度的参数rangeDistance，默认为摄像机远近裁剪面的距离；eventReceiverMask表示摄像机投射ray时哪些层可以响应</li><li>接下来根据EventType采用不同的算法来算ray射到的物体，以两种3D模式为例：<ul><li>World_3D：<code>if (Physics.Raycast(ray, out lastHit, dist, mask)) hoveredObject = lastHit.collider.gameObject</code></li><li>UI_3D：<code>Physics.RaycastAll(ray, dist, mask)</code>获取射线穿到的所有hit，取每个hit对应的collider的go，计算其raycastDepth，并按从大到小排序</li><li>hoveredObject = 上述最大的，且对应panel可见的hit对应的go</li></ul></li></ul><p>【定义：UIWidget.raycastDepth = 自身depth + 所属panel.depth * 1000】<br>【定义：<code>NGUITools.CalculateRaycastDepth(go)</code>计算go下所有可用widget的raycastDepth的最小值】</p><p>参考文献：<a href="http://www.yarpee.com/?p=150" target="_blank" rel="noopener">Yarpee的博文《UICamera》</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> NGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGUI </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式与状态机</title>
      <link href="/tech/complex/DP/fsm-and-state-pattern/"/>
      <url>/tech/complex/DP/fsm-and-state-pattern/</url>
      
        <content type="html"><![CDATA[<p>状态管理是几乎所有游戏开发都会做的一个事情——大到场景管理，小到角色的逻辑状态和动画切换。如果你面对日益增长的复杂的状态分支判断代码而不知所措，状态模式和状态机可能就是救星。状态模式是一个非常简单实用的模式，本文将介绍其基本用法，并结合游戏中的有限状态机（FSM）介绍其各种实际应用和特殊状态机。</p><a id="more"></a><h1 id="1-有限状态机"><a href="#1-有限状态机" class="headerlink" title="1. 有限状态机"></a>1. 有限状态机</h1><p>状态在游戏里面非常常见。想象一个横版过关游戏的主角有如下图状态转换。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/engine/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%8A%B6%E6%80%81%E4%BE%8B%E5%AD%90.jpg" alt="一个简单的游戏角色状态例子"></p><p>FSM有以下特性：</p><ul><li>拥有一组状态，它们之间可以互相切换</li><li>状态机同一时刻只能处于一种状态（事实上防止同时存在两个状态正是使用FSM的原因）</li><li>状态机会接收一组输入或事件</li><li>每个状态有一组转换，每一个转换都关联一个输入并指向另一个状态</li></ul><p>最普通（也是不可取）的做法，是<em>先用if/else分支来判断输入，再用各种bool变量来标记当前是否处于某种状态</em>。随着功能和状态的增加，会不经意破坏已有代码的功能，并引入更多的标记变量使逻辑更加复杂。</p><p>更进一步的做法是将每种状态定义为枚举，颠倒一下上面的处理顺序，<em>先用switch/case判断状态，再在状态中判断输入并做状态切换</em>。如果状态非常少而且不太可能扩展，这是实现状态机最简单有效的做法。</p><p>当问题满足以下几点要求时，FSM将会非常有用：</p><ul><li>一个实体的行为基于它内部状态而改变</li><li>这些状态被严格划分为数量较少的小集合</li><li>实体随着时间变化会响应用户输入或一些特殊事件</li></ul><h1 id="2-状态模式"><a href="#2-状态模式" class="headerlink" title="2. 状态模式"></a>2. 状态模式</h1><p>状态模式实际上就是<strong>将复杂的各个分支判断分离出来成为一个个单独的状态类（继承同个状态基类），然后在业务类中维护状态基类指针m_state，通过多态来分发和切换</strong>。</p><p>为了修改一个状态，之前的做法是给m_state赋值新的枚举值（或常量数字），而将状态抽象为类之后，有两种做法：</p><ul><li>静态状态：如果一个状态对象没有数据成员，可以在状态基类（或其他地方）定义static状态对象。【进一步的，若状态仅包含一个虚函数方法，可以用状态函数来替代状态类，这样m_state就编程函数指针】</li><li>实例化状态：若同类的状态会被多个对象维护，就不能使用静态状态了，只能在状态切换时动态创建实例（要留意清理老的状态实例）。此外，在状态类的处理虚函数中，可以返回一个新的状态实例表示下一个要切换的状态（返回null则状态不变），这样业务类就能根据返回的结果修改m_state的值。</li></ul><h1 id="3-特殊种类的状态机"><a href="#3-特殊种类的状态机" class="headerlink" title="3. 特殊种类的状态机"></a>3. 特殊种类的状态机</h1><h2 id="3-1-并发状态机"><a href="#3-1-并发状态机" class="headerlink" title="3.1 并发状态机"></a>3.1 并发状态机</h2><p>设想一个角色有跑、跳、躲避等状态，现在要添加持枪功能（包括不开火和开火两种状态）。如果执着于传统的FSM，则可能需要跑动和跑动开火等n*m种状态。如果使用并行的两个状态机，则只需要n+m种状态。</p><p>具体实现上，只需要定义多一个状态成员变量，在响应事件多派发一次即可。这种实现适用于两个状态互相独立。若两个状态有依赖，例如不能在跳跃过程中开火，则可能需要在特定的状态中做一些简单的if判断，必要时还需要引用另一个状态。</p><h2 id="3-2-层次状态机"><a href="#3-2-层次状态机" class="headerlink" title="3.2 层次状态机"></a>3.2 层次状态机</h2><p>假设一个角色无论处于站立、走路、跑动、滑动哪个状态，按下B时都要跳跃，按下↓方向键都要躲避。若只用简单的FSM，则会重复不少代码（比如这个例子需要处理4*2个状态转换）。可以在状态模式的基础上，采用继承的方式来复用代码，例如定义OnGroundState来处理跳跃和躲避的状态，四种状态从OnGroundState继承。当有一个事件进来时，如果子状态不处理，则将事件传递给父状态处理。</p><p>不过要注意，这种方法<strong>仅仅只是为了复用代码而去继承，并不符合继承的语义</strong>，像上例中WalkState“是”（is-a）一种OnGroundState吗？因此选用这种“继承层次”的状态机要慎重。</p><h2 id="3-3-下推自动机"><a href="#3-3-下推自动机" class="headerlink" title="3.3 下推自动机"></a>3.3 下推自动机</h2><p>这种状态机使用一个状态<strong>栈</strong>，来解决FSM没有历史记录的问题。举个例子，角色可以从任一状态切换到开火状态，该状态会播放动画，发射子弹并显示一些特效，合理来说开火完成之后应该回到之前的状态。若只用简单的FSM，则需要为每个状态定义一个反向的转换。而使用状态栈时，通过push和pop来记录新状态和恢复历史状态。记住当前状态永远在栈顶，如果不需要历史记录，则切换状态时，总把栈顶的状态修改为最新的状态即可。</p><p>参考文献：《游戏编程模式》第7章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 状态模式 </tag>
            
            <tag> 状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏开发中单例模式的一些思考</title>
      <link href="/tech/complex/DP/singleton-thinking/"/>
      <url>/tech/complex/DP/singleton-thinking/</url>
      
        <content type="html"><![CDATA[<p>往往设计模式的书都是教人如何使用模式，唯独单例模式需要谨慎对待，甚至避免使用。像其他设计决策一样，一旦将一些不必要的单例进行了硬编码，就会带来麻烦。本文描述了单例模式的一些常见问题，以及一些参考解决方案。虽然单例模式存在一些问题，但只要不滥用并仔细思考设计，还是可以享受它带来的好处的。</p><a id="more"></a><h1 id="1-单例模式的基础"><a href="#1-单例模式的基础" class="headerlink" title="1. 单例模式的基础"></a>1. 单例模式的基础</h1><h2 id="1-1-使用方法"><a href="#1-1-使用方法" class="headerlink" title="1.1 使用方法"></a>1.1 使用方法</h2><blockquote><p>单例模式确保一个类只有一个实例，并为其提供一个全局访问入口。</p></blockquote><p>该模式用于一个类如果有多个实例就不能正常运作的情形。最常见的是，这个类与一个<strong>维持着自身全局状态的</strong>外部系统进行交互的情况。像封装底层文件操作API的类，必须知道之前的每一步操作，才能对创建文件和删除文件这些互斥的操作做出正确的反应。</p><p>具体实现上，一个单例类一般会遵循这些规则：private构造方法使得对象只能在类的内部实例化，通过public静态属性来访问这个对象，如以下C++代码所示（以封装文件操作API类为例）。</p><pre><code>class FileSystem{public:    static FileSystem&amp; Instance()    {        // C++11保证一个局部静态变量初始化只进行一次，因此是线程安全的        static FileSystem* instance = new FileSytem();        return *instance;    }private:    FileSystem() {}};</code></pre><h2 id="1-2-模式的特性"><a href="#1-2-模式的特性" class="headerlink" title="1.2 模式的特性"></a>1.2 模式的特性</h2><ul><li>如果不使用这个类，就不会创建实例</li><li>在运行时初始化：若是单纯使用静态类而不是单例，则编译器在main函数调用前就自动初始化静态数据了。这意味着<strong>不能使用运行时才知道的信息</strong>（如从文件中加载的配置），也<strong>不能在单例间互相依赖</strong></li><li>继承单例是一个强大但经常被忽视的特性：参见下面文件封装类跨平台的例子。</li></ul><pre><code>class FileSystem{public:    virtual ~FileSystem() {}    virtual char* Read(char* path) = 0;protected:    FileSystem() {}};class PS3FileSystem : public FileSystem{public:    virtual char* Read(char* path) { // 调用PS3的文件API }}class WiiFileSystem : public FileSystem{public:    virtual char* Read(char* path) { // 调用Wii的文件API }}// 关键的跨平台实现FileSystem&amp; FileSystem::Instance(){#if PLATFORM == PLAYSTATION3    static FileSystem *instance = new PS3FileSystem();#elif PLATFORM == WII    static FileSystem *instance = new WiiFileSystem();#endif}</code></pre><h1 id="2-单例的劣势"><a href="#2-单例的劣势" class="headerlink" title="2. 单例的劣势"></a>2. 单例的劣势</h1><ul><li>单例本质是封装到类中的全局变量<ul><li>令代码晦涩难懂</li><li>全局变量促进了耦合：例如全局音频单例类AudioPlayer穿插在各种业务代码中用于播放声音</li><li>对并发不友好：多个线程都能访问和修改全局变量，很容易导致死锁，条件竞争或其他难以发现的线程同步的bug</li></ul></li><li>单例是个画蛇添足的解决方案：“提供一个全局访问入口”，是使用单例模式的主要原因。像日志类Logger，系统各模块的日志都通过这个单例汇集到一个文件。但这样做的限制是不能创建多个日志器，不能将日志分割为不同的文件。如果后期要修改设计支持多个实例，还需要找出像<code>Logger.Instance.Write</code>这样的调用并逐个修改</li><li>延迟初始化剥离了控制：有的系统初始化时需要耗费一定时间，若在第一次使用时才初始化则可能会引起性能问题。因此在一些对性能有要求的单例中，一般不依赖延迟初始化，即直接像<code>static Singleton m_instance</code>这样定义静态变量，在编译时初始化；或者在恰当的时机（如加载界面）去“假调用”令其初始化</li></ul><p>备注：选择单例还是静态类，取决于后来是否需要将静态类转换为非静态，前者可以传递实例，而后者需要修改每处调用的代码</p><h1 id="3-一些参考解决方案"><a href="#3-一些参考解决方案" class="headerlink" title="3. 一些参考解决方案"></a>3. 一些参考解决方案</h1><ul><li>首先考虑究竟是否需要类：游戏中有许多类都是“管理器”，像SoundManager、ParticleManager，包括其他命名如“XXSystem”、“XXEngine”也类似。在设计这样的功能时，要仔细思考一下究竟是否需要类，是否需要单例模式。</li><li>传递对象到函数中，而不是在函数中调用单例函数：像一些渲染物体的函数需要访问代表图形设备的对象并维护渲染状态，则可能会传递一个context对象到渲染函数中。但另一方面，也要考虑对象是否真的属于某个函数的签名的一部分，像处理AI的函数可能需要写日志，但传递一个Logger对象进去就不合适。</li><li>将单例的获取限制在继承树中：为了进一步减小单例的“全局影响”，可以考虑在基类（如GameObject）中设置单例，并提供一个protected方法供子类获取示例。</li><li>通过其他全局对象访问：可能存在代表整个游戏状态的全局Game或World对象，可以考虑将各种全局对象类包装到这种全局类里面，像<code>Game::Instance.GetAudioPlayer().Play</code>这样调用。这种做法的好处是如果后续要支持多个Game实例（如用于流处理或测试），则几乎不需要修改其他单例类，副作用就是更多的代码耦合到了Game中。</li></ul><p>参考文献：《游戏编程模式》第6章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏引擎的事件系统</title>
      <link href="/tech/game/engine/event-system/"/>
      <url>/tech/game/engine/event-system/</url>
      
        <content type="html"><![CDATA[<p>游戏本质上是事件驱动的。事件是游戏过程中发生、希望关注的事情，例如发生爆炸、玩家被敌人看见、拾取补血包等等。游戏通常需要一些方法做两件事——当事件发生时通知关注该事件的对象，以及让那些对象回应所关注的事件。事件系统采用的设计模式便是知名的观察者模式，本文将介绍事件系统的一些基本原理，以及事件排队的扩展机制。</p><a id="more"></a><p>为了通知游戏对象一个事件己发生，最简单的方法是调用该对象的方法，更进一步的是调用欲通知对象的虚函数。虚函数的后期绑定在某种程度上降低了实现的弹性，实际上，使用静态类型的虚函数作为事件处理程序，会导致GameObject基类需要声明游戏中所有可能出现的事件！这样会令创建新事件变得困难，也阻止了以数据驱动方式产生事件，也违背了让某些类仅注册自己希望关注的事件的初衷。</p><h1 id="1-事件系统的原理"><a href="#1-事件系统的原理" class="headerlink" title="1 事件系统的原理"></a>1 事件系统的原理</h1><h2 id="1-1-把事件封装成对象"><a href="#1-1-把事件封装成对象" class="headerlink" title="1.1 把事件封装成对象"></a>1.1 把事件封装成对象</h2><p>事件实质上由两个部分组成：类型及参数，其中参数为事件提供细节。因此可以把这两个部分封装成事件对象，伪代码如下所示。有些游戏引擎称这种事件结构为消息（message）或命令（command），这些名称强调了本质上，把事件通知对象等于向对象发送消息或命令。</p><pre><code>struct Event{    const U32 MAX_ARGS= 8;    EventType m_type;    U32 m_numArgs;    EventArg m_aArgs[MAX_ARGS];};</code></pre><p>把事件封装为对象有这些好处：</p><ul><li>仅需单个事件处理函数：任何数量的事件类型都可以表示为单个类的实例，仅需要单个虚函数处理所有事件类型（如<code>virtual void OnEvent(Event&amp; event)</code></li><li>持久性：事件对象把其类型及参数储存为数据，因此具有持久性，可用于储存队列稍后处理，或者复制及广播至多个接收者等</li><li>盲目地转发事件：对象可以转发事件至另一对象，而不需要知道事件的内容</li></ul><h2 id="1-2-事件类型"><a href="#1-2-事件类型" class="headerlink" title="1.2 事件类型"></a>1.2 事件类型</h2><p>最简单的方法是使用一个全局的枚举，把每个事件类型映射至一个唯一整数。此方法的优点在于简单及高效，缺点是游戏中所有事件类型都要集中在一起（有点破坏封装的意味，见仁见智）；事件类型是硬编码的，意味着新的事件类型不可通过数据驱动的方式来定义；枚举是索引，有时在中间插入新类型可能会引起一些次序相关的问题。</p><p>另一个事件类型编码方法是使用字符串。此方法是完全自由形式，但问题是有较大机会产生事件名称冲突，也有机会因拼错字而导致不能正常运作，字符串所消耗的内存也较多。不过可以做一些辅助工具来规避字符串带来的风险。在实际项目中，以上两种方法都有被使用，关键还是要权衡其利弊及项目的实际情况。</p><h2 id="1-3-事件参数"><a href="#1-3-事件参数" class="headerlink" title="1.3 事件参数"></a>1.3 事件参数</h2><p>事件的参数通常与函数的参数很相似，而且理论上可以支持任意种类和任意数量的参数。像1.1中代码的<code>EventArg</code>，如果是在C#/Java中，可以将任意类型参数封箱为object发送。但如果是在C/C++中，则只能使用<code>void*</code>指针来模拟，或者使用C++的template模拟。书中还描述了一种用C/C++ union实现的可以容纳多种类型的Variant数据结构，但通用性较弱，此处不赘述。</p><p>事件参数采用以索引为基础的集合，有个问题是参数的意义取决于储存的次序，发送方及接受方都必须理解事件以什么次序储存参数，这可能会导致混淆及bug。可以采用键值对的数据结构来封装一系列事件参数，并通过有实际意义命名的key来提取参数。</p><h2 id="1-4-注册事件与事件处理器"><a href="#1-4-注册事件与事件处理器" class="headerlink" title="1.4 注册事件与事件处理器"></a>1.4 注册事件与事件处理器</h2><p>大部分游戏对象只会关注很小的事件集合，每次都多播或广播事件是很低效的事情。为了提高事件处理的效率，可以让对象注册它们所关注的事件。例如，每个事件类型维护一个链表，内含关注该事件类型的对象，当特定事件触发时只需遍历列表逐个通知即可。</p><p>当游戏对象接收到一个事件，需要以某种方式做出回应，此过程称为事件处理，并通常实现成称为事件处理器（event handler）的函数。在一些高级语言中，可以通过存储函数指针（C/C++）或委托（C#）来注册回调函数，并在收到特定事件时调用。随后，取出<code>EventArg</code>并拆箱还原为原来的参数类型，对其进行处理。</p><p>游戏对象之间经常有依赖性，事件有时需要沿着依赖链传递下去。通常，事件传递的次序是预先由开发者决定的，在事件处理器中通过返回一个布尔值以表示该对象是否处理了该事件，以及是否继续往下转发。支持职责链的事件处理器大概如下所示：</p><pre><code>virtual bool SomeObject::OnEvent(Event&amp; event){    // 先调用基类的处理器    if (BaseClass::OnEvent(event))        return true;  // 基类处理器已处理了事件，返回true表示不再转发    switch (event.GetType())    {        case EVENT_ATTACK:            ResponseToAttack(event.GetAttackinfo());            return false; // 可以转发事件给其他对象        case EVENT_HEALTH_PACK:            AddHealth(event.GetHealthPack().GetHealth());            return true; // 消化了事件，不再转发        // ......        default:            return false;  // 无法识别该事件，转发给其他对象    }}</code></pre><p>即时事件处理器可能导致非常深的调用堆栈，例如对象A向对象B发送一个事件，然后B的事件处理器又发出另一个事件，如此反复。在逻辑有误或使用不当的情况下，极深的调用堆栈有可能会用尽堆栈空间（尤其是造成无限循环的事件发送）。关键还是要遵循一些编码原则，并把事件处理器实现为完全可重入函数，即以递归方式调用事件处理器并不会有任何不良副作用。</p><h1 id="2-事件排队机制"><a href="#2-事件排队机制" class="headerlink" title="2. 事件排队机制"></a>2. 事件排队机制</h1><p>上述的事件机制都是在发送事件时便马上被处理，有的引擎也会容许把事件排队留待未来某刻才进行处理。事件排队有以下好处：</p><ul><li>控制事件处理的时机：让开发者多一道措施确保事件在安全及合适的时机获得处理</li><li>往未来投递事件的能力：可以设置事件的触发时间（例如下一帧、数秒后），这样就相当于实现了一个定时器。具体实现方式：把队列中的事件按送达时间排序，在每帧中先检查队列中首个事件的送达时间，若还未到送达时间，就可立即终止处理（排序保证了之后的事件也是未到时间的）</li><li>处理同时刻事件的优先次序：事件的送达时间通常会量化为整数帧，因此存在同一帧处理多个事件而无法确定顺序的问题。解决方法是为事件设置优先次序（根据需要用整型或若干档枚举表示），当同帧多事件触发时按优先级排序。</li></ul><p>使用事件队列需要考虑的问题：</p><ul><li>增加事件系统的复杂度：给系统加上此功能会增加开发时间和维护成本</li><li>深度复制事件及其参数：若事件是触发后即时处理的，事件参数所占用堆栈内存在事件消费完即销毁。但如果使用事件队列，则需要将整个事件对象（包括参数）深度复制到队列，这样才能<strong>确保没有仅对发送者作用域数据的悬垂引用，并且容许事件无限期储存</strong></li><li>为队列中的事件做动态内存分配：要注意考虑深度复制导致的<strong>动态内存分配开销</strong>，可以考虑快速且不会造成碎片的池分配器或其他小型内存分配器</li><li>调试困难：不能在调试器的调用堆栈看出事件从何而来，以及检查发送者的状态和发送时的环境情况。调试延时事件会变得棘手，若事件会被对象转发的话调试会更加困难</li></ul><p>参考文献：电子工业出版社《游戏引擎架构》第14.7节</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时游戏对象模型（下）——实时更新游戏对象</title>
      <link href="/tech/game/engine/realtime-update-gameobject/"/>
      <url>/tech/game/engine/realtime-update-gameobject/</url>
      
        <content type="html"><![CDATA[<p>大多数低阶引擎子系统，以及游戏对象，都需要周期性更新。差不多所有游戏引擎都在主游戏循环里更新游戏对象的状态，换句话说，它们把游戏对象模型当作另一个需要周期性运行的引擎子系统。本文将简要介绍关于实时更新游戏对象的设计方式及常见问题。</p><a id="more"></a><h1 id="1-实时更新对象的方式"><a href="#1-实时更新对象的方式" class="headerlink" title="1. 实时更新对象的方式"></a>1. 实时更新对象的方式</h1><p>一种最简单但<strong>不可行</strong>的实现方式是，每个游戏对象都有一个虚函数<code>virtual void Update(float dt)</code>，游戏主循环在每一帧遍历全体游戏对象集合并逐一调用Update。每个Update所做的事情大致是更新对象自身的逻辑数据，然后逐个更新其组件（如动画、渲染、粒子、声音组件）。</p><h2 id="1-1-性能限制与批次式更新"><a href="#1-1-性能限制与批次式更新" class="headerlink" title="1.1 性能限制与批次式更新"></a>1.1 性能限制与批次式更新</h2><p>低阶引擎系统都有极严竣的性能限制，<strong>把多个游戏对象的同个子系统更新组合起来批次处理</strong>，要比上述<em>多个游戏对象交错更新子系统</em>更高效，如下图所示。像渲染引擎就是使用批次式更新的典型例子。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/engine/%E4%BA%A4%E9%94%99%E5%BC%8F%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%89%B9%E6%AC%A1%E5%BC%8F%E6%9B%B4%E6%96%B0%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="交错式更新与批次式更新的区别"></p><p>批次式更新带来很多性能效益，包括但不限于：</p><ul><li>最高的缓存一致性：子系统能把各对象的所需数据分配到一个连续的内存区里</li><li>最少的重复运算：可以先执行整体的运算，之后在各对象更新中重用，无须每次在对象中重新计算</li><li>减少资源再分配：交错式更新处理每个对象时须释放及再分配资源，批次式更新则只需每批次一次</li><li>高效的流水线：在某些硬件上可以做一些优化，利用硬件特设的资源并行计算</li></ul><p>性能优势并不是使用批次式更新的唯一原因，<strong>一些引擎子系统从根本上不能以对象单位进行更新</strong>。例如，若一个动力学系统里有多个刚体进行碰撞决议时，孤立地逐一考虑对象，一般不能找到满意的解。</p><h2 id="1-2-对象及子系统的相互依赖"><a href="#1-2-对象及子系统的相互依赖" class="headerlink" title="1.2 对象及子系统的相互依赖"></a>1.2 对象及子系统的相互依赖</h2><p>要正确运行游戏，游戏对象更新的次序是重要的（例如计算某物体的局部坐标需要先计算其父节点的世界坐标）。除了对象之间有依赖关系，各子系统也有依赖关系，而且不是简单的先后关系，例如布娃娃物理模拟系统须与动画系统协同更新。可以在主循环中明确编写各个子系统的更新顺序。</p><p>主循环通常不能简化成每帧每对象调用一次Update，游戏对象可能需要使用多个引擎子系统的中间结果。很多游戏引擎容许游戏对象在1帧中的多个时机编写对应的虚函数“挂钩”进行更新，像Unity GameObject的Update、FixedUpdate、LateUpdate等。游戏对象可按需增加更多更新阶段，但要小心带来多余的调用空的虚函数开销可能很高。</p><h2 id="1-3-桶式更新"><a href="#1-3-桶式更新" class="headerlink" title="1.3 桶式更新"></a>1.3 桶式更新</h2><p>当存在对象间的依赖时，可能会抵触更新次序的规则，有时要轻微调整上述的批次式更新技巧。即不要一次性批处理所有游戏对象，而是把对象按依赖关系分为若干群组（或称为桶bucket），即没有任何依赖关系的对象（依赖树的根）放到第1个桶，依赖树第2层的所有对象放到第2个桶……然后按依赖次序更新每个桶，桶中使用批次式更新，如下图所示。游戏引擎可以明确为依赖树林的深度设限，这样就可以使用固定数目的桶以提高性能。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/engine/%E6%8C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E6%80%A7%E5%88%86%E6%A1%B6%E6%9B%B4%E6%96%B0.jpg" alt="按对象的依赖性分桶更新"></p><h1 id="2-对象状态及“差一帧”延迟"><a href="#2-对象状态及“差一帧”延迟" class="headerlink" title="2. 对象状态及“差一帧”延迟"></a>2. 对象状态及“差一帧”延迟</h1><p>更新游戏对象可视为这样一个过程：每个对象根据$t_1$时刻的状态决定$t_2$（$t_2=t_1+\Delta t$）时刻的状态。理论上，所有游戏对象的状态是瞬间及并行地从时刻$t_1$更新至$t_2$的。但实际上主循环会逐个更新对象，在一轮循环中间中断时则有一些对象处于部分更新的状态（例如某个对象可能已执行姿势动画混合，却未计算物理及碰撞决议）。</p><p>游戏对象在两帧之间状态不一致是混淆和bug的主要来源。当有对象依赖时（如对象B需要根据对象A的速度来决定当前帧自身的速度），程序员必须弄清楚需要的是对象A的之前的状态还是新状态。若需要新状态，而对象A却未更新，就会产生一个更新次序问题，会导致一类称为“差一帧”延迟的bug。解决这个问题通常有以下做法：</p><ul><li>桶式更新：上节已描述，但是必须保证同一个桶内的对象不会互相查询状态</li><li>对象状态缓存：更新时不要就地覆写新的状态，而是保留之前的状态变量，并把新的状态写到另一个变量。这样任何对象都可安全地查询其他对象的之前状态；而且就算是在更新的过程中，它保证永远有一个完全一致的状态；还能通过线性地向前后两个状态插值。这种方法的缺点是多耗一倍内存，而且只能保证在$t_1$状态一致，而$t_2$状态不一定一致</li><li>加上时戳：给每个对象加时戳可轻易分辨对象的状态是在之前还是当前时间</li></ul><p>参考文献：电子工业出版社《游戏引擎架构》第14.6节</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 游戏对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时游戏对象模型（上）——模型架构</title>
      <link href="/tech/game/engine/runtime-gameobject-model/"/>
      <url>/tech/game/engine/runtime-gameobject-model/</url>
      
        <content type="html"><![CDATA[<p>在游戏性基础系统的各种组件中，运行时对象模型可能是最复杂的，通常它会提供这些核心功能：动态产生（spawn）和销毁（destroy）游戏对象，联系底层引擎系统，实时模拟对象行为，对象查询和引用，存档及对象持久性等等。本文将从对象模型架构开始，阐述“以对象为中心”和“以属性为中心”的两种基本架构，接着介绍几种游戏对象引用和查询的方法。</p><a id="more"></a><h1 id="1-各种运行时对象模型架构"><a href="#1-各种运行时对象模型架构" class="headerlink" title="1. 各种运行时对象模型架构"></a>1. 各种运行时对象模型架构</h1><h2 id="1-1-以对象为中心的架构"><a href="#1-1-以对象为中心的架构" class="headerlink" title="1.1 以对象为中心的架构"></a>1.1 以对象为中心的架构</h2><p>这种架构中每个逻辑游戏对象会实现为类的实例，或一组互相连接的实例。然而单纯使用继承和多态会导致一系列类层次结构的问题。</p><h3 id="1-1-1-使用面向对象架构的问题"><a href="#1-1-1-使用面向对象架构的问题" class="headerlink" title="1.1.1 使用面向对象架构的问题"></a>1.1.1 使用面向对象架构的问题</h3><p>类层次结构逐渐变得单一庞大。如下图①实现《吃豆人》（PacMan）的一种简单类结构，随着功能增长，该结构会同时往纵、横方向发展，并出现以下问题：</p><ul><li>类难以理解、维护及修改：要理解一个类，就要理解其所有父类（例如在派生类中修改一个看似无害的虚函数，就可能会违背了众基类中某个基类的假设），参考下图②复杂的单一类树节选</li><li>不能表达多维分类：继承有着“是一个”的语义，导致在分类对象时只能从一个维度去设计。如下图③，各类载具的分类看似合乎逻辑，但如果再加入一种“水陆两用载具”则无从下手</li><li>多重继承的弊端：解决“水陆两用载具”的解决方法之一就是使用C++的多重继承，如下图④。然而多重继承有其严重弊端，此处不再赘述</li><li>使用接口：像C#或Java类只能继承一个类，但可以实现多个接口，这样共用的功能就能抽出来（也称为mix-in类）。如下图⑤，任何继承MHealth的类会有血量信息，并可以被杀</li><li><strong>冒泡效应</strong>：当游戏加入越来越多的功能，程序员很容易不断把若干个类中<strong>公用但与基类无关</strong>的代码上升到基类中（即为了所谓的复用利用了继承的便利），这种趋势会令功能代码沿层次结构上移到基类（冒泡），从而违背类职责应该保持单一的原则</li></ul><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/engine/%E4%BD%BF%E7%94%A8%E5%8D%95%E4%B8%80%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98.jpg" alt="使用单一庞大的类层次结构的各种问题"></p><h3 id="1-1-2-使用“合成”来简化层次结构"><a href="#1-1-2-使用“合成”来简化层次结构" class="headerlink" title="1.1.2 使用“合成”来简化层次结构"></a>1.1.2 使用“合成”来简化层次结构</h3><p>面向对象设计中过度使用“是一个（is-a）”关系，会限制了我们创造新游戏类型的设计选择，而且难以扩展现存类的功能。若像下图左边的继承结构，希望一个游戏对象类有碰撞功能，它必须要继承自CollidableObject ，即使它可能是隐形的而并不需要RenderableObject的功能。若把不同的功能分离为独立的“组件”类，它们互不相干，由一个轻量的GameObject采用“有一个（has-a）”关系持有并管理，如下图右边，则可以大大简化。Unity便是运用这种思想的例子。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/engine/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E5%90%88%E6%88%90%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1.jpg" alt="使用组件合成游戏对象"></p><p>对于GameObject管理其组件声明周期的具体实现，具体的做法是GameObject持有所有可能组件的指针并默认为空，而具体的游戏对象继承GameObject后，自行初始化所需的基本组件，并实现自己的特殊组件。但是当需要扩展新组件时，都要修改GameObject类，不符合开闭原则，因此更好的做法是以下这种GameObject持有Component列表的结构。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/engine/%E4%BD%BF%E7%94%A8%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.jpg" alt="使用通用组件的设计"></p><h2 id="1-2-以属性为中心的架构"><a href="#1-2-以属性为中心的架构" class="headerlink" title="1.2 以属性为中心的架构"></a>1.2 以属性为中心的架构</h2><p>以对象为中心，会自然地关注对象属性和行为。以属性为中心，则是先定义所有属性，再为每个属性键表存储关联该属性的对象，<em>像数据库表就是这种设计</em>。</p><p>这种设计的优点是趋向更有效地使用内存，因为只需储存实际上用到的属性；也更容易使用数据驱动的方式来建模。最后是比以对象为中心的模型更加缓存友好，因为有些游戏硬件的内存存取成本远高于执行指令和运算。把数据连续储存于内存之中，能减少或消除缓存命中失败。这种数据布局方式称为<strong>数组的结构（struct of array）</strong>。以下代码展示了与传统 <em>结构的数组（array of struct）</em>的对比。</p><pre><code>static const U32 MAX_GAME_OBJECTS = 1024;// 传统结构的数组方式struct GameObject{    U32 m_uniqueId;    Vector m_pos;    Quaternion m_rot;};GameObject g_AllGameObjects[MAX_GAME_OBJECTS];// 对缓存更友好的数组的结构方式struct AllGameObjects{    U32 m_UniqueId[MAX_GAME_OBJECTS];    Vector m_Pos[MAX_GAME_OBJECTS];    Quaternion m_Rot[MAX_GAME_OBJECTS];}AllGameObjects g_allGameObjects;</code></pre><p>这种设计的缺点是单凭凑齐一些细粒度的属性去实现一个大规模的行为，并非易事。这种系统也可能更难以除错，因为程序员不能一次性地把游戏对象拉到监视视窗中检查它的属性。</p><h1 id="2-对象引用与世界查询"><a href="#2-对象引用与世界查询" class="headerlink" title="2. 对象引用与世界查询"></a>2. 对象引用与世界查询</h1><h2 id="2-1-对象引用方法"><a href="#2-1-对象引用方法" class="headerlink" title="2.1 对象引用方法"></a>2.1 对象引用方法</h2><h3 id="2-1-1-指针"><a href="#2-1-1-指针" class="headerlink" title="2.1.1 指针"></a>2.1.1 指针</h3><p>每个游戏对象通常需要某种唯一标识符以便互相区分，并且能在运行时或工具方（世界编辑器）找到所需的对象，也可用该标识符作为对象间通信的目标。当通过查询找到一个游戏对象时，需要以某种方式引用它。C/C++中最常见的做法就是使用指针，因为指针是实现对象引用最快、最高效并最容易使用的方式。但使用指针很容易出现孤立对象、过时指针、无效指针等问题，所以开发引擎的团队制定严格的编程惯例，或使用安全的约束方法如智能指针。</p><p>智能指针是一个小型对象，行为与指针非常接近，但其扩展了规避原始C/C++指针所衍生的问题。关于智能指针可参考C++的一些高级书目，此处不赘述，仅建议<strong>尽量不要在项目中尝试自己实现恶心的智能指针</strong>，如果必须使用，尽量选用像Boost这样的成熟实现。</p><h3 id="2-1-2-句柄"><a href="#2-1-2-句柄" class="headerlink" title="2.1.2 句柄"></a>2.1.2 句柄</h3><p>句柄就是某全局句柄表的整数索引，而句柄表则储存指向引用对象的指针。下图说明了此数据结构。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/engine/%E5%8F%A5%E6%9F%84%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8.jpg" alt="句柄引用对象的实现方式及常见应用"></p><p>虽然句柄可以实现为原始整数，但句柄表的索引通常会包装成一个简单类，以提供更方便创建句柄和解引用的接口。以下是一种简单实现（省略其他与句柄无关的实现）。注意在。</p><pre><code>/* GameObject类储存了它的句柄索引，当要创建新句柄时就不用以地址搜寻句柄表了 */class GameObject{private:    GameObjectId m_uniqueId;  // 对象唯一标识符    U32 m_handleIndex;  // 供更快地创建句柄    friend class GameObjectHandle;  // 让它访问id及索引public:    GameObject()    {        m_uniqueId = AssignUniqueObjectId();        m_handleIndex = FindFreeSlotInHandleTable();    }}// 定义句柄表的大小，以及同时间的最大对象数目static const U32 MAX_GAME_OBJECTS = ...;// 全局句柄表，只是简单的数组，储存游戏对象指针static GameObject* g_apGameObject[MAX_GAME_OBJECTS];/* 句柄封装类 */class GameObjectHandle{private：    U32 m_handleIndex;    GameObjectId m_uniqueId;public:    explicit GameObjectHandle(GameObject&amp; object) :        m_handleIndex(object.m_handleIndex),        m_uniqueId(object.m_uniqueId) {}    // 句柄解引用    GameObject* ToObject() const    {        GameObject* pObject = g_apGameObject[m_handleIndex];        if (pObject != NULL &amp;&amp; pObject-&gt;m_uniqueId == m_uniqueId)            return pObject;        return NULL;    }}</code></pre><h2 id="2-2-对象查询方法"><a href="#2-2-对象查询方法" class="headerlink" title="2.2 对象查询方法"></a>2.2 对象查询方法</h2><p>取决于具体的游戏设计，开发者需要根据业务来查询不同种类的对象，例如找出玩家视线范围内的所有敌人角色，找出所有血量少于80%的可破坏游戏对象等等。游戏团队通常要判断，在游戏开发过程中哪些是可能最常用到的查询类型，并实现专用的数据结构加速查询。以下列举了一些可用于加速某类游戏对象查询的专门的数据结构。</p><ul><li>以唯一标识符搜寻：游戏对象的指针或句柄可储存于以唯一标识符为键的散列表或二叉查找树</li><li>对合乎某条件的所有对象进行迭代：可预先以某种条件排序，并把结果储存在某个列表（例如不断维护一个在玩家某半径范围内的所有对象的列表来加速查询实现范围内的敌人）</li><li>搜寻抛射体路径或对某目标点视线内的所有对象：通常会利用碰撞系统实现，多数碰撞系统会提供一些极快的光线投射功能</li><li>搜寻某区域或半径范围内的所有对象：用一些空间散列数据结构去储存游戏对象，如四叉树、八叉树、kd树等等</li></ul><p>参考文献：电子工业出版社《游戏引擎架构》第14.1、14.2、14.5节</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 游戏对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏引擎的游戏性系统简介</title>
      <link href="/tech/game/engine/gameplay-system-introduction/"/>
      <url>/tech/game/engine/gameplay-system-introduction/</url>
      
        <content type="html"><![CDATA[<p>游戏引擎是复杂的多层软件系统，而游戏的本质，并非在于其使用的引擎或技术，而是其游戏性（gameplay）。游戏机制（game mechanics）一词，可以把游戏性这个概念变得更为具体。游戏机制通常定义为一些规则，这些规则主宰了游戏中多个实体之间的互动，如定义玩家的目标、成败的准则、角色的各种能力、游戏体验的整体流程等等。本文将简单介绍用于定义及管理游戏机制的引擎系统及相关工具。</p><a id="more"></a><h1 id="1-剖析游戏世界"><a href="#1-剖析游戏世界" class="headerlink" title="1. 剖析游戏世界"></a>1. 剖析游戏世界</h1><p>游戏类型虽然五花八门，但大多数会有一种基本的结构模式，通常由以下部分组成：</p><ol><li>世界元素<ul><li>静态元素：地形、建筑等等几乎不会动或主动与游戏性交互的物体</li><li>动态元素：角色、NPC、道具、粒子特效、动态光源、区域等等</li><li>区分静态和动态元素，主要是用于优化性能——静态元素都可以预先计算或忽略，减少运行时游戏世界中动态元素的运算</li><li>有一些游戏含有可破坏环境，算是模糊静态和动态元素分界的例子，说明元素是否静态并不是绝对的</li></ul></li><li>世界组块：庞大的游戏世界通常会被拆分成为独立可玩的区域，可以演化成关卡、地图、地区等等。分割关卡有几个原因，首先是内存限制；其次它也是一个控制游戏整体流程的方便机制；最后它可以作为分工的单位，方便开发团队分别构建及管理。</li><li>高级游戏流程：指由玩家<strong>目标</strong>所组成的序列、树或图，可演化成任务、关卡、波（如塔防波次）、胜利条件或失败惩罚。在故事驱动的游戏中，流程可能也包含多个游戏内置电影、过场动画。</li></ol><h1 id="2-游戏世界编辑器"><a href="#2-游戏世界编辑器" class="headerlink" title="2. 游戏世界编辑器"></a>2. 游戏世界编辑器</h1><h2 id="2-1-典型功能"><a href="#2-1-典型功能" class="headerlink" title="2.1 典型功能"></a>2.1 典型功能</h2><p>游戏性内容对应的创作工具便是游戏世界编辑器，其用于定义世界组块，并填入静态及动态元素。所有商用游戏引擎都有某种形式的世界编辑工具，大部分会提供以下列出的主要功能。</p><ul><li>世界组块创建及管理：除了组块管理基本功能外，还可以连接若干静态网格，以及AI用的导航地图、可攀抓边缘信息等等静态数据。有的还提供专门的地形编辑器用于编辑地形（或解析高度场地形）和水体。</li><li>可视化游戏世界：可让开发者大幅提高开发效率，通常3D游戏提供顶、侧、正视图和三维透视视图4部分，2D游戏提供正射视角。有的编辑器直接整合自制的渲染引擎至工具中，有的把自身整合至第三方3D软件，有的会通过与实际的游戏引擎通信，利用游戏引擎来渲染三维视图，甚至整合至游戏引擎本身。</li><li>导航：提供滚动、放大缩小、聚焦某个对象旋转、摄像机飞行模式、记录历史摄像机位置并跳转等等方便开发的功能。</li><li>选取：在编辑器中可以选取个别或框选多个游戏对象，并对它们批量操作。使用光线投射方式选取三维对象时，编辑器可让用户循环选取与光线相交的所有对象，而不是总选取最近者。</li><li>图层：把对象用预设或用户自定义的图层来分组，把游戏世界中的内容有条理地组织起来。图层也是分工的重要工具，多人可以在同个世界组块上的不同图层工作而不冲突。</li><li>属性网格：如下图所示，可视化编辑游戏对象的属性（一般是键值对），不仅可以编辑常见的数值和字符串，还能支持下拉框、复选框、滑块、颜色选取器等控件编辑。<ul><li>选取多个对象后的编辑方式：此高级特性把选中的对象的共有属性混合在一起显示。在网格中编辑公共值时，会把新值更新至所有选取对象的属性中。</li><li>自由格式属性：通常这种属性集会关联到某个用户自定义的对象，以形成新的“自由格式”属性，如光源属性集包含位置、方向、颜色、强度及光源类型属性。</li></ul></li></ul><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/engine/%E5%B1%9E%E6%80%A7%E7%BD%91%E6%A0%BC%E7%A4%BA%E4%BE%8B.jpg" alt="属性网格示例"></p><ul><li>安放对象及对齐辅助工具：除了基本的平移、旋转、缩放工具外，有的编辑器还提供对齐至网格，对齐至地形，对齐至对象，多个对象分布或对齐等功能。</li><li>特殊对象类型<ul><li>光源：通常用特殊图标表示，因为光源没有网格。编辑器可能会尝试模拟光源对场景的照明效果，让设计师能实时调整并能看到场景的最终大致效果。</li><li>粒子发射器：若编辑器是独立于渲染引擎之上，则可简单用图标表示，或尝试在编辑器中模拟效果；若编辑器是内置于游戏引擎，则可以实际模拟调整，达到“所见即所得”的效果。</li><li>区域：即空间中的体积，供游戏侦测相关事件用（如Unity中的trigger）</li></ul></li><li>读/写世界组块：有的引擎把每个组块储存为单个文件，有的可以独立读/写个别的图层；有的引擎使用自定义的二进制文件格式，有的使用如XML的文本格式。</li><li>快速迭代：优秀的编辑器会支持某程度的动态微调功能以供快速迭代。有的编辑器在游戏本身内执行，让用户即时看到改动的效果，有的连接至运行中的游戏，或完全脱机运行。具体的机制并不重要，最重要的是给用户足够短的往返迭代时间。</li></ul><h2 id="2-2-集成资产管理工具"><a href="#2-2-集成资产管理工具" class="headerlink" title="2.2 集成资产管理工具"></a>2.2 集成资产管理工具</h2><p>有些引擎的编辑器会整合游戏资产数据库的其他方面功能，例如设定网格/材质的属性、设定动画/混合树/动画状态机、设置对象的碰撞/物理属性、管理材质资源等，著名的例子有UnrealEd和Unity。它们能对用户提供统一、实时、所见即所得的资产管理视图，促进快速高效的游戏开发过程。</p><p>不同的工具对资产的优化时间点也不一样。</p><ul><li>UnrealEd在导入资产时就会对资产优化，这样在关卡设计上能缩短法代时间，但是改动网格、动画、音频等来源资产会变得更痛苦。</li><li>Source及雷神之锤引擎，把资产优化延后至烘焙关卡、执行游戏之前。</li><li>《光环（Halo）》给用户选择在任意时刻转换原始资源——这些资源在第一次载入至引擎前转换至优化格式并缓存，避免每次执行游戏时都要再做无意义的转换。</li></ul><h1 id="3-游戏性基础系统的组件"><a href="#3-游戏性基础系统的组件" class="headerlink" title="3. 游戏性基础系统的组件"></a>3. 游戏性基础系统的组件</h1><p>如果可以合理地画出游戏与游戏引擎的分界线，那么游戏性基础系统就是刚刚位于该线之下。理论上，我们可以建立一个游戏性基础系统，其大部分是各个游戏皆通用的。实际上不同引擎之间有许多共有模式，以下列出一些常用组件，后续的文章就会逐渐记录这些组件的功能和设计方法。</p><ul><li>运行时游戏对象（runtime game object）模型</li><li>实时更新对象模型</li><li>关卡管理及串流</li><li>目标及游戏流程管理</li><li>消息及事件处理</li><li>脚本</li></ul><p>参考文献：电子工业出版社《游戏引擎架构》第13章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 游戏性系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人体学接口设备（HID）</title>
      <link href="/tech/game/engine/human-interface-device/"/>
      <url>/tech/game/engine/human-interface-device/</url>
      
        <content type="html"><![CDATA[<p>游戏是有互动性的计算机模拟，为游戏而设的人体学接口设备（Human Interface Device，HID）种类繁多，包括摇杆、手柄、键盘、鼠标、Wii遥控器，以及方向盘、跳舞毯、电子吉他等等专用输入设备。本文探讨游戏引擎如何自入体学接口设备读取输入，处理输入，以及向玩家反馈输出。</p><a id="more"></a><h1 id="1-HID的接口技术"><a href="#1-HID的接口技术" class="headerlink" title="1. HID的接口技术"></a>1. HID的接口技术</h1><ul><li>轮询<ul><li>像手柄这样的简单设备，可通过定期轮询硬件来读取输入（通常在主游戏循环里每次迭代轮询一次）</li><li>要明确查询（输出）设备的状态，可直接读取硬件寄存器；读取经内存映射的I/O端口，或通过较高级的软件接口间接读取</li><li>微软为Xbox 360手柄而设的XInput API是简单轮询的好例子。游戏在每帧调用<code>XInputGetState()</code>函数，它与硬件／驱动通信，适当地读取数据，并把所有结果包装成<code>XINPUT_STATE</code>结构，此结构含有手柄设备上所有输入的当前状态</li></ul></li><li>中断：像鼠标这样的设备没必要在静止时还不断发送数据。这类设备通常以硬件中断方式来通信。中断服务程序用来读取设备状态，把状态储存以供后续处理，然后交还CPU给主程序</li><li>无线设备：对于蓝牙设备，软件必须以<strong>蓝牙协议</strong>和它们通信。这种通信一般由引擎主线程以外的线程负责处理，或至少被封装为简单接口供主循环调用。从程序员的角度来说，蓝牙基本和其他传统轮询设备的状态一样</li></ul><h1 id="2-HID的输入输出类型"><a href="#2-HID的输入输出类型" class="headerlink" title="2. HID的输入输出类型"></a>2. HID的输入输出类型</h1><h2 id="2-1-输入类型"><a href="#2-1-输入类型" class="headerlink" title="2.1 输入类型"></a>2.1 输入类型</h2><h3 id="2-1-1-数字式按钮"><a href="#2-1-1-数字式按钮" class="headerlink" title="2.1.1 数字式按钮"></a>2.1.1 数字式按钮</h3><p>数字式按钮只有两个状态——按下（down或press）或释放（up或release），软件中则以1或0表示。有时设备上所有按钮的状态会结合为一个无符号整数值，如XBox 360手柄的状态是以<code>XINPUT_GAMEPAD</code>结构传回。这个结构体第一个字段是一个16位无符号整数变量wButtons，存放所有按钮的状态。每个按钮都会定义一个掩码，实际使用时将wButtons和掩码做&amp;运算来判断是否被按下。</p><h3 id="2-1-2-模拟式轴和相对性轴"><a href="#2-1-2-模拟式轴和相对性轴" class="headerlink" title="2.1.2 模拟式轴和相对性轴"></a>2.1.2 模拟式轴和相对性轴</h3><p>模拟式输入是指可获取一个范围以内的数值。此类输入通常用来代表摇杆的二维位置（使用两个模拟输入， 一个x轴一个y轴）。模拟式输入信号通常都要被数字化，表示为软件中的整数，再送入引擎处理。像Xbox 360手柄拇指摇杆的偏转量（sThumbLX/sThumbLY/sThumbRX/sThumbRY）取值范围是-32768~32767，而左右扳机（bLeftTrigger/bRightTrigger）取值范围是0（没扣压）~255（完全扣压）。</p><p>上述模拟式轴的位置都是<strong>绝对</strong>的，而有些输入是<strong>相对</strong>性的。这类设备不能界定在哪个位置的输入值为0，相反，输入为0代表设备的位置没变动，非零值代表自上次读取输入至今的增量，如鼠标、鼠标滚轮和轨迹球等等。</p><h3 id="2-1-3-加速计及三维定向"><a href="#2-1-3-加速计及三维定向" class="headerlink" title="2.1.3 加速计及三维定向"></a>2.1.3 加速计及三维定向</h3><p>Wii遥控器、PS3的Sixaxis及智能手机都包含加速传感器，能感应xyz三个主轴的加速度。Wii的一些游戏会利用3个加速计去估算控制器在玩家手上的定向。其原理是基于我们在地球表面上玩这些游戏，而地球的1g引力能对物体产生固定的向下加速度。</p><p>若把控制器完美地水平放置，并指向电视方向，那么垂直方向（z）的加速计应量度到大约-1g。若垂直握着控制器，使其指向上方，则可以预期z应为0，而y应为1g（ 因为y传感器会感受到完整的引力效果）。当我们校准加速计得知每个轴的零点，就可以使用逆正弦和逆余弦，轻松求得偏航角、俯仰角和滚动角。</p><h2 id="2-2-输出类型"><a href="#2-2-输出类型" class="headerlink" title="2.2 输出类型"></a>2.2 输出类型</h2><ul><li>震动反馈：模拟游戏角色在游戏中受到扰动或撞击等感觉。震动通常由若干个马达驱动，每个马达带有稍不平衡的负重，以不同速度旋转。游戏可开关这些马达，并通过调节其旋转速度来向玩家双手产生不同的触觉效果</li><li>力反馈：通过由马达驱动的制动器，以其产生的力对抗玩家施于HID上的力。常见于街机赛车游戏——当玩家尝试转方向盘时，方向盘会产生阻力，其输出原理同震动反馈</li><li>其他输入/输出：有些HID设备含扬声器、麦克风等音频接口；较老的像Dreamcast的手柄支持插入记忆卡；Xbox 360手柄和Wii遥控器带有4个软件控制的LED灯；乐器、跳舞毯等特殊设备有其专门的输入／输出类型；近年发展的姿势界面（如Kinect）和VR设备，也是非常独特的HID</li></ul><h1 id="3-游戏引擎的HID系统"><a href="#3-游戏引擎的HID系统" class="headerlink" title="3. 游戏引擎的HID系统"></a>3. 游戏引擎的HID系统</h1><p>多数游戏引擎不会直接使用HID的原始输入数据，而是引入至少一个在HID和游戏之间的间接层，将输入以多种形式抽象化。下面会介绍一些HID系统的典型需求。</p><h2 id="3-1-死区"><a href="#3-1-死区" class="headerlink" title="3.1 死区"></a>3.1 死区</h2><p>假定模拟轴的输入值范围是$I_{min}$到$I_m$，未触碰模拟轴时，稳定及清晰的“未扰动”输入值为$I_0$。</p><p>HID本质上是模拟设备，其产生的电压含有噪声，以致实际上量度到的输入会轻微$I_0$附近浮动。解决办法是引入一个围绕$I_0$的死区。对于摇杆，死区可以定义为$[I_0-\sigma, I_0+\sigma]$；对于扳机，则定义为$[I_0, I_0+\sigma]$。任何位于死区的输入值都可以简单地被钳制为$I_0$。死区必须足够大以容纳未扰动控制的最大噪声，同时也必须足够小以免影响玩家对HID的反应手感。</p><h2 id="3-2-模拟信号过滤"><a href="#3-2-模拟信号过滤" class="headerlink" title="3.2 模拟信号过滤"></a>3.2 模拟信号过滤</h2><p>即使控制器不在死区范围，其输入仍会有信号噪声问题，这些噪声有时候会导致游戏中的行为显得抖动或不自然。由于噪声信号的频率通常比玩家产生的要高。所以，解决办法之一是，先利用低通滤波器过滤原始输入，再把结果传送至游戏中使用。</p><p>结合未过滤输入的时变函数$u(t)$，己过滤输入为$f(t)=(1-a)f(t-\Delta t)+au(t)$，其中参数$a$由帧持续时间$\Delta t$和过滤常数$RC$所确定，即$a=\frac{\Delta t}{RC+\Delta t}$。公式转换C++代码如下：</p><pre><code>F32 lowPassFilter(F32 unfilteredInput, F32 lastFramesFilteredInput, F32 rc, F32 dt) {    F32 a = dt / (rc + dt);    return (1 - a) * lastFramesFilteredInput + a * unfilteredInput;}</code></pre><p>另一个过滤HID输入的方法是计算移动平均。例如，若要计算3帧时间范围内的输入数据平均，只需把原始输入数据简单地储存于3个元素大小的循环缓冲区里，把此数组的值求和除3，就是过滤后的输入值。因为初始时该数组并未填满有效数据，要注意处理前两帧的输入。</p><h2 id="3-3-输入事件检测"><a href="#3-3-输入事件检测" class="headerlink" title="3.3 输入事件检测"></a>3.3 输入事件检测</h2><h3 id="3-3-1-按下和释放按钮"><a href="#3-3-1-按下和释放按钮" class="headerlink" title="3.3.1 按下和释放按钮"></a>3.3.1 按下和释放按钮</h3><p>假设按钮的输入位在释放时为0，按下时为1。可以记录上一帧的状态（32位位整型），和本帧的状态位异或，为1的位表示状态发生变化。再审视每个按钮的当前状态，若某按钮的状态有改变，而当前的状态是按下，则产生按下事件，否则产生释放事件。</p><h3 id="3-3-2-弦（chord）"><a href="#3-3-2-弦（chord）" class="headerlink" title="3.3.2 弦（chord）"></a>3.3.2 弦（chord）</h3><p>弦是指一组按钮，当同时被按下时，会在游戏中产生一个独特行为。一般通过检测两个或以上的按钮状态，当该组按钮全部同时被按下才执行操作。但弦有许多细节值得注意：</p><ul><li>小心避免同时产生个别按钮的动作和弦的动作。要在检测个别按钮的时候，同时检查弦里的<strong>其他按键并没有被按下</strong></li><li>弦的检测代码必须健壮，防止人们按下弦中的某一按钮稍早于其他按钮。有几种方法可以处理这些情况<ul><li>从策划的角度，将按钮输入设计为，弦总是作用于某个按钮的动作再加上额外的动作。例如，若按L1是主武器开火，按L2投射手榴弹，可能L1+L2的弦是令主要武器开火、投射手榴弹，并发送能量波使这些武器的伤害力加倍。这样从玩家的角度来说游戏表现出的行为没有不同</li><li>在个别按钮按下后，加入一段延迟时间，然后才算作是一个有效的游戏事件。在延迟期间（如2或3帧），若检测到一个弦，那么那个弦就会凌驾个别按钮产生事件</li><li>按下单个按钮时立即执行动作，但容许这些动作被之后弦的动作抢占</li><li>按下按钮时检测弦，但之后释放按钮时才产生效果</li></ul></li></ul><h3 id="3-3-3-序列检测"><a href="#3-3-3-序列检测" class="headerlink" title="3.3.3 序列检测"></a>3.3.3 序列检测</h3><p>序列指玩家通过HID，在一段时间内完成一串动作，最常用于格斗游戏，如在0.5-1秒内连续按下“左右左ABA”。序列检测的基本原理是：保留HID输入的动作短期记录，当检测到序列第一个成分，就会把该成分及其时间戳记录在历史缓冲区中。之后，检测到每个后续成分时，需要检查距上一个成分所经过的时间，若时间仍在容许范围内，就把该成分加入缓冲区中。若整个序列于限定时间内完成，就会产生对应的事件。若在过程中检测到无效输入，或超过规定事件，那么整个历史缓冲区会被重置。</p><p>要检测连打按钮频率，只须记录该按钮上一次被按下事件的时间Tlast和两次按下按钮的时间间隔。若该间隔超过了给定的阈值，则不更新Tlast。那么，在有一对新的够迅速的按钮按下事件产生之前，序列会一直判定为无效。</p><p>要检测诸如“在1s内连续按下ABA的序列”，可以参照下面的伪代码。其中<code>ButtonsJustWentDown()</code>函数来检查若干个按钮的按下事件。当成功检测到序列，就会广播指定事件，令整个游戏都能接收到。</p><pre><code>class ButtonSequenceDetector {    U32 m_aButtonIds; // 检测的序列    U32 m_buttonCount; // 序列中的按钮数目    F32 m_dtMax; // 整个序列的最大时限    EventId m_eventId ; // 完成序列的事件    U32 m_iButton; // 要检测的下一个按钮    F32 m_tStart; // 序列的开始时间，以秒为单位public:    void Update() {        ASSERT(m_iButton &lt; m_buttonCount);        // 计算下个预期的按钮，以位掩码表示（把1左移至正确的位索引）        U32 buttonMask = (1U &lt;&lt; m_aButtonid[m_iButton]);        // 若玩家按下预期以外的按钮，废止现时的序列（使用位取反运算检测所有其他按钮）        if (ButtonsJustWentDown(~buttonMask)) {            m_iButton = 0; // 重置        }        // 否则，若预期按钮刚被按下，检查dt及适当更新状态        else if (ButtonsJustWentDown(buttonMask)) {            // 序列中第一个按钮            if (m_iButton == 0) {                m_tStart = CurrentTime();                ++m_iButton;            } else {                F32 dt = CurrentTime() - m_tStart;                // 时间间隔符合要求，序列仍然有效                if (dt &lt; m_dtMax) {                    ++m_iButton;                    // 判断序列是否完成                    if (m_iButton == m_buttonCount) {                        // 广播事件并重置                        BroadcastEvent(m_eventId);                        m_iButton = 0;                    }                }                // 按得不够快，重置                else {                    m_iButton = 0;                }            }        }    }}</code></pre><p>再复杂的序列包含了摇杆方向，例如检测左拇指摇杆沿顺时针方向旋转一周。可以把遥杆位置的二维范围分割成4个象限。顺时针方向旋转时，经过的象限顺序是左上，右上，右下，左下。只要把象限检测当作按钮处理，就可稍修改上文按钮序列检测代码来完成任务。</p><h2 id="3-4-跨平台HID系统"><a href="#3-4-跨平台HID系统" class="headerlink" title="3.4 跨平台HID系统"></a>3.4 跨平台HID系统</h2><p>引擎处理多平台的HID数据时，应该提供某形式的硬件抽象层，使游戏代码和硬件相关细节隔离。此抽象层能把目标硬件的原始控制标识符转化为抽象的控制索引。例如Xbox 360及PS3的两款手柄的控制布局几乎相同，所以可以设立一套抽象标识符来屏蔽它们的差异。</p><h2 id="3-5-输入的重映射"><a href="#3-5-输入的重映射" class="headerlink" title="3.5 输入的重映射"></a>3.5 输入的重映射</h2><p>许多游戏提供给玩家修改键位的选项，这就需要把原始输入映射到最终的游戏功能上。可以给每个游戏功能一个唯一标识符，然后加一个简单的表，把每个抽象的控制索引映射至游戏中的逻辑功能。要改变映射，可以更换整个表，或是让玩家设置该表中的个别条目。</p><p>但要小心不同的输入种类和取值范围，像某个游戏逻辑需要轴，就不能改用按钮操控。为了允许合理的输入映射，可以把所有输入分类并归一化：</p><ul><li>数字式按钮：按钮状态打包成32位字，每一位代表一个按钮的状态</li><li>单向绝对轴（如扳机、模拟式按钮）：产生[O, 1]的浮点数</li><li>双向绝对轴（如摇杆）：产生[-1, 1]的浮点数</li><li>相对轴（如鼠标滚轮、轨迹球）：产生[-1, 1]的浮点数，其中±1代表单帧内最大的相对偏移值</li></ul><h2 id="3-6-上下文相关控制"><a href="#3-6-上下文相关控制" class="headerlink" title="3.6 上下文相关控制"></a>3.6 上下文相关控制</h2><p>许多游戏里一个物理控制会根据上下文有着不同功能，例如若角色站在门前，按“使用”按钮会开门，若角色附近有一个物体，按“使用”按钮会拾起该物体。上下文相关控制可简单地采用状态机来实现，即根据当前状态个别HID控制可能有不同用途。要注意有时还需要实现优先系统，为不同物体赋予权值，来决定同等条件下优先让哪个物体（状态）生效。</p><h2 id="3-7-禁用输入"><a href="#3-7-禁用输入" class="headerlink" title="3.7 禁用输入"></a>3.7 禁用输入</h2><p>在某些场合可能需要禁用玩家的输入，例如过场动画禁用所有输入，玩家经过窄巷暂停自由旋转摄像机。一个较差的方法是使用位掩码来禁用设备上的某些控制，这种方法缺陷是如果忘记重置掩码，很可能使玩家持续失去控制。所以应该小心处理游戏逻辑，并加入一些防故障机制。</p><p>另一个更好的做法是，把禁用某玩家动作及行为的逻辑写进玩家或摄像机的代码里。这样，若摄像机某时刻决定要忽略右拇指轴的输入，游戏引擎内其他系统仍然能自由读取该输入做其他用途。</p><p>参考文献：电子工业出版社《游戏引擎架构》第8章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实时游戏的时间模拟</title>
      <link href="/tech/game/engine/real-time-simulation/"/>
      <url>/tech/game/engine/real-time-simulation/</url>
      
        <content type="html"><![CDATA[<p>游戏是实时的、动态的、互动的计算机模拟，所以<strong>时间</strong>在电子游戏中担当非常重要的角色。游戏中有不同种类的时间——实时、游戏时间、动画的本地时间线、某函数实际消耗的CPU周期等。本文谈及实时、动态模拟软件如何运作，并探讨这类模拟中运用时间的常见方法。</p><a id="more"></a><h1 id="1-抽象时间线"><a href="#1-抽象时间线" class="headerlink" title="1. 抽象时间线"></a>1. 抽象时间线</h1><p>时间线是连续的一维轴，其原点（t=0）可以设置为系统中其他时间线的任何相对位置。时间线可以用简单的时钟变量实现，以整数或浮点数格式储存绝对时间值。时间线可能存在如下几种形式。</p><h2 id="1-1-真实时间线"><a href="#1-1-真实时间线" class="headerlink" title="1.1 真实时间线"></a>1.1 真实时间线</h2><p>可以直接使用CPU的高分辨率计时寄存器来量度时间。此时间线的原点定义为计算机上次启动或重置之时。这种时间的度量单位是CPU周期（或其倍数），但其实只要简单地乘以CPU的高分辨率计时器频率，此单位便可以转换为秒数。</p><h2 id="1-2-游戏时间线"><a href="#1-2-游戏时间线" class="headerlink" title="1.2 游戏时间线"></a>1.2 游戏时间线</h2><p>在正常情况下，游戏时间和真实时间是一致的。但若希望暂停游戏，就可以简单地临时停止对游戏时间的更新，若要把游戏变成慢动作，可以把游戏时钟更新得慢于实时时钟。</p><p>控制游戏时间是很有用的调试工具。例如在追查不正常的渲染时，可以暂停游戏时间，冻结所有动作，然后使用另外时钟的渲染引擎及调试用飞行摄像机继续运作，就能以任意角度观察问题所在。也可以在暂停模式下，手动“逐步更新”推前帧率来调试。要注意这种调试方法暂停游戏时，游戏循环是持续进行的，仅仅是游戏时钟停止，而通过对暂停的时钟加上1/30s去实现单步更新。</p><h2 id="1-3-局部与全局时间线"><a href="#1-3-局部与全局时间线" class="headerlink" title="1.3 局部与全局时间线"></a>1.3 局部与全局时间线</h2><p>可以想象每个动画或音频片段都含有一个局部时间线，其原点定义为片段的开始。在游戏中播放片段时，正常播放、加速、减速、反转等效果可以视觉化为局部到全局时间线的映射。下图给出了几种映射的情况，其中在做缩放播放时，播放速率记为R。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/engine/%E5%B1%80%E9%83%A8%E5%88%B0%E5%85%A8%E5%B1%80%E6%97%B6%E9%97%B4%E7%BA%BF%E6%98%A0%E5%B0%84%E7%9A%84%E5%90%84%E7%A7%8D%E6%83%85%E5%86%B5.jpg" alt="局部到全局时间线映射的各种情况"></p><h1 id="2-测量及处理时间"><a href="#2-测量及处理时间" class="headerlink" title="2. 测量及处理时间"></a>2. 测量及处理时间</h1><h2 id="2-1-帧率与时间增量"><a href="#2-1-帧率与时间增量" class="headerlink" title="2.1 帧率与时间增量"></a>2.1 帧率与时间增量</h2><p>时间增量Δt（delta time）在游戏中非常重要，其值为FPS的倒数（若为60FPS则Δt=16.6ms/f）。假设一个游戏物体以恒定速率v（单位m/s）运行，乘以一帧的时间增量（单位s/f），就能得出该物体每帧的位置变化Δx=vΔt（单位m/f）。<strong>游戏中物体的感知速度依赖于帧时间Δt，因此计算Δt的值是游戏编程的核心问题之一。</strong></p><h3 id="2-1-1-受CPU速度影响"><a href="#2-1-1-受CPU速度影响" class="headerlink" title="2.1.1 受CPU速度影响"></a>2.1.1 受CPU速度影响</h3><p>早期的游戏中，程序员不会尝试在游戏循环中准确量度真实经过的时间，即忽略Δt，以Δx=v计算位置变化。这样的后果是，游戏中物体看上去的速度完全依赖于CPU的速度所产生的帧率。若在较快的CPU上运行这类游戏，游戏看上去就会像快速进带一样。</p><h3 id="2-1-2-基于经过时间的更新"><a href="#2-1-2-基于经过时间的更新" class="headerlink" title="2.1.2 基于经过时间的更新"></a>2.1.2 基于经过时间的更新</h3><p>要开发和CPU速度脱钩的游戏，就要以某种方法度量Δt，只需<em>将CPU的高分辨率计时器取值两次——一次于帧开始时，一次于帧结束时，然后取二者之差就能精确度量上一帧的Δt</em>。绝大部分的游戏引擎都是用这种方法，但它最大的问题是：使用第k帧度量出的Δt去估计第k+1帧的所需时间，这么做不一定准确。有时甚至会产生非常坏的效果，某一帧特别慢导致预测的Δt越来越大，进入低帧率的恶性循环。</p><h3 id="2-1-3-使用移动平均"><a href="#2-1-3-使用移动平均" class="headerlink" title="2.1.3 使用移动平均"></a>2.1.3 使用移动平均</h3><p>游戏循环中每帧之间是有一些连贯性的。例如，若本帧中摄像机对着含许多渲染耗时物体的走廊，那么下一帧有很大机会仍然对着该走廊。因此可以<em>计算连续几帧的平均时间，用来估计下一帧的Δt</em>。此方法能使游戏适应转变中的帧率，同时缓和瞬间帧率尖峰所带来的影响。</p><h3 id="2-1-4-调控帧率"><a href="#2-1-4-调控帧率" class="headerlink" title="2.1.4 调控帧率"></a>2.1.4 调控帧率</h3><p>上述方法都是预测下一帧Δt的做法，难免有误差。预期尝试估算下一帧的经过时间，不如尝试保证每帧都准确耗时固定时间，即帧率调控。首先仍然要度量本帧的耗时，<em>若耗时比目标时间短，则让主线程休眠，直至到达目的时间；若耗时比目标时间长，那么只好白等下一个目标时间</em>。</p><p>当游戏的平均帧率接近目标帧率，此方法才有效。若因经常遇到“慢”帧，就会明显降低游戏质量。因此，仍然需要让将引擎系统设计成能接受任意的Δt。在开发时，引擎停留在“可变帧率”模式，实际运行中，游戏若能一贯地达到目标帧率，就开启帧率调控获其好处。使帧率连续维持稳定对游戏多方面都很重要，例如物理模拟使用的数值积分以固定时间更新运作最佳，或者使游戏录播功能更可靠。</p><p><strong>【题外】</strong>游戏录播的实现方式：需要记录游戏进行时的所有相关事件，并把这些事件及其时间戳储存下来。然后在播放时，使用相同的初始条件和随机种子，就能准确地按时间重播那些事件。理论上，这么做能产生和原来游戏过程一模一样的重播。然而，若帧率不稳定，事情可能以不完全相同的次序发生。此问题的简单解决方法是，同时记录每帧的Δt，使游戏性的逻辑模拟部分能完全重播录制时的状态。若播放时的帧率不能维持原来的速度，可选择以较慢的速度播放，或选择略过渲染一些帧。</p><h3 id="2-1-5-垂直消隐区间"><a href="#2-1-5-垂直消隐区间" class="headerlink" title="2.1.5 垂直消隐区间"></a>2.1.5 垂直消隐区间</h3><p>画面撕裂这种显示异常现象，是指由于CRT显示器的电子枪在扫描中途交换背景和前景缓冲区，导致屏幕上半部分显示了旧的影像，而下半部分则显示了新的影像。为避免画面撕裂，许多渲染引擎会在交换缓冲区之前，等待显示器的垂直消隐区间。等待垂直消隐区间是另一种帧率调控，实际上能限制主游戏循环的帧率，使其必然为屏幕刷新率的倍数。例如，在以60Hz刷新的NTSC显示器上，游戏的真实更新率实际会被量化为1/60s的倍数。若两帧之间的时间超过1/60s，便必须等待下一次垂直消隐区间，即该帧共花了2/60s（30FPS）。</p><h2 id="2-2-高分辨率计时器"><a href="#2-2-高分辨率计时器" class="headerlink" title="2.2 高分辨率计时器"></a>2.2 高分辨率计时器</h2><p>标准C程序库函数time()分辨率为秒，不适合度量游戏帧率。度量时间游戏使用的是现代CPU的高分辨率计时器，这种计时器通常会实现<br>为硬件寄存器，其分辨率为纳秒，如3GHz的奔腾处理器上，计时器每秒递增30亿次。奔腾的<code>rdtsc</code>指令，Win32 API的<code>QueryPerformanceCounter()</code>，一些PowerPC架构的<code>mftb</code>指令等等，都可以查询分辨率计时器。</p><p>要特别注意在一些多核处理器中，每个核有其独立的高分辨率计时器，这些计时器可能会彼此漂移。若比较不同核读取的绝对计算器读数，可能会出现一些奇异情况——甚至是负数的经过时间。</p><h2 id="2-3-时间单位和时钟变量"><a href="#2-3-时间单位和时钟变量" class="headerlink" title="2.3 时间单位和时钟变量"></a>2.3 时间单位和时钟变量</h2><p>大多数计时器都是64位的无符号整数时钟，可以支持非常高的精度及很大的数值范围（3GHz CPU每周期0.333ns，约195年才循环一次），这是最具弹性的表示法。当要度量高精度但较短的时间，例如剖析一段代码的性能，可用32位整数时钟。注意仍然用64位整数变量储存起始和结束时刻，中间的差值才用32位整数变量。</p><p>另一常见方法是把较小的持续时间以秒为单位储存为浮点数，即把以CPU周期为单位的时间度量除以CPU时钟频率。由于32位IEEE浮点数的限制（整数部分占用较少位），应小心避免用浮点时钟变量储存很长的持续时间，最多度量几分钟。若要储存绝对值的浮点时钟，需要定期将其重置为零，以免累加至很大的数值。</p><p>有些游戏引擎支持把时间值设定为自定义单位，如以1/300秒为时间单位，优点是：许多情况下足够精确；约165.7天才会溢出；同时是NTSC和PAL制刷新率的倍数。不过这种时间单位对处理动画时间缩放精度仍不够，但对于处理像枪械每次发射间的空档时间、由AI控制的角色要等多久才开始巡逻这些问题就足够了。</p><h2 id="2-4-应付断点"><a href="#2-4-应付断点" class="headerlink" title="2.4 应付断点"></a>2.4 应付断点</h2><p>当游戏在运行时遇到调试断点，游戏循环会暂停，但CPU实时时钟仍在继续累加，当程序员继续执行程序时，该帧的持续时间会度量出一个巨大的值，显然不适合传到引擎各子系统。最简单的方法就是，在主循环中，若度量到某帧的持续时间超过阈值（如1/10s），则可假定游戏刚从断点恢复执行，于是把增量时间人工设为1/30s或1/60s（或其他目标帧率）。</p><h2 id="2-5-一个简单的时钟类"><a href="#2-5-一个简单的时钟类" class="headerlink" title="2.5 一个简单的时钟类"></a>2.5 一个简单的时钟类</h2><p>以下给出一个简单时钟类的实现。</p><pre><code>class Clock {    U64 m_timeCycles;    // 时钟周期    F32 m_timeScale;    // 时间缩放因子    bool m_isPaused;    // 是否暂停    static F32 s_cyclesPerSecond;    // CPU每秒的周期数    // 将秒数转换为周期数    static inline U64 secondsToCycle(F32 timeSeconds) {        return (U64) (timeSeconds * s_cyclesPerSecond);    }public:    // 游戏启动时调用此初始化    static void init() {        s_cyclesPerSecond = (F32)readHiResTimerFrequency();    }    // 构建一个时钟    explicit Clock(F32 startTimeSeconds = 0.0f) :        m_timeCycles(secondToCycles(startTimeSeconds)), m_timeScale(1.Of), m_isPaused(false)    { }    // 以周期为单位返回当前时间    U64 getTimeCycles() const {        return m_timeCycles;    }    // 应在每帧调此函数一次，并给予真实度量帧时间（以秒为单位）    void update(F32 dtRealSeconds) {        // 非暂停才更新时钟变量        if (!m_isPaused) {            U64 dtScaledCycles = secondsToCycles(dtRealSeconds * m_timeScale);    // 乘以缩放因子，实现时间缩放            m_timeCycles += dtScaledCycles;        }    }    /* 省略其余简单成员函数 */}</code></pre><p>参考文献：电子工业出版社《游戏引擎架构》第7.4、7.5节</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏循环的实现方式</title>
      <link href="/tech/game/engine/game-loop/"/>
      <url>/tech/game/engine/game-loop/</url>
      
        <content type="html"><![CDATA[<p>游戏软件本质上是由一个大循环构成的。本文从最简单的渲染循环开始，讨论各种游戏循环的架构风格，接着针对现代多处理器硬件，简要说明一些让游戏引擎利用多核硬件的常见方法。网络游戏的游戏循环比较特殊，最后也会介绍两种最常见的多人游戏循环架构。</p><a id="more"></a><h1 id="1-基本游戏循环"><a href="#1-基本游戏循环" class="headerlink" title="1. 基本游戏循环"></a>1. 基本游戏循环</h1><h2 id="1-1-渲染循环"><a href="#1-1-渲染循环" class="headerlink" title="1.1 渲染循环"></a>1.1 渲染循环</h2><p>相比于Windows的GUI采用矩形失效技术仅让屏幕有改动的部位重绘，现代3D游戏采用和电影相同的方式产生运动的错觉和互动性——对观众快速连续地显示一连串静止映像，即渲染循环，其最简单的结构如下：</p><pre><code>while (!quit) {    // 基于输入或预设的路径更新摄像机变换    updateCamera();    // 更新场景中所有动态元素的位置、定向及其他相关的视觉状态    updateSceneElements();    // 把静止的场景渲染至屏幕外的帧缓冲（称为“背景缓冲”）    renderScene();    // 交换背景缓冲和前景缓冲，令最近渲染的影像显示于屏幕之上    // （或是在视窗模式下，把背景缓冲复制至前景缓冲）    swapBuffers();}</code></pre><h2 id="1-2-游戏循环的架构风格"><a href="#1-2-游戏循环的架构风格" class="headerlink" title="1.2 游戏循环的架构风格"></a>1.2 游戏循环的架构风格</h2><p>在游戏运行时，多数游戏引擎子系统都需要周期性地提供服务，而它们所需的服务频率各有不同。动画子系统通常需要30Hz或60Hz的更新率，和渲染子系统同步。动力学模拟可能需要更频繁地更新（如120Hz）。像人工智能这种更高级的系统，可能只需要每秒1-2次更新，而且完全不需要和渲染循环同步。</p><p>最简单的游戏循环，是采用<strong>单一循环更新所有子系统</strong>，即在一个无限循环中计算逻辑并渲染画面。此外还有其他常见的架构风格，核心由若干个简单循环组成，再加上不同的修饰。</p><h3 id="1-2-1-视窗消息泵"><a href="#1-2-1-视窗消息泵" class="headerlink" title="1.2.1 视窗消息泵"></a>1.2.1 视窗消息泵</h3><p>Windows平台下，游戏除了要服务引擎本身的子系统，还要处理来自操作系统的消息。因此需要一段成为消息泵的代码来处理，基本原理是先处理来自Windows的消息，无消息时才执行引擎的任务。这种方法的副作用是设置了处理Windows消息为先，渲染和模拟游戏为后的优先次序，导致当玩家在桌面上改变游戏的视窗大小或移动视窗时，游戏就会愣住不动。典型消息泵代码如下：</p><pre><code>while (true) {    // 处理所有Windows消息    MSG msg;    while (PeekMessage(&amp;msg, NULL, 0, 0) &gt; 0) {        TranslateMessage(&amp;msg);        DispatchMessage(&amp;msg);    }    // 再无Windows消息需要处理，执行“真正”的游戏循环迭代一次    RunOneIterationOfGameLoop();}</code></pre><h3 id="1-2-2-回调驱动框架"><a href="#1-2-2-回调驱动框架" class="headerlink" title="1.2.2 回调驱动框架"></a>1.2.2 回调驱动框架</h3><p>游戏引擎子系统和第三方游戏中间套件既可以以程序库方式构成（提供函数和类供随意调用），也有以框架构成的，程序员需提供框架中空缺的自定义实现（编写回调函数），对应用软件的控制流程只有少量甚至没有。</p><p>OGRE引擎提供一套框架，程序员需要从<code>Ogre::FrameListener</code>派生一个类，并覆写两个虚函数：<code>frameStarted()</code>和<code>frameEnded()</code>，OGRE在渲染主三维场景的前后会调用这两个函数。</p><h3 id="1-2-3-基于事件的更新"><a href="#1-2-3-基于事件的更新" class="headerlink" title="1.2.3 基于事件的更新"></a>1.2.3 基于事件的更新</h3><p>在游戏中，事件是指游戏状态的改变，如玩家按下手柄上的按钮、发生爆炸、敌方角色发现玩家等等。多数游戏引擎都有一个事件系统，让各个引擎子系统登记其关注的某类型事件，当那些事件发生时就可以一一回应。</p><p>上述提到的以各种频率周期性更新子系统，就需要<strong>容许发送未来的事件</strong>的事件系统来实现，即事件先置于队列，在设定的时间间隔之后才取出处理。接着，代码可以发送一个新事件，并设定该事件在未来1/30s或1/60s生效，那么这个周期性更新就能一直延续下去。</p><h1 id="2-多处理器的游戏循环"><a href="#2-多处理器的游戏循环" class="headerlink" title="2. 多处理器的游戏循环"></a>2. 多处理器的游戏循环</h1><h2 id="2-1-多处理器游戏机的架构"><a href="#2-1-多处理器游戏机的架构" class="headerlink" title="2.1 多处理器游戏机的架构"></a>2.1 多处理器游戏机的架构</h2><p>上述讨论了基本的单线程游戏循环，而随着并行编程的架构和技术的发展，游戏引擎也需要最大化多核硬件的使用率。Xbox 360和PlayStation 3都是多处理器游戏机，为了有意义地讨论并行软件架构，需要先简单了解它们的内核架构。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/engine/Xbox%20360%E5%92%8CPlayStation3%E7%9A%84%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84.jpg" alt="Xbox 360和PlayStation 3的内核架构"></p><p>多数现代CPU都会提供单指令多数据（SIMD）指令集，其可以让一个运算同时执行于多个数据之上，此乃一种细粒度形式的硬件并行。游戏中最常用的是并行操作4个32位浮点数，可以让三维矢量和矩阵运算加速至4倍。实际使用SIMD指令时，一般要采用封装良好的三维数学库中的函数来计算。</p><h2 id="2-2-分叉与汇合"><a href="#2-2-分叉与汇合" class="headerlink" title="2.2 分叉与汇合"></a>2.2 分叉与汇合</h2><p>基本原理是把一个单位的工作分割成更小的子单位，再把这些工作量分配到多个核或硬件线程（分叉），最后待所有工作完成后再合并结果（汇合）。游戏循环应用分治法后，其结构看上去和单线程循环相似，不过更新循环的几个主要阶段都能并行化。</p><p>举个例子，若动画混合使用线性插值（LERP），其操作可以独立地施于骨骼上所有关节。假设要混合5个角色的一对骨骼姿势，每个骨骼有100个关节，总共要处理500对关节姿势，可以切割成N个批次，每批次含约500/N对关节姿势。其中N按可用的处理器资源来定，如Xbox 360是3或6（3个核，每核有2个硬件线程），PS3是1-6（视有多少个SPU可用）。</p><h2 id="2-3-子系统独立线程与作业模型"><a href="#2-3-子系统独立线程与作业模型" class="headerlink" title="2.3 子系统独立线程与作业模型"></a>2.3 子系统独立线程与作业模型</h2><p>主控线程负责控制及同步这些子系统的次级子系统，子线程用于某些需重复执行且较有隔离性的子系统，如渲染引擎、物理模拟、动画管道、音频引擎等。多线程架构需要线程库支持，Windows上会使用Win32的线程API，UNIX上用类似pthread的库。</p><p>使用多线程的问题之一就是，每个线程都代表相对较粗粒度的工作量（例如把所有动画任务都置于一个线程，把所有物理任务置于另一线程），这会限制多个处理器的利用率。若某个子系统线程未完成其工作，就可能阻塞主线程和其他线程。为充分利用并行硬件架构，另一种方法是把工作分割成多个细小、比较独立的作业（一组数据与操作代码结合成对），作业准备就绪就加入队列，待有闲置的处理器，作业才会从队列取出执行。PS3的SPURS库的作业模型就实现这种方法，其6个SPU只要有闲置就投入处理细粒度的作业。这样有助于最大化处理器的利用率，也可减少对主线程的限制，自然地对任何数量的处理单元进行扩展或缩减。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/engine/%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%8B%AC%E7%AB%8B%E7%BA%BF%E7%A8%8B%E4%B8%8EPS3%E7%9A%84%E4%BD%9C%E4%B8%9A%E6%A8%A1%E5%9E%8B.jpg" alt="子系统独立线程与PS3的作业模型"></p><h1 id="3-网络多人游戏循环"><a href="#3-网络多人游戏循环" class="headerlink" title="3. 网络多人游戏循环"></a>3. 网络多人游戏循环</h1><h2 id="3-1-主从式模型"><a href="#3-1-主从式模型" class="headerlink" title="3.1 主从式模型"></a>3.1 主从式模型</h2><p>网游在在C/S模型下，大部分游戏逻辑运行在服务器上，客户端仅接收设备输入，渲染，处理音频，处理网络请求，以及加上一些预测玩家的代码（为了不让玩家觉得控制的游戏角色反应非常缓慢）。客户端和服务器不一定要运行于两个独立的机器上，运行在同一个机器上也很常见。网游的游戏循环可以实现为客户端和服务器为完全独立的进程；当两者在同一机器上时，可以置于同一进程的两个线程，或者为了节省本地通信的开销，都置于单个线程，由单游戏循环控制。</p><p>必须注意，客户端和服务器的代码可能以不同频率进行更新。假设服务器以20FPS运行（50ms/f），客户端以60FPS运行（16.6ms/f），可以让主游戏循环以频率快者运行（60FPS），服务器每次循环会计算上次更新至今的经过时间，若超过50ms，服务器就会运行一帧，然后重置计时器。</p><h2 id="3-2-点对点模型"><a href="#3-2-点对点模型" class="headerlink" title="3.2 点对点模型"></a>3.2 点对点模型</h2><p>在这种架构下，游戏中每个动态对象，都由其对应的单一机器所管辖。<strong>每个机器对其拥有管辖权的对象就如同服务器，对于其他无管辖权的对象就如同是客户端</strong>，只负责渲染远端管辖者所提供的对象状态。主从模型中，客户端和服务器代码分离得比较开，而在点对点模型中，许多代码都要处理（或实现）为两种游戏对象，一种是本机有管辖权的完整“真实”游戏对象，另一种是“代理版本”，仅含远程对象状态的最小子集。</p><p>注意点对点架构可以设计得更复杂，如其中一机器离开游戏，则该机器所有对象的管辖权必须转移至其他参与该游戏的机器。若有新机器加入游戏，理想地该机器应接管其他机器的一些游戏对象，以平衡每部机器的工作量。以上的讨论带出的重点是，多人架构对于游戏主循环的结构有深远影响。</p><p>参考文献：电子工业出版社《游戏引擎架构》第7.1-7.3、7.6、7.7节</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏引擎中的资源与文件系统</title>
      <link href="/tech/game/engine/resources-and-file-system/"/>
      <url>/tech/game/engine/resources-and-file-system/</url>
      
        <content type="html"><![CDATA[<p>载入及管理多种媒体，是游戏引擎必须具备的能力。多数引擎会采用某种类型的资源（或资产）管理器，载入并管理游戏所需的资源，并确保在同一时间每个媒体文件只可载入一份。每个资源管理器都会大量使用文件系统。本文将介绍现代三维游戏引擎中的各种文件系统API，再分析典型资源管理器的运作方式。</p><a id="more"></a><h1 id="1-文件系统"><a href="#1-文件系统" class="headerlink" title="1. 文件系统"></a>1. 文件系统</h1><h2 id="1-1-文件名和路径"><a href="#1-1-文件名和路径" class="headerlink" title="1.1 文件名和路径"></a>1.1 文件名和路径</h2><p>关于文件和文件夹路径的概念，绝对路径和相对路径的概念，它们在各种操作系统之间的区别，属于常识范畴，此处不赘述。</p><p>关于搜寻路径，是指含若干个路径（以特殊字符分隔）的字符串，寻找文件时会从这些路径逐个寻找，PATH环境变量就是一种搜寻路径。在运行期搜寻资产是费时的做法，而通常资产路径会在运行期之前就得知，所以应该完全避免搜寻资产。</p><p>关于路径API，一般用于对路径进行多种操作，如分离“目录/文件名/扩展名”、使路径规范化、绝对和相对路径互转等等。游戏引擎通常会实现或封装轻量化的路径处理API，以便实现跨平台，从各种特殊的储存媒体（如记忆棒、DVD盘、网络文件系统等等）中存取数据，以及提供操作系统API未能提供的功能，如串流（即在游戏运行中同时载入数据）。</p><h2 id="1-2-基本文件I-O"><a href="#1-2-基本文件I-O" class="headerlink" title="1.2 基本文件I/O"></a>1.2 基本文件I/O</h2><h3 id="1-2-1-文件I-O-API"><a href="#1-2-1-文件I-O-API" class="headerlink" title="1.2.1 文件I/O API"></a>1.2.1 文件I/O API</h3><p>许多游戏引擎都会把文件I/O API封装成自定义的API，这样至少有三个好处：保证I/O API在所有目标平台上均有相同行为；API可以简化到只剩下实际需要的函数，使维护开支维持最小限度；可提供延伸功能，如处理各种特殊的储存媒体（同自定义路径处理API）。</p><p>每次调用输入/输出，都需要称为缓冲区的数据区块，以供程序和磁盘之间传送字节。当API负责管理数据缓冲，就称之为有缓冲功能的API，否则为无缓冲。C标准程序库中，以f开头的文件API是带缓冲的，如<code>fopen()</code>，没有f开头是无缓冲的，如<code>read()</code>。有时自行管理缓冲区是有必要的。例如往日志写数据可能会显著降低性能，可以先把数据累积在内存缓冲，满溢后才写进盘内，甚至把缓冲输出函数置于另一线程里，以避免令主游戏循环发生流水线停顿。</p><h3 id="1-2-2-同步与异步"><a href="#1-2-2-同步与异步" class="headerlink" title="1.2.2 同步与异步"></a>1.2.2 同步与异步</h3><p>C标准库的两种文件I/O库都是同步的，即程序发出I/O请求以后，必须等待读/写数据完毕，程序才能继续运行。为了提高用户体验，往往要使用串流来载入资源，这必须使用异步文件I/O库。多数异步I/O库容许主程序在请求发出后一段时间，等待I/O操作完成才继续运行。有些异步I/O库容许程序员取得某异步操作所需时间的估算，一些API也可以为请求设置时限，并设置请求超时的安排（例如取消请求、通知程序、继续尝试等）。</p><p>异步I/O操作常有不同的优先权，例如从硬盘中串流音频，并且在串流其他资源时播放音频，显然前者优先权高于后者。异步I/O系统必须能暂停较低优先权的请求，才可以让较高优先权的I/O请求有机会在时限前完成。</p><p>关于异步操作（不局限于文件I/O）的实现原理，一般是利用另一线程进行同步操作来实现。主线程调用异步函数时，会把请求放入一个队列，并立即传回。同时，I/O线程从队列中取出请求，并以阻塞I/O函数处理这些请求。请求的工作完成后，就会调用主线程之前提供的回调函数告之该操作己完成。若主线程选择等待完成I/O请求，就会使用信号量处理（每个请求对应一个信号量，主线程把自身处于休眠状态，等待I/O线程在完成请求工作后通知信号量）。</p><h1 id="2-资源管理器"><a href="#2-资源管理器" class="headerlink" title="2. 资源管理器"></a>2. 资源管理器</h1><p>资源管理器由两部分组成：一部分负责管理离线工具链，用来创建资产并把它们转换成引擎可用的形式；另一部分在执行期管理资源，确保资源在使用前已载入内存，不需要时从内存卸下。</p><h2 id="2-1-离线资源管理与工具链"><a href="#2-1-离线资源管理与工具链" class="headerlink" title="2.1 离线资源管理与工具链"></a>2.1 离线资源管理与工具链</h2><h3 id="2-1-1-资产的版本控制"><a href="#2-1-1-资产的版本控制" class="headerlink" title="2.1.1 资产的版本控制"></a>2.1.1 资产的版本控制</h3><p>有些游戏团队使用源码版本控制工具来管理资源。艺术资产通常有极大的数据量，直接从中央版本库复制到本地往往是低效的。以下是一些参考解决方案：</p><ul><li>使用如Alienbrain这种特别针对极大量数据的商业VCS</li><li>在VCS上精心设计一套系统，保证用户只会取得其真正所需的文件到本地</li><li>顽皮狗开发了一款私有工具。用户拥有资产版本库的完整本地视图，只要文件未签出，本地就一直是UNIX的符号链接（Windows可以使用junction实现）以消除数据复制。当签出文件时则移除符号链接，更换为本地副本，签入时则相反。</li></ul><h3 id="2-1-2-资源数据库"><a href="#2-1-2-资源数据库" class="headerlink" title="2.1.2 资源数据库"></a>2.1.2 资源数据库</h3><p>游戏引擎不会使用多数资产原本的格式，而是需要通过一些资产调节管道转换资产，转换过程中每个资源都会产生<strong>元数据</strong>描述如何对资源进行处理。例如描述压缩纹理时，使用哪种压缩方法；描述导出动画片段时，导出哪个范围的帧。大型游戏需要“资源数据库”来管理资源管道所需的数据。无论采用什么形式，数据库都需要提供以下功能：</p><ul><li>以一致的方式处理多种类型的资源</li><li>创建、删除、查看、移动磁盘位置和修改资源</li><li>资源交叉引用其他资源，并维持数据库内的引用完整性</li><li>保存版本历史，含完整日志记录、改动者及事由</li><li>支持不同形式的搜索和查询</li></ul><h3 id="2-1-3-一些成功的资源数据库设计"><a href="#2-1-3-一些成功的资源数据库设计" class="headerlink" title="2.1.3 一些成功的资源数据库设计"></a>2.1.3 一些成功的资源数据库设计</h3><ul><li>虚幻3：由万用工具UnrealEd管理，它是引擎的一部分<ul><li>优点：创建资产后能立即看到资产在游戏中运行的模样；以单一、整合、一致的界面管理所有类型的资源；资产必须明确导入数据库，制作初期便可检查资源有效性</li><li>缺点：所有资源存于少量的大型二进制包文件，不利于VCS合并；资源重命名或移动时，使用虚拟对象，即把旧资源映射到新名称/位置，问题是虚拟对象会闲置、累积起来造成问题，尤其是删除资源时变得严重</li></ul></li><li>顽皮狗的《神秘海域》引擎<ul><li>最初使用MySQL存储资源元数据，并编写自制GUI工具Builder管理，后改用Perforce以提供版本控制，元数据改为XML</li><li>Builder管理演员（包含行为的动态对象）和关卡（含静态背景网格和关卡信息等）两种类型的资源，动画可以组成名为动画包（buddle）的伪文件夹</li><li>引擎含一组基于命令行的工具，用于查询数据库，处理资源原生DCC文件，生成某演员或关卡</li><li>优点：资源粒度小；Builder仅提供必需的特性；源文件映射显而易见，用户容易得知某资源由哪些资产而来；容易更改DCC数据的到处及处理方式；依赖系统会自动处理，生成资产非常容易</li><li>缺点：欠缺预览资产的可视化工具；各种类型的工具没有完全整合</li></ul></li><li>OGRE：拥有一个颇完备、设计非常好的运行时资源管理器，通过一组简单一致又有扩展性的接口就能载入任何类型的资源。缺点在于仅是运行时方案，本身提供的离线处理很弱</li><li>微软的XNA：通过VS IDE的项目管理及生成系统，把游戏资产以同样形式管理及生成</li></ul><h3 id="2-1-4-资产调节管道"><a href="#2-1-4-资产调节管道" class="headerlink" title="2.1.4 资产调节管道"></a>2.1.4 资产调节管道</h3><p>资产调节管道用于将DCC原生格式文件转换成引擎可用的形式，一般经过3个处理阶段：</p><ol><li>导出器：为DCC工具编写自定义插件，将数据导出为某种中间格式。如果DCC不提供自定义方法，则应该把数据存成开放格式，或比较直观的文本格式，或其他可做反向工程的原生格式</li><li>资源编译器：对DCC导出的数据进行一定处理，如把网格的三角形重新排列成三角形带，或压缩纹理。并非所有数据都要编译</li><li>资源链接器：将多个资源先结合成单个有用的包，如复杂的三维模型，然后才载入至游戏引擎。并非所有数据都要链接</li></ol><p>如同程序的源文件，各资产之间也有依赖关系，例如某网格引用若干个材质，这些材质又引用多个纹理。这些依赖关系通常会影响资产在管道内的处理次序，也可告诉我们，当某个源资产做出改动后，要重新生成哪些资产。每个资产调节管道都需要一组规则来描述资产间的依赖关系，并自己搭建系统或使用像make这样的工具来以正确顺序生成资产。一定要管理好资产间的依赖。</p><h2 id="2-2-运行时资源管理"><a href="#2-2-运行时资源管理" class="headerlink" title="2.2 运行时资源管理"></a>2.2 运行时资源管理</h2><h3 id="2-2-1-运行时资源管理器的责任"><a href="#2-2-1-运行时资源管理器的责任" class="headerlink" title="2.2.1 运行时资源管理器的责任"></a>2.2.1 运行时资源管理器的责任</h3><ul><li>确保任何时候，同一个资源在内存中只有一份副本</li><li>管理每个资源的生命期</li><li>处理复合资源的载入（如三维模型）</li><li>维护引用完整性：包括单个资源内的交叉引用，以及资源间的交叉引用</li><li>管理资源载入后的内存用量，确保资源储存在内存中合适的地方</li><li>容许按资源类型，载入资源后执行自定义的处理</li><li>通常提供统一的易扩展的接口管理多种资源类型</li><li>若引擎支持，则要处理串流</li></ul><h3 id="2-2-1-资源文件及目录组织"><a href="#2-2-1-资源文件及目录组织" class="headerlink" title="2.2.1 资源文件及目录组织"></a>2.2.1 资源文件及目录组织</h3><p>资源一般储存为磁盘上的文件，并位于使创作者方便而组织的树状目录中。但引擎通常不会理会资源被放置于资源树中的哪个位置，引擎会把多个资源包裹为单一文件，这种手法能将寻道时间、开启每个文件的时间、从文件读至内存的时间都降到最低。</p><p>OGRE使用ZIP存档资源，因为ZIP是开放格式，内部虚拟文件有相对路径，可被压缩（载入数据后解压所花的时间，通常比读取无压缩数据所花的时间少），并可视为模块（例如把需要本地化的资产打包，针对不同语言制作不同版本的ZIP）。虚幻3采取类似的手法，但是其所有资源都必须置于大型的pak自定义格式文件中，并不容许资源以盘上独立文件出现。</p><h3 id="2-2-2-资源文件格式和GUID"><a href="#2-2-2-资源文件格式和GUID" class="headerlink" title="2.2.2 资源文件格式和GUID"></a>2.2.2 资源文件格式和GUID</h3><p>每类资源都可能有不同的文件格式。单一文件格式也可储存多种不同类型的资产，如Granny的文件格式可轻易用来储存任何种类的数据。许多引擎会自定义文件格式，因为引擎所需部分信息可能没有标准格式可以支持，以及对资源脱机处理，以让其遵从某种内存布局加速运行时载入。</p><p>所有资源都需要GUID来识别，最常见就是使用资源的文件系统路径（操作系统保证两个文件不能有相同的路径），也有使用128位散列GUID的。虚幻3的GUID格式是包名和包内资源路径串接而成，像《战争机器》的一个资源GUID为<code>Locust_Boomer.PhysicalMaterials.LocustBommerLeather</code>。</p><h3 id="2-2-3-资源注册表"><a href="#2-2-3-资源注册表" class="headerlink" title="2.2.3 资源注册表"></a>2.2.3 资源注册表</h3><p>资源管理器都含某种形式的资源注册表，以<strong>保证在任何时间，载入内存的每个资源只会有一份副本</strong>。最简单的实现方法是使用字典，键为资源的GUID，而值是指向内存中资源的指针。资源载入内存时，加进资源注册表字典。卸下资源时，就删除其注册表记录。</p><p>若不能从表中找到请求的资源，最直觉的处理手法就是自动载入该资源。但这样做可能会因为临时从硬盘或光驱等缓慢设备读取数据而严重拖慢游戏帧率。因此引擎可采取这两种替代手法：游戏进行中完全禁止加载资源（游戏关卡的所有资源在游戏进行前全部加载，那时候通常是loading界面）；或资源以相对较难实现的异步形式加载，如玩关卡A时，关卡B的资源在后台加载。</p><h3 id="2-2-4-资源生命期"><a href="#2-2-4-资源生命期" class="headerlink" title="2.2.4 资源生命期"></a>2.2.4 资源生命期</h3><p>资源管理器的职责之一是自动管理资源生命期，或对游戏提供所需API供手动管理。每个资源对生命期有不同需求：游戏持续的所有时间（如角色网格、纹理、动画，HUD的纹理字形等等），持续某一关卡的时间，短于所在关卡的时间（如过场动画），即时串流（如BGM、环境音效等）。</p><p>某资源的载入时期通常在玩家第一次看见该资源便能决定，但何时卸下资源归还内存，就难以回答，因为可能存在多个关卡共享的资源。解决方案之一就是对资源引用计数，即载入新关卡时，遍历所需资源并引用加1，再遍历即将结束的关卡的资源，所有引用减1。下图给出了资源引用计数的例子。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fengine%2F%E8%BD%BD%E5%85%A5%E6%88%96%E5%8D%B8%E4%B8%8B%E4%B8%A4%E4%B8%AA%E5%85%B3%E5%8D%A1%E6%97%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%98%E5%8C%96.jpg" alt="载入或卸下两个关卡时资源的引用变化"></p><h3 id="2-2-5-资源的内存管理"><a href="#2-2-5-资源的内存管理" class="headerlink" title="2.2.5 资源的内存管理"></a>2.2.5 资源的内存管理</h3><p>资源加载的内存位置可能不同，像纹理、顶点缓冲、着色器驻留在显存，大部分资源驻留在主内存。设计游戏引擎时，有时用已有的内存分配器来设计资源系统，有时则要让内存分配器配合资源管理所需。</p><ul><li>基于堆栈分配器：若游戏是以线性关卡为中心，且内存足够容纳各个完整关卡，则可用堆栈分配器。注意栈顶端先分配驻留资源（LSR，各关卡共享的资源），再分配关卡所需内存。</li><li>基于池分配器：因为每个内存组块大小相同，要注意设计资源数据时，必须避免大型连续数据结构，容许资源能被切割成同等大小的块。这种分配方式天生的问题就是文件内<strong>最后的组块</strong>空间被浪费。选择组块大小时，可以考虑设为操作系统I/O缓冲区大小的倍数，如512KB。</li><li>资源组块分配器：专为解决上述组块浪费内存而设的分配模式。只需管理一个链表，内含所有未用满内存的组块以及自由内存块的位置及大小。这种方案有一个问题是卸下资源内存时，其“边角”的组块也会同时消失。解决方案是只利用该种分配器分配<strong>和对应关卡生命期相同的内存</strong>，这需要独立地管理每个关卡的组块，且用户请求分配时指明从哪个关卡分配内存。</li><li>分段资源文件：将资源文件分为若干段，每段分为若干个组块（与池分配器配合）。各段的作用不同，有的是为主内存而设的数据，有的是仅在载入过程中使用、载入后被弃置的临时数据，有的是发行版本不会载入的调试信息</li></ul><h3 id="2-2-6-资源的交叉引用"><a href="#2-2-6-资源的交叉引用" class="headerlink" title="2.2.6 资源的交叉引用"></a>2.2.6 资源的交叉引用</h3><p>资源的交叉引用意味着资源间的依赖性，所以资源数据库可以表达为依赖对象所组成的有向图。交叉引用可以分为内部（单个文件里对象间的引用）和外部（引用另一个文件的对象）。下图给出了资源数据库的交叉引用例子。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fengine%2F%E8%B5%84%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E4%BE%8B%E5%AD%90.png" alt="资源数据库的交叉引用例子"></p><h4 id="2-2-6-1-处理资源内部引用"><a href="#2-2-6-1-处理资源内部引用" class="headerlink" title="2.2.6.1 处理资源内部引用"></a>2.2.6.1 处理资源内部引用</h4><p>在C++中， 由于指针的内存地址总会变，而且离开运行中的程序就失去意义，所以不能用指针来表示对象间的依赖。可以将资源引用存为GUID（全局唯一的字符串或散列码），资源管理器要维护一个全局资源查找表，其中键为GUID，值为资源在内存中的地址。</p><p>储存对象到二进制文件的另一常用方法是，把指针转换为为文件偏移值，并建立指针修正表。下图给出了储存二进制文件以及将文件载入内存的指针修正示意，具体过程为：①把每个对象的内存影响遍历一次，顺序写至文件成为连续映像；②写进文件的代码，清楚知道对象的数据类型和类，也就知道每个对象的指针在哪里，把这些指针位置储存到指针修正表并一同写进文件；③载入文件至内存时，映像内对象仍保持连续，并凭借修正表修正所有指针。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fengine%2F%E5%82%A8%E5%AD%98%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%B0%86%E6%96%87%E4%BB%B6%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98%E7%9A%84%E6%8C%87%E9%92%88%E4%BF%AE%E6%AD%A3%E7%A4%BA%E6%84%8F.jpg" alt="储存二进制文件以及将文件载入内存的指针修正示意"></p><p>从文件载入C++对象，必须调用对象的构造函数。这个问题有两个常见解决方案：使用纯C结构体来储存数据或使用无虚函数、只含不做事情的平凡构造函数的C++ struct/class；表里记录对象属于哪个类，并使用<a href="https://en.wikipedia.org/wiki/Placement_syntax" target="_blank" rel="noopener">placement new</a>语法调用构造函数，像下面的代码所示。</p><pre><code>void* pObject = ConvertOffsetToPointer(objectOffset);::new(pObject) ClassName;  // placement new语法，ClassName为对象所属的类名</code></pre><h4 id="2-2-6-2-处理资源外部引用"><a href="#2-2-6-2-处理资源外部引用" class="headerlink" title="2.2.6.2 处理资源外部引用"></a>2.2.6.2 处理资源外部引用</h4><p>以上提及的两个方案，仅对资源内部引用有效。要正确表示外部引用，除了指明偏移值或GUID，还要加上资源对象所属文件的路径。一般做法是：载入每个资源文件时，扫描文件中的交叉引用表，并载入所有被外部引用但未载入的资源文件，当载入所有互相依赖的资源时，就用主查找表把所有指针转换成真实的内存地址。</p><h3 id="2-2-7-资源载入后初始化"><a href="#2-2-7-资源载入后初始化" class="headerlink" title="2.2.7 资源载入后初始化"></a>2.2.7 资源载入后初始化</h3><p>有一些资源载入内存时需要进行一些无法避免的初始化，例如三维网格的顶点和索引载入主内存后，几乎总是要传送至显存，而且只能在运行时进行。在C++中，可以使用多态为每个类设置如<code>Init()</code>和<code>Destroy()</code>的虚函数用于独立初始化和销毁工作。载入后初始化和资源内存分配策略息息相关，有时初始化会在文件的数据上新增数据（如额外计算类中的成员数据），有时初始化的数据用来取代己载入的数据（如引擎载入过时格式的网格数据，自动转换为最新格式，以保证向后兼容）。可以采用先载入到临时内存区域，初始化完成后再把相关数据复制到内存最终位置。</p><p>参考文献：电子工业出版社《游戏引擎架构》第6章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏引擎支持系统（下）</title>
      <link href="/tech/game/engine/engine-support-system-2/"/>
      <url>/tech/game/engine/engine-support-system-2/</url>
      
        <content type="html"><![CDATA[<p>游戏编程中需要使用各种各样的集合型数据结构，称为容器或集合。字符串看似是个简单基本的数据类型，但在游戏引擎中会涉及许多设计问题和限制。此外，游戏引擎总是伴随大量可调校的选项，有的通过游戏中的选项菜单给玩家调校，有的则只为游戏开发团队设置，在正式发行时被隐掉或去除。</p><p>本文将接着<a href="/tech/game/engine/engine-support-system-1/">上一篇</a>，从游戏引擎的角度描述容器、字符串和引擎配置等游戏引擎支持系统。</p><a id="more"></a><h1 id="1-容器"><a href="#1-容器" class="headerlink" title="1. 容器"></a>1. 容器</h1><p>常见的容器类型包括但不限于：数组、动态数组（可变长）、链表 、堆栈、队列、双端队列、优先队列（二叉堆）、树、二叉查找树（红黑树、伸展树、AVL树等）、字典、集合、图、有向非循环图。常见操作有：插入、移除、顺序访问/迭代、随机访问、查找、排序等等。</p><p>访问容器元素通常都会使用迭代器，它“知道”如何高效地访问容器中的某个元素，移至下一个元素，并用某种方式表示是否遍历完所有元素。使用迭代器的好处是：避免破坏容器类的封装，简化迭代过程。</p><h2 id="1-1-是否建立自定义的容器类"><a href="#1-1-是否建立自定义的容器类" class="headerlink" title="1.1 是否建立自定义的容器类"></a>1.1 是否建立自定义的容器类</h2><p>许多游戏引擎会提供常见容器的自定义实现，而非使用第三方库，原因如下：</p><ul><li>完全掌控：控制数据结构的内存需求、具体算法、分配内存时机等</li><li>优化的机会：如借助游戏机独有的硬件功能来优化</li><li>可定制性：提供第三方库不常见的功能，如搜寻n个最相关的元素</li><li>消除外部依赖：使用第三方库有无法自行调试维护的风险</li></ul><p>第三方库功能强大，使用方便，但有时并不适合游戏引擎。如果决定要使用第三方库，要对它们的优缺点有全方位的了解。</p><ul><li>STL<ul><li>优点：功能丰富；跨平台；几乎所有C++编译器都自带</li><li>缺点：学习曲线陡峭；相比自定义数据结构速度较慢；占用更多内存；进行许多动态内存分配；各编译器的实现微小差异导致移植多平台麻烦</li><li>STL比较适合PC上的引擎，而不适用于游戏主机</li><li>使用经验：用某个STL类前，充分认识其效能和内存特性；避免在可能的性能瓶颈处使用STL；占小量内存的情况才使用STL；若引擎需要支持多平台，推荐会用STLport</li></ul></li><li>Boost<ul><li>优点：提供许多STL没有的有用功能；提供解决STL设计或实现上的问题的替代方案；有效处理智能指针这种复杂问题；文档写得很好（也是优秀的学习材料）</li><li>缺点：生成颇大的.lib文件，不适合小型项目；不保证支持向后兼容；小心阅读许可证内容</li></ul></li><li><a href="http://loki-lib.sourceforge.net/" target="_blank" rel="noopener">Loki</a>：其模板元编程功能极其强大，但代码可能望而生畏，难以使用，而且某些元件依赖编译器的“副作用”行为。Loki不适合胆小者，但是其设计理念非常值得学习</li></ul><h2 id="1-2-一些常用数据结构的使用建议"><a href="#1-2-一些常用数据结构的使用建议" class="headerlink" title="1.2 一些常用数据结构的使用建议"></a>1.2 一些常用数据结构的使用建议</h2><ul><li>动态数组：游戏编程中大量使用固定大小数组以避免动态分配的开销，而且因连续而对缓存友好。可以在开发期选用动态数组，当确定适当的内存预算时，将其改为固定大小的数组（可以自行建立一个兼容<code>std::vector</code>接口的模板</li><li>链表<ul><li>外露式表：节点保存<strong>指向实际元素</strong>的指针。优点是一个元素能同时置于多个链表，缺点是必须动态分配节点。使用池分配器是最佳选择。</li><li>侵入式表：元素的数据结构被嵌入节点。优点是无须动态分配，缺点是没有外露式表那么有弹性。</li><li>若不惜一切代价都要避免动态内存分配，则选用侵入式表；若能负担得起池分配的开销，或链表中的实例来自第三方库，则选用外露式表</li></ul></li><li>字典和散列表：注意散列（把任意类型的键转换为整数）函数的选择是关键。若键为32位整数，把其位模式诠释为32位整数；若键为字符串，则把字符串中所有字符的ASCII或UTF码合并为单个32位整数，常见的字符串散列函数有LOOKUP3、CRC32、MD5等等</li></ul><h1 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h1><h2 id="2-1-字符串类"><a href="#2-1-字符串类" class="headerlink" title="2.1 字符串类"></a>2.1 字符串类</h2><p>字符串类虽然方便，但有隐性成本：传递字符串对象时，函数声明或使用不当引起多个拷贝构造函数的开销；复制字符串涉及动态内存分配。若一定要使用字符串类，应该查明其运行性能特性在可接受的范围，并让所有使用它的程序员知悉其开销。</p><p>在储存和管理文件系统路径时，使用特化的字符串类（如Path类）来处理多平台的字符串差异，在游戏引擎中是很有价值的。</p><h2 id="2-2-唯一标识符"><a href="#2-2-唯一标识符" class="headerlink" title="2.2 唯一标识符"></a>2.2 唯一标识符</h2><p>唯一标识符（64位或128位的GUID字符串）用于识别游戏对象或资产，由于数量非常多，大量的比较在游戏中可能极有影响。最好找到一种方法，既保留字符串的表达能力和弹性，又要有整数操作的速度。可以把字符串散列并存于表中（该过程称为字符串扣留），并通过散列码（也称为字符串标识符，string id或SID）取回原来的字符串，但要选取恰当的散列函数保证不碰撞。</p><p>因为字符串扣留（散列，分配字符串内存，复制至查找表）非常缓慢，所以通常<strong>在运行时就进行，而且仅进行一次，把结果储存备用</strong>。</p><h2 id="2-3-本地化"><a href="#2-3-本地化" class="headerlink" title="2.3 本地化"></a>2.3 本地化</h2><p>对每个向用户显示的字符串，都要事先翻译为需要支持的语言（程序内部使用的，永不显示于用户的字符串无须本地化）。除了通过使用合适的字体，为所有支持语言准备字符字形，游戏还需要处理不同的文本方向（针对一些阅读顺序很特殊的语言）。</p><p>推荐先阅读这篇文章：<a href="http://local.joelonsoftware.com/wiki/The_Joel_on_Software_Translation_Project:%E8%90%AC%E5%9C%8B%E7%A2%BC" target="_blank" rel="noopener">《每个软件开发者都绝对必知的Unicode及字元集必备知识(没有借口！)》</a>。游戏引擎中最常采用的是UTF-8和UTF-16。</p><h3 id="2-3-1-Windows下的Unicode"><a href="#2-3-1-Windows下的Unicode" class="headerlink" title="2.3.1 Windows下的Unicode"></a>2.3.1 Windows下的Unicode</h3><p>在Windows下，<code>wchar_t</code>用来表示单个“宽”UTF-16字符（WCS），<code>char</code>则用作ANSI字符及多字节UTF-16字符串（MBCS）。Windows容许程序员编写<strong>字符集无关</strong>的代码，即提供<code>TCHAR</code>数据类型，它会根据实际所用的字符集自动typedef为特定的类型。</p><p>注意Windows中各种API和标准函数库，无前缀表示普通ANSI字符，前缀为“w”“wcs”表示宽字符，缀为“mbs”表示多字节UTF-16，如<code>strcmp()</code>、<code>wcscmp()</code>和<code>_mbscmp()</code>。</p><p>对于游戏机上的Unicode，Xbox 360开发套件几乎完全采用WCS字符串。不同的引擎采用哪种编码并不重要，重要的是在项目中尽早决定，并始终贯彻使用。</p><h3 id="2-3-2-其他本地化要考虑的事"><a href="#2-3-2-其他本地化要考虑的事" class="headerlink" title="2.3.2 其他本地化要考虑的事"></a>2.3.2 其他本地化要考虑的事</h3><ul><li>本地化不仅包括字符，还包括录制语音、带文字的纹理，还要注意一些符号在不同文化中意义的差别，注意不同市场的评级界限</li><li>本地化系统需要建立字符串数据库，通过SID以及全局的“当前语言”设定来查找对应的语言字符串。其函数声明可能为：<code>const wchar_t* getLocalizedString(const char* sid)</code></li><li>数据库的实现细节不是很重要，可以用CSV，也可以用专门的DBMS</li><li>程序员切记<strong>不要硬编码原始字符串</strong>，而是采用上述查找函数取得所需字符串。注意字符串可能需要处理像<code>&quot;Player {0} Score: {1}&quot;</code>这样的格式化串</li></ul><h1 id="3-引擎配置"><a href="#3-引擎配置" class="headerlink" title="3. 引擎配置"></a>3. 引擎配置</h1><h2 id="3-1-读写选项"><a href="#3-1-读写选项" class="headerlink" title="3.1 读写选项"></a>3.1 读写选项</h2><p>可配置选项可简单实现为全局变量或单例中的成员变量，这些选项必须可供用户配置，储存到硬盘、记忆卡或其他媒体，游戏能随时读取。下面是一些读写选项的方法：</p><ul><li>文本配置文件：如INI、XML、JSON等等</li><li>经压缩的二进制文件：主要用于老式游戏主机上储存空间极其有限的记忆卡</li><li>Windows注册表：以树形式存储，内部节点为注册表项（类似文件夹），叶节点以键值对储存选项。任何应用程序都可预留一个注册表项存储任意内容</li><li>命令行选项：通过扫描命令行取得选项设置</li><li>环境变量</li><li>线上用户设定档：存储在中央服务器，必须通过联网存取，一般用于存储用户成就、已购买或解锁的游戏内容、游戏选项及其他信息</li></ul><h2 id="3-2-个别用户选项"><a href="#3-2-个别用户选项" class="headerlink" title="3.2 个别用户选项"></a>3.2 个别用户选项</h2><p>个别用户选项保留了每个玩家自己配置其喜欢的选项，与全局选项区分开来。需要小心控制每个玩家只能“看见”自己的选项，而不会遇见其他玩家在同一设备的选项。</p><p>在Windows上，应用程序通常在<code>C:\Documents and Settings</code>的隐藏文件夹<code>Application Data</code>文件夹中建立自己的文件夹，存放个别用户数据。或者通过读写注册表<code>HKEY_CURRENT_USER</code>下的注册表项，来存取管理当前用户的配置选项。</p><h2 id="3-3-真实引擎中的配置管理"><a href="#3-3-真实引擎中的配置管理" class="headerlink" title="3.3 真实引擎中的配置管理"></a>3.3 真实引擎中的配置管理</h2><ul><li>雷神之锤的主控台变量（Console Variables，CVAR）：一个储存浮点数或字符串的全局变量，可在主控台下查看及修改，部分值可储存到硬盘上的<code>config.cfg</code>文件</li><li>OGRE引擎：使用INI，像<code>plugins.cfg</code>记录要启用的插件及路径，<code>resources.cfg</code>包含游戏资产的路径。通过<code>Ogre::ConfigFile</code>类可轻易读写全新的配置文件</li><li>顽皮狗的神秘海域引擎：使用以下多种配置机制<ul><li>游戏内置菜单选项：每个可配置选项都实现为全局变量，为选项创建菜单项目时，会提供全局变量的地址，之后菜单项目就能直接控制该全局变量的值</li><li>命令行参数：可指定要载入的关卡名称，以及其他常用参数</li><li>Scheme（一种Lisp方言）数据定义：通过脚本定义数据结构，并用自建的数据编译器转换为二进制文件，同时自动生成C/C++的头文件以解释二进制文件的数据。可以在运行期间重编译和重加载二进制文件，以便随时修改数据结构并立即看到效果。这种系统给予程序员巨大的弹性，可以定义复杂的数据结构，如细致的动画树、物理参数、游戏机制等。下面的代码示例，用于为动画定义属性，并导出2个动画</li></ul></li></ul><pre><code>;; Scheme代码，定义一个新的数据类型，名为simple-animation(deftype simple-animation () (    (name string)    (speed float: default 1.0)    (fade-in-seconds float: default 0.25)    (fade-out-seconds float: default 0.25)));; 定义此数据结构2个实例(define-export anim-walk    (new simple-animation        :name &quot;walk&quot;        :speed 1.0    ))(define-export anim-jump    (new simple-animation        :name &quot;jump&quot;        :fade-in-seconds 0.1        :fade-out-seconds 0.1    ))</code></pre><p>此Scheme代码会产生以下C/C++头文件：</p><pre><code>// simple-animation.h// 警告：本文件是Scheme自动生成的，不要手工修改struct SimpleAnimation {    const char* m_name;    float m_speed;    float m_fadeInSeconds;    float m_fadeOutSeconds;};</code></pre><p>在游戏编程中，可调用<code>LookupSymbol()</code>函数读取数据，该函数<strong>以返回类型为模板参数</strong>：</p><pre><code>#include &quot;simple-animation.h&quot;void someFunction() {    SimpleAnimation* pWalkAnim = LookupSymbol&lt;SimpleAnimation*&gt;(&quot;anim-walk&quot;);    SimpleAnimation* pJumpAnim = LookupSymbol&lt;SimpleAnimation*&gt;(&quot;anim-jump&quot;);    // 在此使用这些动画......}</code></pre><p>参考文献：电子工业出版社《游戏引擎架构》第5.3-5.5节</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏引擎支持系统（上）</title>
      <link href="/tech/game/engine/engine-support-system-1/"/>
      <url>/tech/game/engine/engine-support-system-1/</url>
      
        <content type="html"><![CDATA[<p>每个游戏都需要一些底层支持系统，以管理一些例行却关键的任务，例如启动及终止引擎、存取文件系统、存取各种不同资产类型（网格、纹理、动画、音频等），以及为游戏团队提供调试工具。</p><p>本文（分上下篇）重点讨论多数游戏引擎中都会出现的底层支持系统，为后续探索大型的核心系统做准备。其中上篇将讨论子系统的启动和终止的顺序管理，以及各种动态内存分配器和碎片整理等内存管理问题。</p><a id="more"></a><h1 id="1-子系统的启动和终止"><a href="#1-子系统的启动和终止" class="headerlink" title="1. 子系统的启动和终止"></a>1. 子系统的启动和终止</h1><p>游戏引擎是复杂软件，由多个互相合作的子系统结合而成。各子系统间的相互依赖关系，隐含地定义了每个子系统所需的启动次序，例如子系统B依赖子系统A，那么先启动A，再启动B，而各子系统的终止顺序则相反。</p><p>多数游戏引擎都是采用C++为编程语言，所以应该考虑C++原生的语法如何供启动及终止子系统所用。通常，每个子系统会被设计为单例（或称为管理器manager）。最有效的简单方法是，每个单例管理器的构造和析构函数不做任何事，而是自定义各自的<code>startUp()</code>和<code>shutDown()</code>方法，然后在main函数中调用控制各系统启动和终止的顺序。</p><p>还有更优雅的实现方式，例如让各管理器把自己登记在一个全局的优先队列，之后再按恰当次序逐一启动；或者让每个管理器列举其依赖的管理器，定义一个管理器间的依赖图，再计算最优的启动次序。总之，蛮力法虽然粗暴，但是简单容易实现，非常容易调试和维护，是首选的方法。</p><h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h1><p>任何软件的性能，不仅受算法的选择和算法编码的效率所支配，程序如何运用内存也是重要因素。内存对性能的影响有动态内存分配、内存碎片和缓存等方面。</p><h2 id="2-1-优化动态内存分配"><a href="#2-1-优化动态内存分配" class="headerlink" title="2.1 优化动态内存分配"></a>2.1 优化动态内存分配</h2><p>通过malloc()/free()或C++的new/delete运算符动态分配内存通常是非常慢的，原因有两个：堆分配器是通用设施，可以处理任何大小的分配请求，需要大量的管理开销；多数操作系统上分配内存会在用户模式和内核模式来回切换，这些上下文切换可能会耗费很多时间。因此，游戏开发中一个常见的经验法则是：<strong>维持最低限度的堆分配，并且永不在紧凑循环中使用堆分配。</strong> 当然，任何游戏引擎都无法完全避免动态内存分配，所以会实现若干个定制分配器。定制分配器比原生分配器更高效的原因有两个：从预分配的内存中完成分配请求（顶分配内存来自new），完全避免了上下文切换；对内存的使用模式做出多种假设，会比通用的堆分配器高效得多。</p><h3 id="2-1-1-基于堆栈的分配器"><a href="#2-1-1-基于堆栈的分配器" class="headerlink" title="2.1.1 基于堆栈的分配器"></a>2.1.1 基于堆栈的分配器</h3><p>许多关卡类的游戏，载入关卡时就会为关卡分配内存，关卡载入后，就会很少甚至不会动态分配内存。在玩家完成关卡之际，关卡的数据会被卸下，所有关卡占用的内存也可被释放。这类内存分配非常适合采用堆栈分配器。这种分配器要分配一大块连续内存，通过移动一个指向堆栈顶端的指针来“模拟”内存的分配和释放。释放时按分配的相反次序，不容许释放个别的内存块，而是释放从回滚点（标记）至目前堆栈顶端之间的所有内存。</p><p>双端堆栈分配器（即一个分配器从内存块底端往上分配，另一个从内存块顶端往下分配）可以更有效地运用内存。一种非常优秀的从不会产生内存碎片问题的分配方案：所有内存分配自单个巨大内存块，以双端堆栈分配器管理，底堆栈用来载入及卸下游戏关卡，顶堆栈则用来分配临时内存块，这些临时内存会在每帧中分配及释放。堆栈分配器的实现模型见下图。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fengine%2F%E5%A0%86%E6%A0%88%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E5%88%86%E9%85%8D%E6%A8%A1%E5%BC%8F.png" alt="堆栈分配器的分配模式"></p><h3 id="2-1-2-池分配器"><a href="#2-1-2-池分配器" class="headerlink" title="2.1.2 池分配器"></a>2.1.2 池分配器</h3><p>矩阵、迭代器、链表中的节点、可渲染的网格实例等会分配大量同等尺寸的小块内存。池分配器是此类分配模式的完美选择。其工作方式为：首先预分配一大块内存，大小刚好是分配元素的倍数（例如每元素4字节的4×4矩阵池的大小设为64字节的倍数），池内每个元素会加到一个存放自由元素的链表。池分配器收到分配请求时，就会把自由链表的下一个元素取出，并传回该元素；释放元素之时，只需简单地把元素插回自由链表中。这些分配和释放都是O(1)的操作。</p><h3 id="2-1-3-含对齐功能的分配器"><a href="#2-1-3-含对齐功能的分配器" class="headerlink" title="2.1.3 含对齐功能的分配器"></a>2.1.3 含对齐功能的分配器</h3><p>为了提高内存的吞吐量和效率，所有内存分配器都必须能传回<strong>字节对齐</strong>的内存块。只要在分配内存时，分配比请求所需多一点的内存，再向上调整地址至适当的对齐，最后传回调整后的地址。大多数情况下，额外分配的字节等于对齐字节。例如，若请求为16字节对齐的内存块，就可以额外分配多16字节，最坏的情况下要把地址往上移动15字节。多出的1字节可以用来存储偏移量，以便于正确释放分配的内存。</p><h3 id="2-1-4-单帧和双缓冲分配器"><a href="#2-1-4-单帧和双缓冲分配器" class="headerlink" title="2.1.4 单帧和双缓冲分配器"></a>2.1.4 单帧和双缓冲分配器</h3><p>几乎所有游戏都会在游戏循环中分配一些临时用数据，这些数据要么可在循环迭代结束时丢弃，要么可在下一迭代结束时丢弃。这种模式适用于以下两种分配模式：</p><ol><li>单帧分配器：先预留一块内存，并以简单堆栈分配器管理。在每帧开始时，都把堆栈的顶端指针重置到内存块的底端地址。在该帧中，分配要求会使堆栈向上成长。优点是极其高效，分配了的内存永远不需要手动释放，因为每帧开始时分配器会自动清除所有内存。最大缺点在于，程序员必须有不错的自制能力，并意识到内存块只在目前的帧里有效，<strong>绝不能把指向单帧内存块的指针跨帧使用</strong>。</li><li>双缓冲分配器：第i帧分配的内存块用于第(i+1)帧。实现方法就是建立两个相同尺寸的单帧堆栈分配器，并在每帧交替使用（见下方代码）。</li></ol><pre><code>class DoubleBufferedAllocater {    U32 m_curStack;    StackAllocator m_stack[2];public:    void swapBuffers() {        m_curStack = (U32)!m_curStack;    }    void clearCurrentBuffer() {        m_stack[m_curStack].clear();    }    void *alloc(U32 mBytes) {        return m_stack[m_curStack].alloc(nBytes)    }}DoubleBufferedAllocator g_doubleBufAllocator;// 主游戏循环while (true) {    // 每帧清除单帧分配器的缓冲区    g_singleFrameAllocator.clear();    // 对双缓冲分配器交换现行和无效的缓冲区    g_doubleBufAllocator.swapBuffers();    // 清空新的现行缓冲区，保留前帧的缓冲不变    g_doubleBufAllocator.clearCurrentBuffer();    // ...    // 从双缓冲分配器分配内存，不影响前帧的数据，要确保这些内存仅在本帧或次帧中使用    void* p = g_doubleFrameAllocator.alloc(nBytes);    // ...}</code></pre><h2 id="2-2-内存碎片"><a href="#2-2-内存碎片" class="headerlink" title="2.2 内存碎片"></a>2.2 内存碎片</h2><p>当经过非常多次随机次序的分配及释放不同尺寸的内存块，堆中就会出现许多内存“孔洞”，这就是内存碎片状态。由于分配的内存必须是连续的，所以内存碎片会导致分配请求经常失败。在支持虚拟内存的操作系统上，内存碎片并非大问题。对当代的游戏机而言，虽然技术上能支持虚拟内存，但由于其导致的开销，多数游戏引擎不会使用虚拟内存。</p><h3 id="2-2-1-用堆钱和池分配器避免内存碎片"><a href="#2-2-1-用堆钱和池分配器避免内存碎片" class="headerlink" title="2.2.1 用堆钱和池分配器避免内存碎片"></a>2.2.1 用堆钱和池分配器避免内存碎片</h3><p>使用堆栈分配器分配到的内存块总是连续的，可以完全避免内存碎片。池分配器虽然会产生碎片，但因为每个内存块都一样大，所以不会因缺乏足够大的连续内存块而造成分配失败</p><h3 id="2-2-2-碎片整理及重定位"><a href="#2-2-2-碎片整理及重定位" class="headerlink" title="2.2.2 碎片整理及重定位"></a>2.2.2 碎片整理及重定位</h3><p>若要以随机次序分配及释放不同大小的对象，以上两种也不适用。这时可以对堆定期进行碎片整理，即把每个“洞”搬移至高位，最后所有己分配内存块都会连续地凑在堆内存空间的底端。移动内存是简单的事，但背后的副作用是<strong>移动了己分配的内存块，若有指针指向这些内存块，这些指针便会失效。</strong>其中一个解决方案就是把指向这些内存块的指针逐一更新，使移动内存块后这些指针能指到新的地址，这个过程称为指针重定位。</p><p>由于C/C++不支持搜寻所有指向某地址范围的指针，若要在游戏引擎中支持碎片整理功能，程序员必须小心手动维护所有指针，另一个选择是采用智能指针或句柄（使用索引指向句柄表内的元素，每个元素储存指针，句柄的值不变，移动内存块时要修改指针）来替代。重定位的另一难题是，使用一些第三方库，该库本身不使用智能指针或句柄，那么指向库内数据结构的指针就不能被重定位。最好的办法是，让这些库在另一个特别缓冲区里分配内存，此缓冲区位于可重定位内存范围以外。或者干脆容许一些内存块不能被重定位，若这种内存块数量少且体积小，重定位系统仍可运行得相当好。</p><h3 id="2-2-3-分摊碎片整理整本"><a href="#2-2-3-分摊碎片整理整本" class="headerlink" title="2.2.3 分摊碎片整理整本"></a>2.2.3 分摊碎片整理整本</h3><p>碎片整理要复制内存块，其过程可能很慢。然而可以把碎片整理分摊至多个帧，例如容许容许每帧进行多达N次内存块移动（N是小数目，如8或16），只要分配及释放的次数低于碎片整理的移动次数，那么堆就会经常保持接近完全整理的状态。此方法只对细小的内存块有效，使移动内存块的时间短于每帧配给的重定位时间。若要重定位非常大的内存块，有时候可以把它分拆为两个或更多的小块，而每个小块可以独立被重定位。</p><h2 id="2-3-缓存一致性"><a href="#2-3-缓存一致性" class="headerlink" title="2.3 缓存一致性"></a>2.3 缓存一致性</h2><p>为了降低读写主内存的平均时间，现代处理器会采用高速缓存。每当出现缓存命中失败，程序便要被逼暂停，等待缓存线自主内存更新后才能继续运行。因为数据始终要在缓存和主内存之间移动，所以无法完全避免缓存命中失败。高效计算的诀窍在于，以最优的方式安排内存中的数据及为算法编码，尽量减少缓存命中失败的次数。</p><h3 id="2-3-1-硬件层面上的缓存"><a href="#2-3-1-硬件层面上的缓存" class="headerlink" title="2.3.1 硬件层面上的缓存"></a>2.3.1 硬件层面上的缓存</h3><p>现代的CPU架构上出现了一级L1和二级L2高速缓存，其存取方向为“CPU←→L1缓存←→L2缓存←→主内存”，存取速度依次减慢，L2缓存命中失败通常比L1的成本高。有一种特别差的缓存命中失败称为load-hit-store，此问题在PowerPC架构上（如Xbox360和PS3）极为普遍。其出现过程是，CPU往某内存地址写入数据，随即又读取该地址，而此时要等待L1缓存写回数据至主内存，造成CPU的流水线停顿。具体可以参见<a href="http://assemblyrequired.crashworks.org/load-hit-stores-and-the-__restrict-keyword/" target="_blank" rel="noopener">这篇文章</a></p><p>此外还需要意识到大多数处理器会在物理上独立分开指令缓存和数据缓存，前者会预载即将执行的机器码，后者则用来加速内存读写数据。因此程序变慢，要考虑是指令还是数据缓存命中失败。</p><h3 id="2-3-2-软件层面上避免缓冲命中失败"><a href="#2-3-2-软件层面上避免缓冲命中失败" class="headerlink" title="2.3.2 软件层面上避免缓冲命中失败"></a>2.3.2 软件层面上避免缓冲命中失败</h3><p>避免<strong>数据</strong>缓存命中失败的最佳办法就是，<strong>把数据编排进连续的内存块中，尺寸越小越好，并且要顺序访问这些数据</strong>。当数据是连续的（即不会经常在内存中“跳来跳去”），那么单次命中失败便会把尽可能最多的相关数据载入单个缓存线。</p><p>要避免<strong>指令</strong>缓存命中失败，需要了解C/C++链接器的一些简单规则，例如编译器和链接器按函数在cpp文件中的出现次序排列内存布局；单个函数的机器码几乎总是置于连续的内存；位于一个翻译单元内的函数总是置于连续内存中。据此可以使用以下经验法则：</p><ul><li>高效能代码的体积越小越好，体积以机器码指令数目为单位</li><li>在性能关键的代码段中，<strong>避免调用函数</strong></li><li>若要调用某函数，就把该函数置于<strong>最接近</strong>调用函数的地方，最好是紧接调用函数的前后，而不要把该函数置于另一翻译单元（cpp文件）</li><li>谨慎使用内联函数。内联小型函数能增进效能，然而过多的内联会增大代码体积，使性能关键代码再不能完全装进缓存。若循环内的代码不能完全装进缓存，应重新考虑算法及其代码实现</li></ul><p>参考文献：电子工业出版社《游戏引擎架构》第5.1、5.2节</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏引擎架构总览</title>
      <link href="/tech/game/engine/game-engine-architecture-preview/"/>
      <url>/tech/game/engine/game-engine-architecture-preview/</url>
      
        <content type="html"><![CDATA[<p>游戏引擎通常由运行时组件和工具套件两部分构成。本文先探讨运行时部分的架构，给出了一个不包含工具的极其庞大的总览图（如果时间有限仅看此图即可），并对图中每一组件进行描述，最后再阐述工具方面的内容。如同所有软件系统，游戏引擎也是以软件层构建的，而且通常上层依赖下层，下层不依赖上层。</p><a id="more"></a><h1 id="1-运行时引擎架构"><a href="#1-运行时引擎架构" class="headerlink" title="1. 运行时引擎架构"></a>1. 运行时引擎架构</h1><p>下图为游戏运行时引擎架构的总览图，本图相对原书标上了序号，以方便下面各节阐述时对应其位置，并省略了一些细节的组成部分。<strong>图片较大，建议在新标签页中打开图片查看。</strong></p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fengine%2F%E6%B8%B8%E6%88%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84.png" alt="游戏运行时引擎架构"></p><h2 id="1-1-硬件与操作系统"><a href="#1-1-硬件与操作系统" class="headerlink" title="1.1 硬件与操作系统"></a>1.1 硬件与操作系统</h2><p>图中的A1为目标硬件层，代表用来执行游戏的计算机系统或游戏主机。典型平台包括基于微软Windows或Linux的PC、苹果的iPhone及Machintosh、微软的Xbox360、索尼的PS4/PSP、任天堂的NDS/Wii等等。</p><p>图中的A2是设备驱动程序，是由操作系统或硬件厂商提供的最低阶软件组件。驱动程序负责管理硬件资源，也隔离了操作系统及上层引擎，使上层的软件无须理解不同硬件版本的通信细节差异。</p><p>图中的A3是操作系统。在PC上操作系统是一直运行的，PC游戏不能假设拥有硬件的所有控制权；而在游戏主机上，操作系统通常只是个轻量级的库，链接到游戏的执行档里。不过像Xbox 360和PS3这些新主机中，操作系统也会中断游戏的执行，接管某些系统资源以显示在线信息。</p><h2 id="1-2-第三方软件开发包和中间件"><a href="#1-2-第三方软件开发包和中间件" class="headerlink" title="1.2 第三方软件开发包和中间件"></a>1.2 第三方软件开发包和中间件</h2><p>图中的B表明大多数游戏引擎会借用第三方SDK及中间件（middleware），SDK提供基于函数或基于类的API。下面是一些常见的例子：</p><ul><li>数据结构及算法：如STL、STLport、Boost、Loki。因为PC上有虚拟内存系统，所以可以无碍使用STL，而游戏主机上，只有有限的（甚至没有）虚拟内存功能，而且缓存命中失败的代价极高，所以最好编写自定义的数据结构</li><li>图形：如DirextX、OpenGL、libgcm、Edge等</li><li>碰撞和物理：如Havok、PhysX、ODE（Open Dynamics Engine）等</li><li>角色动画：如Granny、Havok Animation、Edge等</li><li>人工智能：如Kynapse，提供低阶的AI构件，例如路径搜寻、静态和动态物体回避、空间内的脆弱点辨认，以及相当好的AI和动画间接口</li><li>生物力学角色模型：如Endorphin、Euphoria等，利用了真实人类运动的高阶生物力学模型，去产生角色动作</li></ul><h2 id="1-3-平台独立层"><a href="#1-3-平台独立层" class="headerlink" title="1.3 平台独立层"></a>1.3 平台独立层</h2><p>图中的C为平台独立层。大部分游戏引擎需要运行于不同的平台上，该层包装了常用的标准C语言库、操作系统调用及其他基础API，确保包装了的接口在所有硬件平台上均为一致。</p><h2 id="1-4-核心系统"><a href="#1-4-核心系统" class="headerlink" title="1.4 核心系统"></a>1.4 核心系统</h2><p>游戏引擎以及其他大规模复杂C++应用软件，都需要一些有用的实用软件（utility)，统称为“核心系统”，即图中的D。以下是一些核心系统层的常见功能：</p><ul><li>内存管理：几乎每个游戏引擎都有若干个自定义内存分配系统，以保证高速的内存分配及释放，并控制内存碎片所造成的负面影响</li><li>数学库：游戏本质上就是高度数学密集的，所以每个游戏引擎都有若干个数学库，提供矢量、矩阵、四元数旋转、三角学、数值积分、解方程组，以及其他游戏程序员需要的功能</li><li>自定义数据结构及算法：除非引擎设计者想完全依靠第三方软件包，否则引擎通常要提供一组工具去管理基础数据结构和算法，以减少或完全消去动态内存分配，并保证在目标平台上的运行效率为最优</li></ul><h2 id="1-5-资源管理"><a href="#1-5-资源管理" class="headerlink" title="1.5 资源管理"></a>1.5 资源管理</h2><p>图中的E为资源管理器，提供一组统一的接口去访问任何类型的游戏资产及其他引擎输入数据。有些引擎使用高度集中及一致的方式（例如虚幻的包package、OGRE的ResourceManager类）。其他引擎使用专案（ad hoc）方法，比如让程序员直接读取磁盘的或压缩的文件（如雷神之锤引擎使用的PAK文件）。</p><h2 id="1-6-渲染引擎"><a href="#1-6-渲染引擎" class="headerlink" title="1.6 渲染引擎"></a>1.6 渲染引擎</h2><p>任何游戏引擎中，渲染引擎是最大及最复杂的组件之一。渲染器有很多不同的架构方式，通常采用分层架构。</p><ul><li>低阶渲染器（图中F1）：包含引擎中全部原始的渲染功能，着重于高速渲染丰富的几何图元集合<ul><li>图形设备接口：使用图形SDK（如DirectX及OpenGL），都需要编写不少代码去枚举图形设备，初始化设备，建立渲染表面等，这些工作通常由图形设备接口组件负责</li><li>其他渲染器组件：目的是要收集须提交的几何图元，包括网格、线表、点表、例子、地形块、字符串等等。低阶渲染器还提供视区（viewport）抽象、材质系统及动态光照系统</li></ul></li><li>场景图/剔除优化（图中F2）：该层基于某些可视性判别算法去限制低阶渲染器提交的图元数量。非常小的游戏世界可能只需要简单的平截头体剔除算法，比较大的游戏世界则可能需要较高阶的空间细分数据结构，令渲染更有效率</li><li>视觉效果（图中F3）：支持广泛的视觉效果，例如粒子系统（烟、火、水花等）、贴花系统（弹孔、脚印等），还有一些全屏幕后期处理，例如高动态范围光照（HDR）、敷霜效果、全屏抗锯齿（FSAA）、颜色校正等等</li><li>前端（图中F4）：该层主要用于显示2D图形，如平视显示器（HUD）、GUI界面等等，通常会用附有纹理的四边形结合正射投影来渲染，或者用完全三维的四边形公告板（billboard）渲染</li></ul><h2 id="1-7-剖析与调试工具"><a href="#1-7-剖析与调试工具" class="headerlink" title="1.7 剖析与调试工具"></a>1.7 剖析与调试工具</h2><p>图中的G用于剖析调优性能，分析内存。还包含了游戏内置调试功能，包括调试用绘图、内置菜单、主控台、录制回放游戏过程等。市场上有很多优良的通用软件剖析工具，如VTune、Quantify、Purify等等，但是多数游戏也会加入自制的剖析与调试工具以应对特殊需求。</p><h2 id="1-8-碰撞和物理"><a href="#1-8-碰撞和物理" class="headerlink" title="1.8 碰撞和物理"></a>1.8 碰撞和物理</h2><p>图中的H为碰撞与物理组件。游戏中如果没有碰撞检测，物体会互相穿透，并且无法在虚拟世界里合理地互动。碰撞和物理系统一般是紧密联系的，因为当碰撞发生时，碰撞几乎总是由物理积分及约束满足逻辑来解决。一些游戏还包含真实或半真实的刚体动力学模拟。时至今日，游戏引擎通常使用第三方的物理SDK，如Havok、PhysX和ODE。</p><h2 id="1-9-动画"><a href="#1-9-动画" class="headerlink" title="1.9 动画"></a>1.9 动画</h2><p>图中的I为动画系统，游戏常会用到精灵/纹理动画、刚体层次结构动画、骨骼动画、每顶点动画、变形目标动画5种基本动画。现今游戏<br>中，骨骼动画是最盛行的动画方式。此外，骨骼网格渲染组件是连接渲染器和动画系统的桥梁，这些组件合作渲染的过程称为蒙皮（skinning）。</p><p>当使用布娃娃系统时，动画和物理系统便产生紧密耦合，这是因为布娃娃是无力的（经常是死了的）角色，其运动完全由物理系统模拟。物理系统把布娃娃当作受约束的刚体系统，用模拟来决定身体每部分的位置及方向。</p><h2 id="1-10-人体学接口设备"><a href="#1-10-人体学接口设备" class="headerlink" title="1.10 人体学接口设备"></a>1.10 人体学接口设备</h2><p>图中的J用于处理玩家输入，包括键盘鼠标、游戏手柄及其他专用游戏控制器（如方向盘、跳舞毯、Wii遥控器等）。除了输入功能，一些设备也提供输出，如游戏手柄的震动、Wii遥控器的音频输出等。</p><p>在架构HID引擎时，通常让硬件的低阶细节与高阶游戏操作脱钩。HID引擎从硬件取得原始数据，为控制器的每个摇杆设置环绕中心点的死<br>区，去除按钮抖动，检测按下和释放按钮事件，演绎加速计的输入并使该输入平滑。HID引擎也可能包含一个系统，负责检测弦（chord）（即数个按钮一起按下）、序列（即接钮在时限内顺序按下）、手势（即按钮、摇杆、加速计等输入的序列）。</p><h2 id="1-11-音频"><a href="#1-11-音频" class="headerlink" title="1.11 音频"></a>1.11 音频</h2><p>图中的K为音频引擎。一些游戏团队会为这些引擎加入自定义功能，或用内部方案替换，例如微软为DirectX平台提供一个名为XACT的优秀的音频工具包，艺电也开发了内部的音频引擎SoundR!OT。然而，即使游戏团队用既有的音频引擎，开发每个游戏时仍然需要大量的定制软件开发、整合工作及注意细节，才可以制作出有高质量音频的最终产品。</p><h2 id="1-12-在线多人-网络"><a href="#1-12-在线多人-网络" class="headerlink" title="1.12 在线多人/网络"></a>1.12 在线多人/网络</h2><p>图中的L为在线多人/网络组件。多人游戏有单屏多人、切割平多人、网络多人、大型多人在线等多种基本形式。支持多人游戏，会深切影响到游戏世界对象模型、人体学接口设备系统、玩家控制系统、动画系统等多个组件的设计。把一个现有的担任引擎改装成多人引擎的难度是非常大的，但如果反过来则比较简单——许多游戏引擎把单人游戏模式当做是一个玩家参与的多人游戏。</p><h2 id="1-13-游戏性基础系统"><a href="#1-13-游戏性基础系统" class="headerlink" title="1.13 游戏性基础系统"></a>1.13 游戏性基础系统</h2><p>游戏性（gameplay）是指：游戏内进行的活动、支配游戏虚拟世界的规则、玩家角色的能力（也称为玩家机制）、其他角色和对象的能力、玩家的长短期目标。游戏性编程除了用引擎的原生语言，通常还会使用高阶的脚本语言，为了连接低阶的引擎子系统和游戏性代码，多数游戏引擎会引入一个软件层，即图中的M。</p><ul><li>游戏世界和游戏对象模型：游戏世界含动态与静态的元素，而典型的游戏对象有静态背景几何物体（如建筑、地形）、动态刚体（如石头、椅子）、玩家角色、NPC、武器、抛射物、载具、光源、摄像机</li><li>事件系统：事件驱动架构常用于游戏对象间的通信</li><li>脚本系统：使用脚本语言来编写游戏独有的游戏性规则和内容，可以快速开发，避免重新编译链接</li><li>人工智能基础：像Kynapse这种商用AI引擎，抽象了大多数AI系统共有的模式，在这个基础层上可以很容易地开发个别游戏的逻辑。其功能包括用路径节点和漫游体积组成网络定义AI角色可行走的地区和路径，在漫游地区边界周围的简化碰撞信息，A*路径搜寻，联系碰撞系统及世界模型进行视线追踪及其他感知，AI决策层架构等等</li></ul><h2 id="1-14-个别游戏专用子系统"><a href="#1-14-个别游戏专用子系统" class="headerlink" title="1.14 个别游戏专用子系统"></a>1.14 个别游戏专用子系统</h2><p>如图中的N，每个游戏都有若干自身特有的游戏性系统。如果可以清楚地分开引擎和游戏，这条分界线会位于特定游戏专用子系统和游戏性基础软件层之间。实际上，这条分界线永远不会是完美的。一些游戏的特定知识，总是会向下渗透到游戏基础软件层中，更有甚者会延伸至引擎核心。</p><h1 id="2-工具套件"><a href="#2-工具套件" class="headerlink" title="2. 工具套件"></a>2. 工具套件</h1><h2 id="2-1-数字内容创作工具"><a href="#2-1-数字内容创作工具" class="headerlink" title="2.1 数字内容创作工具"></a>2.1 数字内容创作工具</h2><p>游戏本质上是多媒体应用。游戏引擎的输入数据形式广泛，例如三维网格数据、纹理位图、动画数据、音频文件等。所有源数据皆由美术或音效师等专业人员使用数字内容创作（Digital Content Creation，DCC）应用软件制作，如Maya、3ds Max、Photoshop、SoundForge等等。有些游戏引擎提供专门的设计游戏世界的编辑器，而有的团队会在现有软件像3ds Max的基础上开发插件去设计场景，甚至用简单的位图编辑器去制作地形高度图。总之，游戏团队想要及时开发高完成度的产品，工具必须<strong>相对易用</strong>，并且<strong>绝对可靠</strong>。</p><h2 id="2-2-资产（asset）调节管道"><a href="#2-2-资产（asset）调节管道" class="headerlink" title="2.2 资产（asset）调节管道"></a>2.2 资产（asset）调节管道</h2><p>DCC所生成的数据格式，很少有直接用于游戏中的，原因有两点：生成的数据格式通常比游戏所需的复杂得多，游戏引擎只需其中一小部分信息；直接读取速度过慢，而且有些格式是不公开的专有格式。因此，DCC软件制作的数据，通常要导出为容易读取的标准格式或自定义格式，有时还需要针对不同平台进行再处理，以便在游戏中使用。从DCC到游戏引擎的管道，就是所谓的资产调节管道。</p><h2 id="2-3-常见的游戏资产数据"><a href="#2-3-常见的游戏资产数据" class="headerlink" title="2.3 常见的游戏资产数据"></a>2.3 常见的游戏资产数据</h2><ul><li>几何图形数据<ul><li>笔刷集合图形：由凸包集合定义，每个凸包则由多个平面定义。其优点是制作迅速简单，便于设计师建立粗略的原型，也可用作碰撞体积；缺点是分辨率低难以制作复杂图形，不能支持有关节的物体或运动角色</li><li>三维模型/网格：由三角形和顶点组成，每个网格使用若干个材质。网格通常在三维建模软件里制作，并且需要专用的导出器来导出游戏引擎可读的格式</li></ul></li><li>骨骼动画数据：骨骼网格是一种为关节动画而绑定到骨骼层次结构之上的特殊网格，游戏引擎需要网格本身、骨骼层次结构和若干动画片段3种数据来渲染骨骼网络</li><li>音频数据：由专业的音频制作工具导出，有不同格式和采样率。音频文件通常组织成音频库，以方便管理，载入及串流。</li><li>粒子系统数据：由视觉特效设计师使用第三方工具（如Houdini）或引擎自带的粒子效果编辑工具制作</li><li>游戏世界数据：不少商用游戏引擎会提供优良的世界编辑器，用于编辑游戏世界</li></ul><p>参考文献：电子工业出版社《游戏引擎架构》第1.6、1.7节</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（十五）——尾声</title>
      <link href="/tech/complex/software/software-construction-15/"/>
      <url>/tech/complex/software/software-construction-15/</url>
      
        <content type="html"><![CDATA[<p>本文是《代码大全》学习笔记系列的最后一篇。书中最后几章是一些杂项主题，本文将简要记录这几个主题的内容，包括个人性格对编程的影响，软件开发艺术的有关问题，以及关于软件工程的推荐书单。</p><a id="more"></a><h1 id="1-个人性格"><a href="#1-个人性格" class="headerlink" title="1. 个人性格"></a>1. 个人性格</h1><p>编程过程非常耗用脑力，这种特性使得个人性格显得很重要。而编程工作本质上是项无法监督的工作，因为没人真正清楚你正在做什么。老板也无法强迫你成为好的程序员，很多时候他甚至无法判断你是否合格，一切都只能靠自己。你无法提升自己的聪明程度，但性格在一定程度上能够改进。事实证明，个人性格对于造就出程序员高手更具有决定性意义。</p><h2 id="1-1-个人性格对编程的影响"><a href="#1-1-个人性格对编程的影响" class="headerlink" title="1.1 个人性格对编程的影响"></a>1.1 个人性格对编程的影响</h2><ul><li>聪明和谦虚：高智商与优秀程序员之间并无太密切的联系。实际上许多好的编程做法都是为了减轻脑力负担，例如将系统分解是为了使之易于理解，进行审查、评审和测试是为了减少人为失误，通过各种各样的规范是为了将思路从相对繁琐的编程事务中解放出来。精通编程的人是那些了解自己头脑有多大局限性的人，都很谦虚。</li><li>求知欲：技术环境的特定特征每5到10年就变化一番，如果没有足够的求知欲来跟上这些变化，就会面临落伍的威胁，下面是一些培养求知欲的方法<ul><li>在开发过程中建立自我意识</li><li>不断用小程序来试验技术点</li><li>阅读解决问题的有关方法</li><li>在行动之前做分析和计划</li><li>学习成功项目的开发经验，阅读高手的代码</li><li>认真阅读文档和其他书本期刊</li><li>同专业人士交往</li><li>向专业开发看齐：专业开发可分为这样四个等级：入门级（会使用某语言的基本功能和特性），中级（已度过入门期，能使用多种 语言，并得心应手使用至少一种语言），熟练级（对语言或环境有着专业技能，通常是公司的核心开发，很多程序员不能超越该层次），技术带头人级（具有熟练级的专业技能，也明白写代码是给人看而非给机器看）</li></ul></li><li>诚实：通常表现为：不是高手时不假装是高手；乐于承认错误；力图理解编译器的警告，而非弃之不理；透彻理解自己的程序，而不要只是编译看看能否运行；提供实际的状况报告；提供现实的进度方案，在上司面前坚持自己的意见</li><li>交流与合作：真正优秀的程序员知道怎样同别人融洽地工作和娱乐，并且会把提高代码可读性和修改你代码的人放在心上</li><li>创造力和纪律：不要把各种标准和规范的纪律看成是对创造力的约束，相反，许多有很强创造力的人都极其遵守纪律和规范</li><li>偷懒：通常表现为拖延不喜欢的任务（没有任何益处），迅速做完不喜欢的任务以摆脱之（尽管是偷懒，但毕竟用最少时间完成了任务），<strong>编写某个工具来完成不喜欢的任务以便再也不用做这样的事情</strong>（一劳永逸的懒，无疑是最具产值的偷懒形式）</li><li>习惯：优秀的程序员早就养成了编程各方面的良好习惯，而不是最近才培养的。初涉某事时，就应端正态度来学，干了一段时间后，“习惯的力量”就开始起作用。如果没养成最有效的习惯，或者想改掉坏习惯，应该用良好的新习惯去取代，而不是强行杜绝掉坏习惯</li></ul><h2 id="1-2-不如你想象中那样起作用的性格因素"><a href="#1-2-不如你想象中那样起作用的性格因素" class="headerlink" title="1.2 不如你想象中那样起作用的性格因素"></a>1.2 不如你想象中那样起作用的性格因素</h2><p>注意以下列举的性格都是<strong>反面因素</strong>。</p><ul><li>坚持：多数时候软件开发中的坚持其实就是没有好处的“固执”，当在某段新代码上卡壳时，不妨另辟蹊径，尝试重新设计类，或者绕过去，以后回头再试。花好几个小时干掉某一错误确实会有满足感，但实际上早点放弃固有的思路，换个角度可能可以节省更多时间。</li><li>经验：由于软件技术更新换代太快，所谓的“经验”很快就会落伍，程序员要持续学些，保持与时俱进。</li><li>编程狂人：彻夜编程让你感觉像是世上最好的程序员，却要花几个星期去纠正你在短暂辉煌时埋下的失误。可以热爱编程，但热情不能代替熟练的能力，请想明白什么更重要。</li></ul><h1 id="2-软件开发艺术的有关问题"><a href="#2-软件开发艺术的有关问题" class="headerlink" title="2. 软件开发艺术的有关问题"></a>2. 软件开发艺术的有关问题</h1><p>这一章相当于对全书介绍的各种细节背后所折射出的哲学思想做出一个总结。</p><ul><li>克服复杂性：《代码大全》绝大部分的篇幅都用于阐述如何划分系统模块，抽象类和接口，遵循什么样的编程规范等等，归根结底是为了降低软件的复杂性。</li><li>精选开发过程：对于小的项目，程序员的个人才能对软件质量影响最大，对于多人项目，组织性的重要程度超过了个人技能。关于开发过程的重要性，一个明显的例子是看看在需求还未确定就开始设计和编码的后果。其他有用的开发过程，如增量开发，先设计后编码，先粗调后优化，伪代码编码并不断添加注释等等，均在之前的文章提到过，不再赘述。</li><li>首先为人写程序，其次才是为机器：可读的代码写起来并不比含糊的代码多花时间，得到的好处是巨大的。自己维护，后期重构，复审代码，别人修改程序，统统都要读到代码，因此一次性编写可读性强的代码，是非常经济划算的。即便是自写自用的私有代码，也应该认真对待，因为这是一种优秀的习惯（习惯在上述个人性格中提到过）。</li><li>深入一门语言去编程，不浮于表面：要先考虑要干什么，然后采用手头的工具去实现目标。如果你所用的语言不支持某种你想要的特性，可以尝试用一些变通的方法以最大限度地遵循编程规范，因为规范能帮助你理清环境中的危险特性。</li><li>借助规范集中注意力：规范能够节省程序员回答同样问题的麻烦，能精确地传达重要信息，免除各种编码的危险做法，还能弥补语言的某些不足之处</li><li>基于问题域编程：顶层的代码要说明想解决的问题，而不要充斥各种与文件、数据结构、数据类型有关的操作细节。设计程序时，应考虑下图这样的抽象层次<ul><li><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fsoftware%2F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1.png" alt="程序的抽象层次"></li></ul></li><li>留心警告信号：当你或其他人说“这段代码暗藏玄机”时，或者类中含有比平均数目更多的错误，或者发现子程序中有许多判断点、嵌套，或者发现代码有重复，或者发现代码不容易写注释和命名变量，或者编译时出现警告等等，这些都是警告信号。任何警告信号都应让你质疑程序的质量，并促使你去寻求更满意的解决之道。</li><li>一次又一次迭代：需求、设计、开发、测试，软件开发从头到尾每一步都充斥着迭代并逐步精化的过程。所以不要追求所谓的“一步登天”。</li><li><strong>不要</strong>存在软件信仰（即坚持某种做法）<ul><li>折中主义：要对编程问题找出最有效的解决方案时，盲目迷信某种方法只会缩小你的选择余地。折中主义是一种有益的态度，对于每个特定问题，应该将多种方法视为工具箱中的工具。多数时候工具的选择关系不大，但有些场合需要自己判断权衡，挑选最好的工具</li><li>试验：要想有效地试验，应能基于试验结果改变思路。许多顽固的方法源于对错误的畏惧心理，“试图没有错误”是最大的错误。软件开发的各方面，你都应保待开放的心态</li></ul></li></ul><h1 id="3-书单"><a href="#3-书单" class="headerlink" title="3. 书单"></a>3. 书单</h1><p>书中最后一章作者给出了一些建议阅读的经典著作，下面挑选了一部分有中译版本的书（有一些书再版了多次，链接给出的都是最新的版本）组成一个参考书单，供以后学习。</p><ul><li>软件构建类<ul><li><a href="https://book.douban.com/subject/5387402/" target="_blank" rel="noopener">《程序员修炼之道》</a>（《The Pragmatic Programmer》，Andrew Hunt / David Thomas）</li><li><a href="https://book.douban.com/subject/3227098/" target="_blank" rel="noopener">《编程珠玑》</a>（《Programming Pearls》，Jon Bentley）</li><li><a href="https://book.douban.com/subject/6524000/" target="_blank" rel="noopener">《程序设计实践<strong>（评注版）</strong>》</a>（《The Practice of Programming》，Brian W. Kernighan / Rob Pike），注意这本书市面上没有很好的中译本，只有最新的这本评注版</li></ul></li><li>软件工程综述类<ul><li><a href="https://book.douban.com/subject/26419766/" target="_blank" rel="noopener">《软件开发心理学》</a>（《The Psychology of Computer Programming》，Gerald M. Weinberg）</li><li><a href="https://book.douban.com/subject/2230248/" target="_blank" rel="noopener">《人月神话》</a>（《The Mythical Man-Month》，Frederick P.Brooks）</li><li><a href="https://book.douban.com/subject/6047742/" target="_blank" rel="noopener">《软件工程：实践者的研究方法》</a>（《The Mythical Man-Month》，Roger S.Pressman）</li></ul></li></ul><p>参考文献：电子工业出版社《代码大全（第2版）》第33、34、35章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（十四）——代码布局与自说明代码</title>
      <link href="/tech/complex/software/software-construction-14/"/>
      <url>/tech/complex/software/software-construction-14/</url>
      
        <content type="html"><![CDATA[<p>本文关注的是计算机编程的美学话题——程序源代码的布局和自说明性。尽管这些技巧并不影响执行速度、内存使用量等方面的程序性能，但它却会让你日后理解、检查以及修改代码变得更容易，也使其他人在你缺位的时候更容易阅读、理解和修改你的代码。</p><p>需要注意的是，形成良好的代码布局，并让代码具备自说明性，需要始终贯穿项目的生命期，晚了就很难做好了。要想完全实现这些细节规定，在最初建构时就要着手去做。如果你干的是合作项目，更是要在开始编码之前统一大家的风格。</p><a id="more"></a><h1 id="1-代码布局"><a href="#1-代码布局" class="headerlink" title="1. 代码布局"></a>1. 代码布局</h1><h2 id="1-1-良好布局的目标"><a href="#1-1-良好布局的目标" class="headerlink" title="1.1 良好布局的目标"></a>1.1 良好布局的目标</h2><ul><li>准确表现代码的逻辑结构：例如利用缩进、空行等空白来表达逻辑关系</li><li>始终如一地表现代码的逻辑结构</li><li>改善可读性：如果有一种缩进策略合乎逻辑，但却令程序更难看懂，那么它就毫无用处</li><li>经得起修改：好的布局应该在修改某行时不必连带修改其他行的代码</li></ul><h2 id="1-2-常用布局技术与风格"><a href="#1-2-常用布局技术与风格" class="headerlink" title="1.2 常用布局技术与风格"></a>1.2 常用布局技术与风格</h2><ul><li>空白：包括空格、制表符、换行、空行等等。程序中的空白就像书籍中划分章节、段落、句子一样向读者展示组织主题的思路<ul><li>分组：确保相关的语句成组放在一起，用空行分隔，就像文章中的一段话一样</li><li>空行：将不相关的语句分隔开，就像文章中段与段的分隔一样</li><li>缩进：显示程序的逻辑结构</li></ul></li><li>括号：对包含两个以上的项的表达式，应该用括号去澄清</li><li>控制结构布局<ul><li>别让begin和end对两次缩进</li><li><strong>单条语句</strong>的代码块的格式要前后统一</li><li>对于复杂的表达式，将条件分隔放在几行上</li><li>case语句不要有行尾布局的例外</li></ul></li><li>单条语句布局<ul><li>各种标点符号两侧使用空格会让逻辑表达式更易读</li><li>使用空格让数组引用，子程序参数更易读</li><li>单条语句过长时，应分行，并让续行显得更明显，通常在行尾以<code>&amp;&amp;</code>、<code>||</code>、<code>+-*/</code>等符号为结尾</li><li>续行要以标准的空格数缩进</li><li>不要将赋值语句按等号对齐</li><li>每行仅写一条语句（C++中不要让一行里有多个副作用操作（如<code>++a</code>））</li></ul></li><li>数据声明布局<ul><li>每行只声明一个变量</li><li>合理组织声明顺序：建议按类型分类</li></ul></li><li>注释布局<ul><li>注释的缩进要与相应代码一致</li><li>每行注释用至少一个空行分开</li></ul></li><li>子程序布局<ul><li>用空行分隔子程序的各部分</li><li>将子程序参数按标准缩进，如果参数过多，可以考虑一行放一个参数</li></ul></li><li>类布局<ul><li>类的内容按以下顺序排布：说明类及其完整用法的头部注释、类数据、构造函数与析构函数、public子程序、protected子程序、private子程序</li><li>一个文件应只有一个类，文件的命名应与类名有关</li><li>在文件中清晰地分隔各子程序</li></ul></li></ul><p>关于块结构和花括号指定的块边界，不同语言有不一样的规范。书中所提规范放在某些语言也不适用，实际使用应遵循相应的规范，此处不赘述书中所提的布局与风格。</p><h1 id="2-自说明代码"><a href="#2-自说明代码" class="headerlink" title="2. 自说明代码"></a>2. 自说明代码</h1><h2 id="2-1-编程风格的重要性"><a href="#2-1-编程风格的重要性" class="headerlink" title="2.1 编程风格的重要性"></a>2.1 编程风格的重要性</h2><p>自说明代码代表了易读性的最高水平，而且一般是<strong>由良好的编码风格决定</strong>，很大程度<strong>与注释无关</strong>。对于精心编写的代码而言， 注释不过是美丽衣裳上的小饰物而已。关于自说明代码所体现出的编码风格，请参见<a href="http://www.kancloud.cn/raytaylorlin/code-complete-checklist/150866" target="_blank" rel="noopener">核对表：自说明代码</a></p><h2 id="2-2-高效注释"><a href="#2-2-高效注释" class="headerlink" title="2.2 高效注释"></a>2.2 高效注释</h2><p>注释的作用分为六种：重复代码（用文字把代码的工作又描述一次，<strong>这种注释是废话，应杜绝</strong>）、解释代码（通常是因为代码含糊不清，此时应<strong>改进代码</strong>而不是添加注释）、代码标记（提示工作未做完，待修复等等）、概述代码（用一两句话把若干行代码的意思说出来）、代码意图说明（指出一段代码要解决的问题，而非解决问题的方法）、传达代码无法表述的信息（如版权声明、保密要求、doc注释符号等等）。<strong>对于完工的代码，只允许有的三种注释类型：概述代码、代码说明意图和代码无法表达的信息。</strong></p><p>注释占用太多时间通常归因于两点：</p><ol><li>注释的风格可能耗时或枯燥乏味。如果这样，请另谋新的风格。需要庞大工作量的注释风格维护起来也会令人头痛。如果注释不便修改，人们就不愿意修改。于是注释就会变得不准确，起到误导作用，反而还不如没有注释</li><li>说明程序干什么的话不好想出来。这通常是你没有真正理解程序的信号。“写注释”所占用的时间其实都用在了更好地理解程序上面，而不管你写不写注释，这些时间注定是得花的</li></ol><p>下面是高效注释的几条指导原则。</p><ul><li>采用不会打断或抑制修改的注释凤格：不要为了美观而使用大量的<code>.-*</code>符号排版的注释，例如用星号围成一个矩形的注释，每加入一行都得小心维护右边的星号。如果花大量时间增删符号只是为了对齐，你就不是在编程，而是浪费时光</li><li>用伪代码编程法减少注释时间</li><li>将注释集成到你的开发过程中：不要项目快结束时才开始写注释，也不要把注释当做专门的任务，而应该边写代码边注释。</li><li>性能不是逃避注释的好借口：像Javascript的注释会增大网络传输的流量，但这不是理由，解决方案应该是构建不包含注释的发布版代码，区别于开发版代码</li></ul><h2 id="2-3-注释技术"><a href="#2-3-注释技术" class="headerlink" title="2.3 注释技术"></a>2.3 注释技术</h2><ul><li>注释单行<ul><li>不要随意添加无关的注释</li><li>尽量不要使用行尾注释，因为写行尾难以格式化和维护，也经常是重复说明本行代码的废话。这几种例外情况可以使用行尾注释：用于数据声明，或标记代码块尾部（如end while，end if）</li></ul></li><li>注释代码段<ul><li>注释应表达代码段的意图，指出代码本身说不清的本意。TIPS：在给代码段写意图注释时，想象这段代码转换成一个子程序，应该命名什么名字，这个名字很有可能就是意图</li><li>注释应注重“为何做（why）”而不是“怎么做（how）”</li><li>用注释为后面的内容做铺垫：好的注释会让读者只要浏览注释就能了解代码在做什么，去哪找特定的操作</li><li>说明非常规做法（trick）</li><li>代码错误或语言环境独特点都要加注释</li><li>给出不得不故意违背良好编程风格的理由</li><li>不要为投机取巧的代码加注释说明，应重写之</li></ul></li><li>注释数据声明<ul><li>注释数据的单位（包括单位所处的背景环境）和取值范围（包括输入数据的限制）</li><li>注释枚举类型各个值的含义，注释bit位标识的含义</li><li>注释全局数据：指出该数据的目的，为何必须是全局数据</li></ul></li><li>注释控制结构<ul><li>应在每个if、case、循环前加上注释，阐明控制结构的意图</li><li>在长控制结构或嵌套控制结构结尾处加上注释</li><li>如果用到了上一条规则，那么应将控制结构结束处的注释看成是代码太复杂的征兆：最好办法就是重写代码，使之不再复杂到需要费劲注释的程度</li></ul></li><li>注释子程序<ul><li>在子程序上部用一两句话说明其意图，如果参数很复杂要在声明参数处注释这些参数（如果参数涉及输出，还要特别说明）</li><li>利用诸如Javadoc之类的代码说明工具，则可以替代上一条</li><li>注释接口假设：例如假设传入的数组是有序的，传入的对象是初始化过的等等，都应该描述清楚</li><li>对子程序的局限性作注释：例如指出结果的精确度，子程序碰到麻烦时的默认行为，对程序做什么修改会损坏此子程序等等</li><li>说明子程序对全局数据的操作，如果有的话</li><li>记录所用算法的来源</li></ul></li><li>注释类和文件<ul><li>说明类的设计方法，局限性、用法假设，不要在类接口处说明实现细节</li><li>在文件开头处用注释块说明文件的意图和内容</li><li>在文件注释块中包含作者姓名、电子邮件、电话号码、版本控制标记、法律通告等</li></ul></li></ul><p>参考文献：电子工业出版社《代码大全（第2版）》第31、32章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（十三）——代码集成</title>
      <link href="/tech/complex/software/software-construction-13/"/>
      <url>/tech/complex/software/software-construction-13/</url>
      
        <content type="html"><![CDATA[<p>集成是指将一些独立的软件组件组合为一个完整系统。对大项目，集成也许要花数周或数月时间，把一组程序编织为一个整体。本文将首先介绍不太常用的阶段式集成，然后再介绍更为常用的增量集成，其中集成的策略是讨论的重点。最后每日构建与冒烟测试的使用原则。</p><a id="more"></a><p>集成是在开发人员完成开发者测试之后才进行的，而且集成过程是与系统测试一道进行的，所以集成有时也被认为是一种测试行为。然而，集成本身就足够复杂了，因此应该被看做一项独立的行动。程序集成有两种方式：阶段式集成和增量集成。</p><h1 id="1-阶段式集成"><a href="#1-阶段式集成" class="headerlink" title="1. 阶段式集成"></a>1. 阶段式集成</h1><ol><li>设计、编码、测试、调试各个类，这一步称为“单元开发”</li><li>将这些类组合为一个庞大的系统，这一步成为“系统集成”</li><li>测试并调试整个系统，这一步成为“系统瓦解（system dis-integration）”</li></ol><p>这种集成的问题是，当第一次把系统中的类放到一起时，新的问题会不可避免地大量浮现，所有的类都有嫌疑导致出问题的位置难以确定。所以对绝大多数情况，阶段式集成都不是很适用。</p><h1 id="2-增量集成"><a href="#2-增量集成" class="headerlink" title="2. 增量集成"></a>2. 增量集成</h1><h2 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h2><ol><li>开发一个小的系统功能部件。它可能是最小的功能部件、最难的部件、关键部件、或者以上的某种组合，对它彻底地测试并调试。将它作为骨架，稍后附着肌肉、神经、皮肤等系统的其余部件</li><li>设计、编码、测试、调试某个类</li><li>将这个新的类集成到系统骨架上，测试并调试“骨架和新类的结合体”。在进一步添加任何新类之前，确保该结合体能工作。如果做完了剩余的所有工作，就回到步骤2开始重复这一过程</li></ol><h2 id="2-2-相对阶段式集成的优势"><a href="#2-2-相对阶段式集成的优势" class="headerlink" title="2.2 相对阶段式集成的优势"></a>2.2 相对阶段式集成的优势</h2><ul><li>易于定位错误：降低“多个问题之间相互影响”或“一个问题将另一个问题掩盖”的风险</li><li>及旱在项目里取得系统级的成果</li><li>改善对进度的监控：利于管理层判断进度和需求</li><li>更加充分地测试系统中的各个单元</li><li>能在更短的开发进度计划内建造出整个系统</li></ul><h2 id="2-3-策略"><a href="#2-3-策略" class="headerlink" title="2.3 策略"></a>2.3 策略</h2><ul><li>自顶向下集成<ul><li>一般从主入口（Main函数、主窗体等等）开始，测试顶层类时需要一些存根（stub）类辅助，最终逐渐替换为实际的类</li><li>优点：能快速得到一个能部分工作的系统，并及早地暴露一些设计上的问题</li><li>缺点：棘手的系统接口的演练必须留到最后才进行，有问题的底层可能会反过来影响顶层</li><li>纯粹的自顶向下集成几乎是不可能的，大多时候使用混合方法集成，或用下图的在各个竖直划分的功能块中自顶向下集成</li></ul></li></ul><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fsoftware%2F%E5%9C%A8%E5%90%84%E4%B8%AA%E7%AB%96%E7%9B%B4%E5%88%92%E5%88%86%E7%9A%84%E5%8A%9F%E8%83%BD%E5%9D%97%E4%B8%AD%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E9%9B%86%E6%88%90.png" alt="在各个竖直划分的功能块中自顶向下集成"></p><ul><li>自底向上集成<ul><li>首先要完成整个系统的设计，然后一个一个添加底层类向上层集成，最初需要编写驱动测试类</li><li>优点：容易定位错误，尽早演练“可能存在问题的系统接口”</li><li>缺点：如果高层存在概念上的设计问题，那么要把所有细节工作都做完才能发现</li><li>一般也很少用纯粹的自底向上集成</li></ul></li><li>三明治集成<ul><li>首先集成继承体系顶部的高层业务对象类，然后集成底部的与设备接口的类和广泛使用的工具类，最后集成中间层的类</li><li>结合了上述两种方式的优点，是现实的实用的方法</li></ul></li><li>风险导向的集成<ul><li>大顺序和三明治集成一致，但细节顺序，是优先考虑高风险的实现最有挑战的部件，如顶层接口、底层系统接口、未被透彻理解的算法的类等等</li></ul></li><li>功能导向的集成<ul><li>首先需要搭建好骨架，然后按照功能（模块）划分顺序来集成，如下图所示</li></ul></li></ul><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fsoftware%2F%E5%8A%9F%E8%83%BD%E5%AF%BC%E5%90%91%E7%9A%84%E9%9B%86%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="功能导向的集成示意图"></p><ul><li>T型集成<ul><li>先选中某个特定的“竖直块”及早开发并集成，这个功能块应该能从头到尾演练系统，并找出系统设计的全部主要问题。纠正所有问题后，就可以开始开发系统其它核心部件，如下图所示。这种方法常与风险导向和功能导向集成集合使用</li></ul></li></ul><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fsoftware%2FT%E5%9E%8B%E9%9B%86%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="T型集成示意图"></p><p>集成顺序的策略有多种多样的形状和规模，没有哪一种对所有情况而言都是最佳的。<strong>最佳集成步骤随项目不同而变化，最佳解决方案总是为了满足特定项目的特定需求而制定的，不要像教条一样遵循前面提到的任何过程。</strong></p><h1 id="3-每日构建与冒烟测试"><a href="#3-每日构建与冒烟测试" class="headerlink" title="3. 每日构建与冒烟测试"></a>3. 每日构建与冒烟测试</h1><p>无论选用哪种集成策略，<a href="http://baike.baidu.com/view/1704207.htm" target="_blank" rel="noopener">每日构建（daily build）</a>和<a href="http://baike.baidu.com/view/120001.htm" target="_blank" rel="noopener">冒烟测试</a>都是软件集成的好方法。这些简单的过程可以降低出现低质量软件的风险，也便于诊断缺陷，并且每天的成果可以极大地鼓舞士气。以下是这两种方法的一些使用原则：</p><ul><li>关键是<strong>每一天</strong>坚持build：某次build失败可以将错误锁定在一天之内</li><li>检查失败的build：每个项目要建立一套评定“什么才算是破坏了build”的质量标准</li><li>每天进行准确的冒烟测试：冒烟测试应彻底地从头到尾演练<strong>已完成的</strong>系统的主要功能，不要认为是浪费时间的重复性工作</li><li>自动化：<strong>脱离自动化谈每日构建与冒烟测试是不切实际的</strong></li><li>成立build小组</li><li>仅当有意义时，才将修订（revisions）加入build中……：因为通常开发者编写代码的速度不会快到使系统每天都有明显的进展</li><li>……但是别等太久才将修订加入进来：警惕某个开发人员接连两三天都不check in他做的改动，他很可能陷入一组牵扯到大量文件的修订中</li><li>要求开发人员在把他的代码添加到系统之前，进行本地冒烟测试</li><li>为即将添加到build的代码准备一块暂存区，在暂存区产生新的build并认为其可接受时，才合并到主源码中</li><li>惩罚破坏build的人：build失败是异常情况，应严肃对待</li><li>在早上发布build：测试人员可以当天测试，发现问题也能尽早找到开发者解决</li><li>即使有进度压力，也要保持daily build和冒烟测试</li></ul><p>参考文献：电子工业出版社《代码大全（第2版）》第29章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（十二）——软件的规模与管理</title>
      <link href="/tech/complex/software/software-construction-12/"/>
      <url>/tech/complex/software/software-construction-12/</url>
      
        <content type="html"><![CDATA[<p>软件开发的规模扩大并不是像“拿一个小项目来，然后增大它的每一部分”那样简单。如果要开发大型软件，就必须了解软件规模对构建的影响。此外，本文将记录与构建直接相关的一些特定管理问题。如果你是一名开发人员，本文将帮助你了解管理者需要考虑的一些问题；如果你是一名管理者，本文将帮助你了解开发人员是如何看待管理者的，以及如何才能有效地管理构建。</p><a id="more"></a><h1 id="1-程序规模对构建的影响"><a href="#1-程序规模对构建的影响" class="headerlink" title="1. 程序规模对构建的影响"></a>1. 程序规模对构建的影响</h1><ul><li>成员交流与项目规模的关系：交流路径越多，花在交流上的时间就越多（见下图），因交流而出错的机会也就越大，改善交流效率的常用方法是采用正式的文挡<ul><li><img src="http://7d9rl0.com1.z0.glb.clouddn.com/image/software/%E6%88%90%E5%91%98%E4%BA%A4%E6%B5%81%E4%B8%8E%E9%A1%B9%E7%9B%AE%E8%A7%84%E6%A8%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="成员交流与项目规模的关系"></li></ul></li><li>项目规模对错误的影响：在小项目中，构建错误大约占所有被发现错误的75%，在更大的项目中，构建错误占错误总数的比例逐步下降到50%左右，而需求错误和架构错误则弥补了其中差额。缺陷密度（每1000行代码所包含的缺陷数量）会随项目规模增大而增加</li><li>顶目规模对生产率的影响：小项目的生产率会比大项目高出2至3倍，并且最小的项目和最大的项目的生产率差距可能达到5到10倍之巨</li><li>顶目规模对开发活动的影响：对小型项目，构建占差不多65%的开发实践，随着项目规模增大，构建的比重逐渐减小，架构、设计、集成和测试占更多时间</li></ul><h1 id="2-管理构建"><a href="#2-管理构建" class="headerlink" title="2. 管理构建"></a>2. 管理构建</h1><h2 id="2-1-鼓励良好的编码实践"><a href="#2-1-鼓励良好的编码实践" class="headerlink" title="2.1 鼓励良好的编码实践"></a>2.1 鼓励良好的编码实践</h2><p>从管理的角度出发，强制采用一套严格的技术标准并不是个好主意。如果项目中有人要制定标准，那么应该由一位受人尊敬的架构师来做，而不应该由管理者来做。下面给出一些编码实践，这些实践比呆板的编码标准更容易实行：</p><ul><li>给项目的每一部分分派两个人：结对编程，导师带学生等等</li><li>同行复查代码：包括程序员本人和至少两名评审员的复查，可以为改善代码质量提供压力</li><li>要求代码签名：在认定代码完成之前，高级技术人员要在代码清单上签字</li><li>安排一些好的代码示例供人参考</li><li>强调代码是公有财产</li><li>奖励好代码：给予程序员想要的奖励，只有非常出色的代码才应得到奖励</li></ul><h2 id="2-2-配置管理"><a href="#2-2-配置管理" class="headerlink" title="2.2 配置管理"></a>2.2 配置管理</h2><p>配置管理即“变更控制”。如果你不对需求变更加以控制，那么就会为系统中某些最终会被去除的部件编写代码，也会去写出一些可能与系统中新的部件不兼容的代码；可能会修改某个别人也正在修改的子程序，把两个人的改动合并导致出现问题。总之，配置管理就是使用评估提交的更改、追踪更改、保留系统在不同时间点的历史版本等等技术来对软件项目的变化进行控制。</p><ul><li>需求变更和设计变更<ul><li>遵循某种系统化的变更控制手续</li><li>成组地处理变更请求：先记下所有的想法和建议，直到有时间再去整体处理它们，以防总是在中途突然变卦</li><li>评估每项变更的成本：重新设计和编码，修改用户文档，评估代码复查，重新测试等等各种时间成本</li><li>提防大量的变更请求：有时这可能是一个表明需求、架构或上层设计做的不够好导致无法支持变更的警报</li><li>成立变更控制委员会或者类似机构</li><li>警惕官僚主义，但也不要因为害怕官僚主义而排斥有效的变更控制</li></ul></li><li>软件代码变更：使用合适的版本控制软件</li><li>工具版本：可能有些项目需要“重新构造出‘创建软件的各个特定版本’的原样环境”的能力，这时需要把编译器、链接器、代码库等也纳入版本控制中</li><li>机器配置：使用标准化的开发机器配置和操作系统映像，可以省掉许多开发前配置的麻烦</li><li>备份计划：项目过程中应定期备份代码、文档、图表以及保存介质；要测试备份过程，确保所需的全部数据能正确恢复；昨晚项目后及时归档</li></ul><h2 id="2-3-评估构建进度"><a href="#2-3-评估构建进度" class="headerlink" title="2.3 评估构建进度"></a>2.3 评估构建进度</h2><p>对于项目预估进度和实际进度，有调查表明，开发人员的估计值比实际值要乐观20%~30%。评估项目规模的方法有很多种，例如使用评估软件，使用算法方法，聘请外界的评估专家，评估项目的每一部分并加起来等等。下面是一套评估项目的参考原则：</p><ul><li>建立目标：理清评估的目的、内容、准确度、乐观评估和悲观评估结果等</li><li>为评估留出时间，并且做出计划</li><li>清楚地说明软件需求</li><li>在底层细节层面（划分为多个小块并分别）进行评估</li><li>使用若干不同的评估方法，并且比较其结果</li><li>在项目推进过程中定期做重新评估</li></ul><p>为了按时完成软件项目而做的“计划”中，评估是很重要的组成部分。然而，最初评估的准确度的重要性远远比不上“随后为了完成进度而成功地<strong>控制资源</strong>”的重要性。如果项目进度落后了，人们经常会产生一些错觉：“我们后面一定会加班加点把时间补回来”，调查显示越接近项目后期，延误和超支的现象就越严重；“扩充团队来加速开发”，新手需要先花时间熟悉项目，占用现有人员的培训时间，然后才能发挥出生产率，而且仅仅增加人员数量，会导致项目交流的复杂度和数量增加，除非项目的任务是可分割的才能通过增加人手完成。</p><p>缩减项目范围是在进度落后时的有效手段。最初做产品计划的时候，要把产品的功能划分成“必须有”、“有了更好”和“可选择”三类。如果进度落后了，那么就调整“可选择”和“有了更好”的优先级，并扔掉那些最不重要的功能。</p><h2 id="2-4-把程序员当人看"><a href="#2-4-把程序员当人看" class="headerlink" title="2.4 把程序员当人看"></a>2.4 把程序员当人看</h2><p>首先要了解程序员的时间分配。研究表明一个程序员大约有30%的时间花费在“对项目没有直接好处”的非技术活动之上：步行、个人事务等，学习和编写代码占约30%。</p><p>其次是了解程序员的信仰问题。这些信仰涉及编程语言、编码风格、编程工具、编程方法论等等。作为一个管理者，要清楚地知道信仰是一个敏感的问题，对这些领域要使用“建议”或者“指导原则”（避免僵硬的“规则”或“标准”），并让程序员们制定他们自己的标准。当然，如果有人因可读性差等影响整个项目的实践行为，为了提高代码质量，不要怕引发一些摩擦。</p><p>最后，要了解物理环境对程序员生产率有着巨大的影响。这些环境包括桌子、椅子、电脑、书籍、键盘，以及办公氛围、不经常被打扰的环境等等。如果你的工作环境属于最差的那25%，那么你有机会给生产率带来100%的提升，办法是把环境改善为最佳的那25%。</p><h2 id="2-5-管理你的管理者"><a href="#2-5-管理你的管理者" class="headerlink" title="2.5 管理你的管理者"></a>2.5 管理你的管理者</h2><p>在软件开发中，如果你需要面对非技术出身的管理者，你可能要肩负起“管理你的管理者”的责任。其要点在于，你要表现得使你的管理者认为他仍然在管理你。有这么一些应对管理者的方法：把你希望做什么的念头先藏起来，等着你的管理者组织一场有关你希望什么的头脑风暴/集体讨论；把做事情的正确方法传授给你的管理者；关注你的管理者的兴趣，按照他的真正意图去做；拒绝按照你的管理者所说的去做，坚持用正确的方法做自己的事；换工作。</p><p>参考文献：电子工业出版社《代码大全（第2版）》第27、28章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（十一）——代码性能的调整</title>
      <link href="/tech/complex/software/software-construction-11/"/>
      <url>/tech/complex/software/software-construction-11/</url>
      
        <content type="html"><![CDATA[<p>本文首先概述了程序运行性能应该考虑的一些问题，然后从策略上和技术上两个方面来探讨代码性能的调整问题。技术上的代码调整并没有什么万金油的方法，也不是灵丹妙药，唯一可以信赖的法则就是每次都应当在具体的环境下评估代码调整所带来的效果，而本文所列的调整方法则仅供参考。此外，追求性能的背后往往伴随着牺牲程序的可读性和可维护性，而<strong>在很多情况下，代码的可读性和可维护性都要比运行速度或资源占用更为重要。</strong>因此在调整代码时一定要考虑这样的性能提升是否真的必要。</p><a id="more"></a><h1 id="1-性能概述"><a href="#1-性能概述" class="headerlink" title="1. 性能概述"></a>1. 性能概述</h1><p>现实中，相对于代码质量和纯粹的性能，用户更关心的是程序的外在特性和处理能力。性能同代码速度之间存在着很松散的联系。如果只是关注于代码的运行速度，你的工作不免顾此失彼。要特别当心放弃其他功能去让你的代码跑得更快。如果过分强调速度，程序的整体性能（表现）常常不升反降。</p><p>如果要追求程序的效率，可以从以下几个方面来思考问题：</p><ul><li>性能需求：客户要求的系统响应时间有时决定了设计方案的复杂度和成本，在花费时间处理一个性能问题之前，要想清楚是否真的需要满足这样的需求</li><li>程序架构：优先考虑整体性能，然后再为每个子系统和类设置要达到的性能目标</li><li>类和子程序设计：在这一层次，数据结构和算法将对性能产生重要影响</li><li>与操作系统的交互：考虑系统I/O，系统调用等性能</li><li>代码编译：这一层次由编译器和转化后的机器码决定，通常程序员无法干预</li><li>硬件：有时直接升级硬件是最直接了当的提升性能的办法</li></ul><h1 id="2-策略上的代码调整"><a href="#2-策略上的代码调整" class="headerlink" title="2. 策略上的代码调整"></a>2. 策略上的代码调整</h1><h2 id="2-1-佩雷托法则"><a href="#2-1-佩雷托法则" class="headerlink" title="2.1 佩雷托法则"></a>2.1 佩雷托法则</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%B8%95%E9%9B%B7%E6%89%98%E6%B3%95%E5%88%99" target="_blank" rel="noopener">帕雷托法则</a>即是众所周知的80/20法则，其对程序性能优化也是有效的，即程序中20%的子程序耗费了80%的执行时间。因此程序员们应当衡量代码的各个部分（如使用性能分析器），找出最需要关注的地方，然后集中火力来对付占用了绝大部分资源的少量代码。</p><h2 id="2-2-代码调整的一些误区"><a href="#2-2-代码调整的一些误区" class="headerlink" title="2.2 代码调整的一些误区"></a>2.2 代码调整的一些误区</h2><ul><li>在高级语言中，减少代码的行数就可以提升所生成的机器代码的运行速度，或是减少其资源占用——<strong>错误！</strong>：实际上高级语言代码行数和程序最终的资源占用和运行速度之间并没有必然联系</li><li>特定运算可能比其他的快，代码规模也较小——<strong>错误！</strong>：程序性能受语言、编译器种类、编译器版本、库种类、库版本、中央处理器、机器内存等等环境的影响</li><li>应当随时随地进行优化——<strong>错误！</strong>：应该在整个系统完成之后综合分析，才能最准确快速地找到瓶颈</li><li>程序的运行速度同其正确性同等重要——<strong>错误！</strong>：程序要先保证正确运行，再考虑运行速度</li><li>编译器的优化功能可能比你想象的要强大得多：在编写代码时自作聪明，编译器在优化这些代码的时候会痛苦不堪，结果是你的程序倒霉，<strong>应该使用直白的代码</strong></li></ul><h2 id="2-3-常见的性能瓶颈"><a href="#2-3-常见的性能瓶颈" class="headerlink" title="2.3 常见的性能瓶颈"></a>2.3 常见的性能瓶颈</h2><ul><li>输入/输出操作：包括文件、数据库、网络等等的读写</li><li>操作系统内存分页时的缺页中断</li><li>系统调用：考虑编写自己的服务程序来替代，或者减少不必要的系统调用等等</li><li>解释型语言</li><li>代码中的错误：如没有去掉调试代码，忘记释放内存，数据库表设计失误，轮询并不存在的设备，超时等等</li></ul><h2 id="2-4-性能测量"><a href="#2-4-性能测量" class="headerlink" title="2.4 性能测量"></a>2.4 性能测量</h2><p>在优化代码的过程中，一定要使用工具来进行性能测量，特别是对代码进行改进之后要实际测量一下看有没有改进。一个的典型的案例是C++对矩阵元素求和，通常的写法是二重循环遍历行列求和，但有的人可能会觉得数组访问和循环条件判断会花掉很多时间，对于一个100×100的矩阵会产生一万次乘法和加法，于是考虑改成一重循环用指针访问数组（但这样会牺牲代码可读性）。但实际测量结果时修改后性能<strong>没有任何变化</strong>，原因是编译器早已将数组访问改为用指针实现。这个案例告诉我们，<strong>性能问题的很多方面都是违反直觉的，而且经验对性能优化也没有太大的帮助。</strong></p><p>找出性能瓶颈之后，应该结合多种优化方法反复对代码进行迭代和调整，尽管每种方法单独实施起来收效并不大，但把所有方法结合起来将可以优化出非常好的结果。</p><h1 id="3-技术上的代码调整"><a href="#3-技术上的代码调整" class="headerlink" title="3. 技术上的代码调整"></a>3. 技术上的代码调整</h1><p>再次重申，<strong>在很多情况下，代码的可读性和可维护性都要比运行速度或资源占用更为重要。</strong>因此在调整代码时一定要考虑这样的性能提升是否真的必要。而且调整完之后一定要用工具测量一下性能的提升到底有没有起效。</p><ul><li>逻辑判断的调整<ul><li>在知道答案后停止判断：利用好“短路求值”的语言特性中断and的条件判断，或者在循环遍历查找时找到后break退出</li><li>按照出现频率来调整if-elseif的顺序，让运行最快和判断结果最有可能为真的判断首先被执行</li><li>用查询表替代复杂表达式</li><li>使用惰性求值：仅到必须使用的时候才去处理数据，例如有一张大数据表，程序仅仅用到很小一部分，与其在程序启动时生成表的所有内容，不如放到需要的时候再计算</li></ul></li><li>循环的调整<ul><li>将循环中的判断往外提，避免每次在循环中做重复的判断</li><li>当两个循环的下标变化相同时，可以考虑合并成一个循环，但要确保代码先后顺序一致</li><li>将循环展开（减少了循环条件判断）：会严重影响可读性，而且只对少量元素的循环适用</li><li>尽可能减少在循环内部做的工作：例如将重复计算的常量移到循环外</li><li>在线性查找循环中，使用“哨兵值”来替代多次条件判断</li><li>把最忙的（即循环次数多的）循环放在最内层</li></ul></li><li>数据变换的调整<ul><li>使用整数而不是浮点数</li><li>尽可能减少数组维度：例如考虑用一维数组来表示二维的矩阵</li><li>尽可能减少数组引用</li><li>使用辅助索引：添加相关数据，使得对某种数据类型的访问更为高效。例如，如果数据类型中的条目很大或是存于磁盘上难于移动，可以创建一个存放关键码和指向详细信息的指针的辅助索引，在内存中对索引进行排序或查找，最后进行一次代价高昂的访问即可</li><li>使用缓存机制：缓存常用的或者需要耗费大量时间计算的值。创建新元素的代价越大，请求相同信息的次数越多，那么缓存就越有价值，风险是增加程序的复杂性</li></ul></li><li>表达式的调整<ul><li>利用代数恒等式：例如<code>not (a or b)</code>比<code>not a and not b</code>省一次not操作，判断<code>x &lt; y</code>要比判断<code>sqrt(x) &lt; sqrt(y)</code>省上几十甚至上百倍的时间</li><li>削弱运算强度：如用加法替代乘法，乘法代替乘幂，移位替代乘除，三角恒等式代换等价的三角函数，单精度数代替双精度数等等</li><li>编译期初始化：把代价高昂的常量计算提前定义成常量</li><li>如果系统函数提供的功能过于复杂，考虑自己写一个：例如计算以2为底且是整数的对数函数，与其使用官方的浮点log函数计算，不如自己写一个穷举整数范围的Log2函数</li><li>删除重复使用的公共子表达式</li></ul></li><li>子程序的调整<ul><li>将子程序重写为内联（C++）</li><li>用低级语言重写核心代码：应先用高级语言编写整个应用程序，经过完整测试验证正确性后，如果需要改进性能，再考虑用少量的低级语言去重写核心部分。例如某些语言可能不擅长处理位操作，此时将这部分直接翻译成汇编是不错的选择</li></ul></li></ul><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>研究表明，任何特定优化的效果实际上都不可预测：每一步代码调整所产生的影响都受制于编程语言、编译器、编译器的版本、代码<br>库、库版本以及编译器设置等各种因素。此外，代码调整无可避免地为性能改善的良好愿望而付出复杂性、可读性、简单性、可维护性方面的代价。由于每一次调整后需要对性能进行重新评估，代码调整还引入了巨额的管理维护开销。</p><p>进行代码调整时，应该恪守“对每一次的改进进行量化”的准则。如果某项优化非常重要，值得为它付出剖析和对优化效果进行量化测量的代价，那么只要优化有效，我们还是可以去做的。</p><p>参考文献：电子工业出版社《代码大全（第2版）》第25、26章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（十）——测试与重构</title>
      <link href="/tech/complex/software/software-construction-10/"/>
      <url>/tech/complex/software/software-construction-10/</url>
      
        <content type="html"><![CDATA[<p>测试可以由开发人员或专门的测试人员进行。按层级分，测试可以分为单元测试、组件测试、继承测试、回归测试、系统测试；按是否了解对象内部工作机制分，测试可以分为黑盒测试和白盒测试。本文关注的是开发人员所进行的白盒测试。重构是“在不改变软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改”的过程。本文将讲述软件演化以及重构的一些理念。</p><p>测试和重构都是非常大的话题，大到足以各用一本经典著作来阐述，如<a href="https://book.douban.com/subject/1801050/" target="_blank" rel="noopener">《软件测试》</a>和<a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构：改善既有代码的设计》</a>。因此本文也仅是记录一些要点，如果要深入了解，还是要阅读相关的书籍为好。</p><a id="more"></a><h1 id="1-开发者测试"><a href="#1-开发者测试" class="headerlink" title="1. 开发者测试"></a>1. 开发者测试</h1><h2 id="1-1-开发者测试在软件质量中的角色"><a href="#1-1-开发者测试在软件质量中的角色" class="headerlink" title="1.1 开发者测试在软件质量中的角色"></a>1.1 开发者测试在软件质量中的角色</h2><ul><li>测试的目标是找出错误，与其他开发活动背道而驰</li><li>测试永远不可能彻底证明程序中没有错误</li><li>测试本身并不能改善软件的质量，只能用来指示</li><li>测试时要求你假设会在代码里面找到错误</li></ul><p>根据项目大小和复杂程度的不同，开发者测试应该占整个项目时间的8%~25%。测试得出的结果，可以用来评估产品的可靠性，并指导对软件的修正。</p><h2 id="1-2-推荐方法"><a href="#1-2-推荐方法" class="headerlink" title="1.2 推荐方法"></a>1.2 推荐方法</h2><ul><li>对每一项相关的需求进行测试，以确保需求都已经被实现：最好在需求阶段就计划好这一部分的测试用例，并注意测试安全级别、数据存储、安装过程及系统可靠性等这些厂被忽略的测试点</li><li>对每一项相关的设计关注点进行测试，以确保设计已经被实现</li><li>使用一个检查表，其中记录着你在本项目迄今为止所犯的，以及在过去的项目中所犯的错误类型</li><li><strong>推荐先写测试用例再写代码</strong>：可以更早地把需求问题暴露出来，迫使你写代码前思考一下设计，并更早地发现代码中的缺陷</li></ul><h3 id="1-2-1-结构化基础测试"><a href="#1-2-1-结构化基础测试" class="headerlink" title="1.2.1 结构化基础测试"></a>1.2.1 结构化基础测试</h3><p>一个子程序所需的测试用例的<strong>最少数量</strong>可以用下面的简单方法计算：</p><ol><li>对通过子程序的直路，开始的时候记1</li><li>遇到if、while、repeat、for、and以及or关键字或者其等价物时，加1</li><li>遇到每一个case语句就加1，如果case语句没有缺省情况，则再加1</li></ol><p>假设一个子程序有5个if或for语句，那么至少需要6个测试用例，其中1个测试所有布尔条件都为真的正常情况，其余5个测试每一种假的情况。不过，结构化基础测试能够向你保证所有的代码都得到执行，但它并不能说明数据的变化情况。</p><h3 id="1-2-2-数据流测试"><a href="#1-2-2-数据流测试" class="headerlink" title="1.2.2 数据流测试"></a>1.2.2 数据流测试</h3><p>编写数据流测试用例的关键是要对所有可能的<strong>定义-使用</strong>路径进行测试，即对每一个变量测试所有在某处定义而在另一处使用的组合。因此添加完整的“己定义-已使用”所需的用例可以覆盖到结构化基础测试所覆盖不到的情况。</p><h3 id="1-2-3-其他测试建议"><a href="#1-2-3-其他测试建议" class="headerlink" title="1.2.3 其他测试建议"></a>1.2.3 其他测试建议</h3><ul><li>猜测错误：猜测程序会在哪里出错的基础之上建立测试用例，通常基于直觉或者过去的经验</li><li>边界值分析：除了分析边界点、允许的最大最小值之外，还应该注意多个变量互相关联时的边界</li><li>测试几类坏数据：数据太少（没有数据），数据太多，无效数据，长度错误的数据，未初始化的数据</li><li>测试几类好数据：正常的情形（所期望的值），最小和最大的正常情况，与旧数据的兼容性</li><li>采用容易手工检查的测试用例</li></ul><h2 id="1-3-改善测试过程"><a href="#1-3-改善测试过程" class="headerlink" title="1.3 改善测试过程"></a>1.3 改善测试过程</h2><h3 id="1-3-1-测试支持工具"><a href="#1-3-1-测试支持工具" class="headerlink" title="1.3.1 测试支持工具"></a>1.3.1 测试支持工具</h3><ul><li>为测试各个类构造脚手架：使用“模仿对象（mock object）”或“桩函数（stub routine）”来模拟测试</li><li>Diff工具：将程序输出重定向到一个文件，并与预计输出文件作比较</li><li>测试数据生成器：正确设计的随机数据生成器可以产生不寻常的测试数据组合，并且比手工构造数据更能彻底对程序进行测试</li><li>覆盖率监视器：跟踪哪些代码己经测试过了，而哪些代码还没有</li><li>数据记录器/日志记录器：监视程序，并在错误发生的时候为收集程序状态信息；另外可考虑编写自己的数据记录工具，并编译进开发版本中</li><li>符号调试器：对代码进行单步调试，跟踪变量的值等等调试手段，可以作为测试和走查代码的辅助手段</li><li>系统干扰器：这类工具有内存填充、内存抖动、选择性内存失败（模拟内存不足的情况）、内存访问边界检查（监视指针操作）等系统功能</li><li>错误数据库：用于存放以往的错误，以便检查重复出现的错误</li></ul><h3 id="1-3-2-改善测试过程"><a href="#1-3-2-改善测试过程" class="headerlink" title="1.3.2 改善测试过程"></a>1.3.2 改善测试过程</h3><ul><li>有计划的测试：就重要性而言，测试应该于设计和编码平起平坐，这就要求项目重视测试并保障这一过程的质量</li><li>回归测试：要保证每次回归测试都<strong>使用相同的测试用例</strong>，随着产品的不断发展，会添加新的测试用例，但仍应保留旧的用例</li><li>自动化测试：管理回归测试唯一可行的方法，就是将其变成一个自动化的过程</li></ul><h3 id="1-3-3-保留测试记录"><a href="#1-3-3-保留测试记录" class="headerlink" title="1.3.3 保留测试记录"></a>1.3.3 保留测试记录</h3><p>为了确定所做的修改对整个项目的影响，通常可以收集这些数据以供参考：缺陷的管理方面描述（报告日期、人员、描述、修正错误日期等等），问题的完整描述，复现错误所需要的步骤，绕过该问题的建议，相关的缺陷，问题的严重程度，缺陷根源（需求、设计、编码还是测试），对编码缺陷的分类，修正错误所改变的类和子程序，缺陷所影响的代码行数，查找该错误所花的小时数，修正错误所花费的小时数等等。</p><h1 id="2-重构"><a href="#2-重构" class="headerlink" title="2. 重构"></a>2. 重构</h1><h2 id="2-1-软件的演化与重构"><a href="#2-1-软件的演化与重构" class="headerlink" title="2.1 软件的演化与重构"></a>2.1 软件的演化与重构</h2><p>软件演化就像生物进化一样，有些突变对物种是有益的，另外一些则是有害的。区分软件演化类型的关键，就是程序的质量在这一过程中是提高了还是降低了；第二个标准是演化是源于程序构建过程还是维护过程中的修改，毕竟构建时由最初开发人员完成，没有什么修正压力，而维护时的修改则需要面对已发布产品和用户的压力。</p><p>软件演化是无法避免且具有重要意义的现象。<strong>当你有机会或迫不得已需要对代码进行改变时，就努力对代码进行改进（重构），这样未来在开发中调整就会更容易。</strong></p><p>重构的理由有许多，如代码重复，冗长的子程序，过长或嵌套过深的循环，内聚性太差的类等等。无论是哪种情况，代码都会有一些警告信号，这就是所谓的代码的“坏味道”。关于重构的更详尽的理由在专门讲重构的书都列得非常清楚，此处不再赘述。</p><h2 id="2-2-各层级的重构"><a href="#2-2-各层级的重构" class="headerlink" title="2.2 各层级的重构"></a>2.2 各层级的重构</h2><ul><li>数据级<ul><li>用具名常量替代神秘数值</li><li>使变量的名字更为清晰且传递更多信息</li><li>用函数来代替表达式</li><li>用多个单一用途变量代替某个多用途变量</li><li>将一组类型码转化为类或枚举类型</li></ul></li><li>语句级<ul><li>将复杂布尔表达式转换成命名准确的布尔函数</li><li>合并条件语句不同部分中的重复代码片段</li><li>使用break或return而不是循环控制变量</li><li>在嵌套的if-else语句中一旦知道答案就立即返回，而不是去赋一个返回值</li><li>用多态来替代条件语句（尤其是重复的case语句）</li></ul></li><li>子程序级<ul><li>将冗长的子程序转换为类</li><li>将查询操作从修改操作中独立出来</li><li>合并相似的子程序，通过参数区分它们的功能</li><li>简化或去除无用的参数</li></ul></li><li>类实现<ul><li>如果一组派生类的差别仅仅是虚函数返回的常量不同，应用数据初始化替代虚函数</li><li>整理成员函数或成员数据的位置</li><li>将特殊代码提取为派生类，将相似的代码结合起来放置到基类中</li></ul></li><li>类接口<ul><li>将包含多个不同功能的类进行拆分</li><li>删除无所事事的类</li><li>去除多余的中间者调用</li><li>对暴露在外的成员变量进行封装</li><li>对于不能修改的类成员，删除相关的Set()成员函数</li></ul></li><li>系统级<ul><li>为无法控制的数据创建明确的索引源：例如GUI控件中维护的数据无法方便或一致地访问，可以创建一个类来映射其中的数据，并将此类作为该数据的明确来源</li><li>基于类型码创建对象时，用工厂模式而不是简单地实例化对象</li></ul></li></ul><h2 id="2-3-安全重构的方法"><a href="#2-3-安全重构的方法" class="headerlink" title="2.3 安全重构的方法"></a>2.3 安全重构的方法</h2><ul><li>在开始重构之前，保存初始代码</li><li>缩小重构的步伐，不要一次性大动干戈</li><li>同一时间只做一项重构</li><li>把要做的事情列出来，并记录下在重构过程中发现的需要进行的另外一项重构任务</li><li>增加测试用例，重构完后重新测试</li><li>根据重构风险级别来调整重构方法：如果是高风险的重构，务必做好测试工作，请其他人来检查重构工作甚至采用结对编程</li></ul><p>重构是一剂良药，但也有被滥用的可能性，因此<strong>不要把重构当做先写后改的代名词</strong>，也要<strong>避免用重构代替重写</strong>。</p><p>关于重构的时机，如果拿捏不准，可以考虑这些建议：在增加子程序和类，在修补缺陷的时候进行重构；关注易于出错和高度复杂的模块；在维护环境下改善你手中正在处理的代码；定义清楚干净代码和拙劣代码之间的边界，然后尝试把代码一部分一部分移到理想的一边。</p><p>参考文献：电子工业出版社《代码大全（第2版）》第22、24章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（九）——协同构建与调试</title>
      <link href="/tech/complex/software/software-construction-9/"/>
      <url>/tech/complex/software/software-construction-9/</url>
      
        <content type="html"><![CDATA[<p>所有的协同构建技术都试图通过这样或那样的途径，将展示你工作的过程正式化，以便把错误暴露出来。软件构建不可避免地都会伴随着调试，在一些项目中，调试可能占到整个开发周期的50%。对很多程序员来说，调试是程序设计中最为困难的部分。本文的前半部分将介绍协同构建的一些实践方法，后半部分将介绍一些科学的调试手段以节省更多精力。</p><a id="more"></a><h1 id="1-协同构建"><a href="#1-协同构建" class="headerlink" title="1. 协同构建"></a>1. 协同构建</h1><h2 id="1-1-协同开发实践概要"><a href="#1-1-协同开发实践概要" class="headerlink" title="1.1 协同开发实践概要"></a>1.1 协同开发实践概要</h2><p>“协同构建”包括结对编程、正式检查、非正式技术复查、文档阅读，以及其他让开发人员共同承担创建代码及其他工作产品责任的技术。各种协同构建技术之间尽管存在着一些差异，但它们都基于一个相同的思想，那就是在工作中开发人员总会对某些错误点视而不见，而其他人不会有相同的盲点，所以开发人员让其他人来检查自己的工作是很有好处的。</p><p>大量研究和数据表明，协同开发在捕获错误方面比测试的效能更高，而且让人们意识到他们的工作会被复查，这样他们会小心谨慎地检查自己的工作。此外，协同构建有利于传授公司文化以及编程专业知识，复查是老人培养新人人以提高其代码质量的好方法。</p><h2 id="1-2-结对编程"><a href="#1-2-结对编程" class="headerlink" title="1.2 结对编程"></a>1.2 结对编程</h2><p>在进行结对编程的时候，一位程序员敲代码，另外一位注意有没有出现错误，并考虑某些策略性的问题，例如代码的编写是否正确，正在编写的代码是否所需等。全程采用结对编程的成本可能比单人开发要高大约10%~25%，但开发周期大概会缩短45%。结对编程与单独开发相比，能够使人们在压力之下保持更好的状态，能够改善代码质量，缩短进度时间表等等。要从结对编程中获益，需要遵守以下几条准则：</p><ul><li>用编码规范来支持结对编程：应提前制定标准，避免两个人把时间浪费在争论代码风格上</li><li>不要让结对编程变成旁观：不掌握键盘的那个人应该主动参与到编程当中，例如分析代码，提前思考接下来的代码应该做些什么，对设计进行评估，并对如何测试代码做出计划</li><li>不要强迫在简单的问题上使用结对编程</li><li>有规律地对结对人员和分配的工作任务进行轮换</li><li>鼓励双方跟上对方的步伐</li><li>确认两个人都能够看清楚显示器中的代码</li><li>不要强迫程序员与自己关系紧张的人结对</li><li>避免新手组合</li><li>指定一个协调工作分配的组长，其对结果和项目外其他人的联系负责</li></ul><h2 id="1-3-正式检查"><a href="#1-3-正式检查" class="headerlink" title="1.3 正式检查"></a>1.3 正式检查</h2><p>正式检查（详查）是一种特殊的复查，与普通复查的区别是：详查关注的是复查者过去所遇到的问题，专注于缺陷的检测而非修正；复查人员要为详查会议做好预先准备，并且带来一份他们所发现的己知问题的列表；详查的主持人不是被检查产品的作者，且应该已经接受过主持详查会议方面的培训；只有在参与者都做好充分准备之后才会召开详查会议，每个参与者都赋予了明确的角色（主持人、代码作者、详查评论员、记录员、只了解结果的经理）；每次详查所收集的数据都会被应用到以后的详查当中，以便对详查进行改进；高层管理人员不参加详查会议，除非你们正在详查一个项目的计划，或者其他管理方面的资料，但技术负责人可能参加。</p><p>详查由以下几个阶段组成：</p><ul><li>计划：作者提交设计或代码，主持人决定参与的人员和时间地点</li><li>概述：当评论员不熟悉他们所要详查的项目时，作者可以花大约一个小时来描述一下这些设计或代码的技术背景</li><li>准备：每一个评论员独立地对设计或者代码进行详查，找出其中的错误。给评论员赋予特定视角或待详查场景，可以有效提高复查的效率</li><li>详查会议：评论员阐述设计或阅读代码，记录员记录发现的错误。不要在开会的过程当中讨论解决方案，小组应该把注意力保持在识别缺陷上。详查速度，可以参考系统级代码每小时90行，应用级代码每小时500行</li><li>详查报告：主持人总结报告，列出每个缺陷及其类型和严重级别</li><li>返工：主持人将缺陷分配给作者修复</li><li>跟进：主持人负责监督在详查过程中分配的返工任务</li></ul><p>对于作者来说，详查的过程应该是正面的，所有参与者都是一个学习的过程。作者也应该预料到他会听到对某些缺陷的批评，不应该试图为正在被检查的工作辩护，在复查之后，作者可以独自对每一个问题进行思考，判断它是否真的是一个缺陷。</p><h2 id="1-4-走查"><a href="#1-4-走查" class="headerlink" title="1.4 走查"></a>1.4 走查</h2><p>走查是一种很流行的<strong>非正式</strong>复查方式，同时也是一种宽松的定义。既然是一种较为“随意”的复查形式，其找出程序的错误概率也相对较低，而当项目的压力增加的时候，走查更是变得几乎不可能。与走查相比，详查在消除错误方面似乎更有效。但如果你有个很大的复查团队，或者由其他组织的评审员参与，或许走查会更适合。</p><h1 id="2-调试"><a href="#2-调试" class="headerlink" title="2. 调试"></a>2. 调试</h1><p>调试本身并不是改进代码质量的方法，而是诊断代码缺陷的一种方法。软件的质量必须从开始逐步建立：开发高质量软件产品的最佳途径是精确描述需求，完善设计，并使用高质量的代码编写规范。<strong>调试只是迫不得已时采用的手段。</strong></p><p>程序不可能没有缺陷，关键是掌握避免缺陷产生的方法，并从以往的缺陷中学习。程序员在调试过程中应该理解正在编写的程序，明确犯了哪种类型的错误，从代码阅读者的角度分析代码质量，审视自己解决问题和修正缺陷的方法。</p><h2 id="2-1-效率低下的调试万法"><a href="#2-1-效率低下的调试万法" class="headerlink" title="2.1 效率低下的调试万法"></a>2.1 效率低下的调试万法</h2><p>下面列举的是调试的魔鬼指南，注意这些是<strong>让程序员们受尽折磨的传统的调试方法，应该引以为戒</strong>。</p><ul><li>凭猜测找出缺陷：把print语句随机地散布在程序中，凭输出来确定缺陷到底在哪里。如果通过print语句还是不能找到缺陷，那就在程序中修改点什么，知道有些东西好像能干活了</li><li>不要把时间浪费在理解问题上：要解决它们并不需要彻底弄懂程序，只要找出问题就行了</li><li>用最唾手可得的方式修正错误</li><li>迷信式调试：也许你会遇到这样一种程序员，他们经常碰到各种奇怪问题——不听话的机器，奇怪的编译器错误，月圆时才会出现的编程语言的隐藏缺陷，失效的数据……<strong>要知道，如果你写的程序出了问题，那就是你的原因，不是计算机的</strong></li></ul><h2 id="2-2-科学的调试方法"><a href="#2-2-科学的调试方法" class="headerlink" title="2.2 科学的调试方法"></a>2.2 科学的调试方法</h2><p>下面给出一种寻找缺陷的有效方法：</p><ol><li>将错误状态稳定下来</li><li>确定错误的来源<br> a. 收集产生缺陷的相关数据<br> b. 分析所收集的数据，并构造对缺陷的假设<br> c. 确定怎样去证实或证伪这个假设，可以对程序进行测试或是通过检查代码<br> d. 按照2(c)确定的方法对假设做出最终结论</li><li>修补缺陷</li><li>对所修补的地方进行测试</li><li>查找是否还有类似的错误</li></ol><p>如果一个错误无法重现，这通常会是一个变量初始化错误，或者是一个同时间有关的问题，或者是悬空指针问题。要将一个错误的发生稳定下来，要构造一个尽可能简单的测试用例，并假定一些产生错误的因素，用测试用例一个一个排除掉无关的因素，不断缩小错误因素的范围。一些寻找错误的小建议：在构造假设时考虑所有的可用数据，提炼产生错误的测试用例，采用多种不同的方法重现错误，用更多的数据生成更多的假设，将代码分而治之缩小嫌疑代码的范围，对之前出现过缺陷的代码和最近修改过的代码保持警惕。</p><p>在必要时，也可以采用蛮力调试。人们往往出于投机心理都宁愿去用一种有可能在五分钟内发现缺陷的高风险方法，也不愿意为某种保证能找出缺陷的方法花上半个小时。实际上当你被这种心理绕进去时，有可能几个小时甚至几天就这样浪费了。如果打算通过捷径摘取胜利果实，那么应该为尝试捷径的时间设置一个上限。<strong>如果耗时超过了上限，就应老老实实地承认问题比你最初想象的要更加难于分析，应该转到蛮力（彻查代码甚至重写）的路上重新开始。</strong></p><p>对于语法错误，虽然编译器现在做得越来越好，这个问题不应成为一个很大的障碍，但也应该注意一些编译器的坑，例如：不要过分信任编译器信息中的行号，有时问题可能出在那一行的前后；不要迷信编译器给出的错误信息；不要轻信编译器的第二条信息，如果无法迅速找出第二条或第三条错误信息的源头，先把第一条处理了再重新编译看看。</p><h2 id="2-3-修正缺陷"><a href="#2-3-修正缺陷" class="headerlink" title="2.3 修正缺陷"></a>2.3 修正缺陷</h2><ul><li>在动手之前先要真正理解问题</li><li>理解程序本身，而不仅仅是问题</li><li>花点时间编写测试用例，验证对错误的假设</li><li>修改错误后不要急着提交，可以先放松一下，等到充分考虑了这样的修改完全无误后再提交</li><li>保存最初的源代码，以方便对照</li><li>治本，而不是治标，不要用特例去绕过程序的错误</li><li>修改代码时一定要有恰当的理由</li><li>一次只做一个改动</li><li>检查自己的改动并增加能暴露问题的单元测试</li><li>修正缺陷后，搜索类似的缺陷</li></ul><h2 id="2-4-调试工具简介"><a href="#2-4-调试工具简介" class="headerlink" title="2.4 调试工具简介"></a>2.4 调试工具简介</h2><ul><li>源代码比较工具：如<a href="http://linux.die.net/man/1/diff" target="_blank" rel="noopener">diff</a>、<a href="http://www.scootersoftware.com/" target="_blank" rel="noopener">Beyond Compare</a>等，常用于比较新旧代码的差异以唤醒记忆</li><li>编译器<ul><li>将编译器的警告级别设置为最高级，尽可能不放过任何一个警告</li><li>用对待错误的态度来处理警告：一些编译器允许将警告当做错误报告</li><li>在项目组范围内使用统一的编译设置</li></ul></li><li>增强的语法检查和逻辑检查：如各种语言的lint工具（一般许多高级的编辑器都有对应插件）</li><li>性能分析器：有时花上几分钟来研究某个程序的性能分析结果，或许可以让你发现一些令人惊奇的隐藏错误</li><li>测试框架/脚手架：各种语言都有对应的测试框架</li><li>调试器：利用好编译器可能具有的以下功能：<ul><li>设置断点，某行代码执行n次或变量被赋予特定值时中断，监控变量，逐行运行代码，记录特定语句的执行</li><li>检查结构化和动态分配的数据，智能地适应用户定义的数据类型，在运行过程中修改值并继续运行</li><li>查看高级语言生成的汇编代码，查看调用链</li><li>针对每个单独的程序保存调试参数（如断点、监视变量等）</li></ul></li></ul><p>参考文献：电子工业出版社《代码大全（第2版）》第21、23章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（八）——表驱动法与一般控制问题</title>
      <link href="/tech/complex/software/software-construction-8/"/>
      <url>/tech/complex/software/software-construction-8/</url>
      
        <content type="html"><![CDATA[<p>表驱动法是一种编程模式——从表里面查找信息而不使用逻辑语句（if和case）。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。本文将介绍直接访问表、索引访问表和阶梯访问表三种常见的表驱动法。最后，本文将记录一些控制问题（如布尔表达式的使用、空语句、深层嵌套问题等等）上的使用原则，这一部分内容比较简单而且与前面的章节有一些重叠，因此将快速带过。</p><a id="more"></a><h1 id="1-表驱动法"><a href="#1-表驱动法" class="headerlink" title="1. 表驱动法"></a>1. 表驱动法</h1><p>例如当使用复杂的if-elseif逻辑对字符分类时，可以用一个查询表（数组或字典）来代替查询，当然，查询表要事先创建好。</p><h2 id="1-1-直接访问表"><a href="#1-1-直接访问表" class="headerlink" title="1.1 直接访问表"></a>1.1 直接访问表</h2><p>使用直接访问法的例子：</p><ul><li>一个月中的天数：建立含12个整数的数组，把月份当下标查询</li><li>保险费率：费率随年龄、性别、婚姻状况等变化，可以以这几个维度建立多维数组，从外部读入数据</li><li>灵活的消息格式：假定一份文件中有几百条消息，消息种类约20种，每种消息都有若干字段。可以把消息种类构造为查询表，并把每种字段对应的行为用多态实现，这样可以大幅简化对消息种类和字段进行判断</li></ul><p>使用直接访问法查表时，关键是能直接得到查询的键值。有时像保险费率中的年龄，可能小于18岁，18-65岁，超过65岁是三种不一样的费率，这时可以使用以下这些方法将其转换为可查询的键值：</p><ul><li>复制信息：查询表填充18个18岁以下的费率，47个18-65岁的费率，以此类推，缺点是复制的冗余会浪费空间，而且表中存在错误的可能性也会增加</li><li>转换键值：将一个区间通过某个函数转换为一个值，例如<code>max(min(66, age), 17)</code>可以生成一个位于17到66之间的键值，这种方法要精心设计转换函数</li><li>把键值转换提取成独立子程序：上面的转换键值方法其实不太适用于年龄转换这种复杂情况，编写一个<code>KeyFromAge()</code>方法里面写几个if判断将年龄转换为键值更加清晰</li></ul><h2 id="1-2-索引访问表"><a href="#1-2-索引访问表" class="headerlink" title="1.2 索引访问表"></a>1.2 索引访问表</h2><p>使用索引的时候，先用一个基本类型的数据从一张索引表中查出一个键值，然后再用这一键值查出你感兴趣的主数据。下图解释了这种技术的具体原理：</p><p><img src="http://7d9rl0.com1.z0.glb.clouddn.com/image/software/%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86.jpg" alt="索引访问表的原理"></p><p>索引访问技术有几个主要优点：首先，如果主查询表中的每一条记录都很大，那么创建一个浪费了很多空间的<strong>索引数组</strong>所用的空间，就要比创建一个浪费了很多空间的<strong>主查询表</strong>所用的空间小得多；其次，即使用了索引以后没有节省内存空间，操作位于索引中的记录有时也要比操作位于主表中的记录更方便廉价；最后，索引访问技术在可维护性上所具有的普遍优点，编写到表里面的数据比嵌入代码中的数据更容易维护。</p><h2 id="1-3-阶梯访问表"><a href="#1-3-阶梯访问表" class="headerlink" title="1.3 阶梯访问表"></a>1.3 阶梯访问表</h2><p>阶梯结构的基本想法是，表中的记录对于不同的数据范围有效，而不是对不同的数据点有效。最常见的例子是按分数段（浮点数）评定ABCDF等级。由于是浮点数划分范围，用数据转换函数或索引都不适合。为了使用阶梯方法，要把每一区间的上限写入一张表里，然后写一个循环，按照各区间的上限来检查分数，当分数第一次超过某个区间的上限时，就知道相应的等级了。除此之外，还可以将这种方法应用在概率分布的统计（这在游戏中的抽奖相当常见），这种无规则分布的数据是不可能用一个函数把它们整齐地转换成表键值的。使用阶梯访问表需要注意一些细节：</p><ul><li>留心端点：充分考虑每一个阶梯区间的上界，不要把&lt;误用为&lt;=</li><li>考虑用“准”二分查找取代顺序查找</li><li>考虑用索引访问采取代阶梯技术：如果执行速度很重要，应考虑用空间换时间的索引表技术</li><li>把阶梯表查询操作提取成单独的子程序</li></ul><h1 id="2-一般控制问题"><a href="#2-一般控制问题" class="headerlink" title="2. 一般控制问题"></a>2. 一般控制问题</h1><h2 id="2-1-布尔表达式的使用"><a href="#2-1-布尔表达式的使用" class="headerlink" title="2.1 布尔表达式的使用"></a>2.1 布尔表达式的使用</h2><ul><li>用true和false做布尔判断，而不要用0和1等数值</li><li>隐式地比较布尔值：即使用<code>while (!done)</code>而不要写成<code>while (done == false)</code></li><li>简化复杂的表达式：可以通过拆分复杂的判断并引入新的布尔变量，把复杂的表达式提取成布尔函数，用决策表代替复杂的条件等方法</li><li>编写肯定形式的布尔表达式：在变量命名上尽量采用肯定形式，if语句的布尔表达式尽量<strong>不用not形式</strong></li><li>用<a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">德摩根定理</a>简化否定的布尔判断</li><li>用括号便布尔表达式更清晰</li><li>理解布尔表达式是如何求值的：主要是要充分理解所用编程语言中<strong>“短路求值”</strong>的用法</li><li>按照数轴的顺序编写数值比较表达式</li><li>与0比较时应该：隐式地比较逻辑变量，显式地把数字和0相比较，显式地把指针与NULL相比较，在C语言中显示地比较字符和<code>\0</code>终止符</li></ul><h2 id="2-2-空语句"><a href="#2-2-空语句" class="headerlink" title="2.2 空语句"></a>2.2 空语句</h2><ul><li>万非得以使用空语句时，要突出这种用法：空语句并不多见，应该让其独占一行，加以缩进，用成对的花括号括住空语句以表强调</li><li>为主语句创建一个DoNothing()预处理宏或者内联函数</li><li>考虑如果换用一个非空的循环体，是否会让代码更清晰</li></ul><h2 id="2-3-深层嵌套问题"><a href="#2-3-深层嵌套问题" class="headerlink" title="2.3 深层嵌套问题"></a>2.3 深层嵌套问题</h2><p>过分深层的缩进（嵌套）是产生混乱代码的罪魁祸首之一。有研究表明，应避免使用超过3到4层的嵌套。下面给出一些用于避免深层嵌套的方法。</p><ul><li>通过重复检测条件中的某一部分来简化嵌套的if语句</li><li>在循环中用break块来简化嵌套if</li><li>把嵌套if转换成一组if-else-if语句或case语句</li><li>把深层嵌套的代码抽取出来放进单独的子程序</li><li>对于复杂的case语句，可以考虑面向对象的手段来简化</li><li>重新设计深层嵌套的代码</li></ul><h2 id="2-4-控制结构与复杂度"><a href="#2-4-控制结构与复杂度" class="headerlink" title="2.4 控制结构与复杂度"></a>2.4 控制结构与复杂度</h2><p>降低软件复杂度首先要知道如何度量复杂度，其中最著名的方法是计算子程序中“决策点”的数量：</p><ol><li>从1开始，一直往下筒骨哦程序</li><li>一旦遇到<code>if</code>、<code>while</code>、<code>repeat</code>、<code>for</code>、<code>and</code>、<code>or</code>这些关键字或同类的词，就加1</li><li>给case语句中每一种情况都加1</li></ol><p>通过下面的评分来分析子程序的复杂度：</p><ul><li>0-5：子程序可能还不错</li><li>6-10：得想办法简化子程序了</li><li>10+：把子程序的某一部分拆分成另一个子程序并调用它</li></ul><p>把子程序的一部分提取成另一个子程序，不会降低整个程序的复杂度，只是把决策点移到其他地方。但是这样做可以降低你在同一时间必须关注的复杂度水平。由于重点是要降低你需要在头脑中同时考虑的项目的数量，所以降低一个给定子程序的复杂度是有价值的。10个决策点的上限并不是绝对的。应该把决策点的数量当作一个警示，该警示说明某个子程序可能需要重新设计了，不要死守决策点上限这个规则。</p><p>参考文献：电子工业出版社《代码大全（第2版）》第18、19章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（七）——防御式编程</title>
      <link href="/tech/complex/software/software-construction-7/"/>
      <url>/tech/complex/software/software-construction-7/</url>
      
        <content type="html"><![CDATA[<p>防御式编程这一概念来自防御式驾驶。在防御式驾驶中要建立这样一种思维，那就是你永远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。本文将讲述如何面对严酷的非法数据的世界、在遇到“绝不会发生”的事件以及其他程序员犯下的错误时保护你自己。</p><a id="more"></a><h1 id="1-防御式编程"><a href="#1-防御式编程" class="headerlink" title="1. 防御式编程"></a>1. 防御式编程</h1><p>防御式编程的主要思想是：子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。更一般地说，其核心想法是要承认程序都会有问题，都需要被修改。防御式编码的最佳方式就是在一开始不要在代码中引入错误。使用途代式设计、编码前先写伪代码、写代码前先写测试用例、低层设计检查等活动，都有助于防止引入错误。因此，要在防御式编程之前优先运用这些技术。</p><h2 id="1-1-保护程序免遭非法输入数据的破坏"><a href="#1-1-保护程序免遭非法输入数据的破坏" class="headerlink" title="1.1 保护程序免遭非法输入数据的破坏"></a>1.1 保护程序免遭非法输入数据的破坏</h2><p>对已形成产品的软件而言，应该做到“垃圾进，什么都不出”、“进来垃圾，出去是出错提示”或“不许垃圾进来”。通常有三种方法来处理进来垃圾的情况。</p><ul><li>检查所有来源于外部的数据的值：检查从文件、用户、网络或其他外部接口中获取的数据</li><li>检查子程序所有输入参数的值</li><li>决定如何处理错误的输入数据</li></ul><h2 id="1-2-使用断言（assert）"><a href="#1-2-使用断言（assert）" class="headerlink" title="1.2 使用断言（assert）"></a>1.2 使用断言（assert）</h2><p>断言可以用于在代码中说明各种假定，澄清各种不希望的情形。但通常断言只是在开发阶段用于帮助查清相互矛盾的假定、预料之外的情况以及传给子程序的错误数据等。在生成产品代码时，不要把断言编译进目标代码，以免降低性能和让用户看到断言报错信息。下面是关于使用断言的一些指导性建议。</p><ul><li>用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况</li><li>避免把需要执行的代码放到断言中：断言只检查变量的值，而不要在断言中<strong>运行</strong>函数</li><li>用断言来注解并验证前条件和后条件：所谓前条件是子程序或类的调用方代码在调用子程序或实例化对象之前要确保为真的属性，后条件是子程序或类在执行结束后要确保为真的属性</li><li>对于高健壮性的代码，应该先使用断言再处理错误</li></ul><h2 id="1-3-错误处理技术"><a href="#1-3-错误处理技术" class="headerlink" title="1.3 错误处理技术"></a>1.3 错误处理技术</h2><p>有很多种解决方案用于处理那些预料中可能要发生的错误，下面列举一些可用的方案，实际中还经常把这些技术集合起来使用。</p><ul><li>返回中立值：遇到错误时继续执行操作并简单地返回一个没有危害的数值。但对于关键领域（如医疗、航天），关闭程序也比显示错误的数据要好</li><li>换用下一个正确的数据：如读数据库时发现一条损坏的记录，则继续读下去直到找到一条正确记录为止</li><li>返回与前次相同的数据：在前后变化不会太大的场景使用，如游戏重绘使用上一帧的图像</li><li>换用最接近的合法值：如小于0的值用0代替</li><li>把警告信息记录到日志文件中</li><li>返回一个错误码：简单地报告有错误发生，并信任调用链上游的某个子程序会处理该错误</li><li>调用全局的错误处理子程序或对象</li><li>当错误发生时显示出错消息以提高用户体验：采用这种做法时要考虑模块划分，多语言化，还要小心不要告诉系统的潜在攻击者太多东西</li><li>用最妥当的方式在局部处理错误</li><li>关闭程序：适用于人身安全攸关的应用程序</li></ul><h2 id="1-4-异常"><a href="#1-4-异常" class="headerlink" title="1.4 异常"></a>1.4 异常</h2><p>异常是把代码中的错误或异常事件传递给调用方代码的一种特殊手段。如果在一个子程序中遇到了预料之外的情况，但不知道该如何处理的话，它就可以抛出一个异常，就好比是举起双手说“我不知道该怎么处理它一一我真希望有谁知道该怎么办！” 一样。对出错的前因后果不甚了解的代码，可以把对控制权转交给系统中其他能更好地解释错误并采取措施的部分。</p><ul><li>用异常通知程序的其他部分，发生了不可忽略的错误</li><li>只在真正例外的情况下才抛出异常：仅在其他编码实践方法无法解决的情况下才使用异常</li><li>不能用异常来推卸责任：如果某种的错误情况可以在局部处理，那就应该在局部处理掉它</li><li>避免在构造函数和析构函数中抛出异常，除非你在同一地方把它们捕获</li><li>在恰当的抽象层次抛出异常</li><li>在异常消息中加入关于导致异常发生的全部信息</li><li>避免使用空的catch语句：不要试图敷衍一个不知该如何处理的异常</li><li>了解所所用函数库可能抛出的异常</li><li>考虑创建一个集中的异常报告机制</li><li>把项目中对异常的使用标准化</li></ul><h2 id="1-5-在架构上设置隔栏来隔离错误"><a href="#1-5-在架构上设置隔栏来隔离错误" class="headerlink" title="1.5 在架构上设置隔栏来隔离错误"></a>1.5 在架构上设置隔栏来隔离错误</h2><p>隔栏是一种容损策略，这与与船体外壳上装备隔离舱或者建筑物中的防火墙是类似的。以防御式编程为目的而进行隔离的一种方法，是把某些接口选定为“安全”区域的边界。对穿越安全区域边界的数据进行合法性校验，并当数据非法时做出敏锐的反映。可以把这种方法看做是手术室里使用的一种技术——任何东西在允许进入手术室之前都要经过消毒处理。因此手术室内的任何东西都可以认为是安全的。这其中最核心的设计决策是规定什么可以进入手术室，什么不可以进入，还有把手术室的门设在哪里。</p><h2 id="1-6-编写辅助调试的代码"><a href="#1-6-编写辅助调试的代码" class="headerlink" title="1.6 编写辅助调试的代码"></a>1.6 编写辅助调试的代码</h2><p>防御式编程的另一重要方面是使用辅助调试的代码，可以用于帮助快速地检测错误。一般人除非被某个错误反复纠缠，否则是懒得花精力去写这些辅助调试代码的，但如果越早引入辅助调试的代码，它能够提供的帮助也越大。还有一种“进攻时编程”的方式来处理异常情况：在开发阶段让错误显现出来，而在产品代码运行时能够自我修复——在开发时惨痛地失败，能让你在发布产品后不会败得太惨。</p><p>如果使用了辅助调试的代码，那要做好清理的计划。例如使用类似ant或make这样的编译控制工具，或者使用内置的预处理器（如C/C++的<code>#define</code>的，如果语言不支持预编译器就考虑用变通方法写自己的预处理器），在发布的产品代码中剔除掉调试代码。</p><p>说了这么多防御式编程的手段，但是过度地防御也会引起问题，例如引入的额外代码增加了软件的复杂度，引入的代码也可能引入其他bug。因此，要考虑好什么地方你需要进行防御，然后因地制宜地调整你进行防御式编程的优先级。</p><p>参考文献：电子工业出版社《代码大全（第2版）》第8章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（六）——语句</title>
      <link href="/tech/complex/software/software-construction-6/"/>
      <url>/tech/complex/software/software-construction-6/</url>
      
        <content type="html"><![CDATA[<p>本文开始从以数据为中心的编程观点转到以语句为中心的观点上。常用的编程语句有顺序、控制和循环三种基本结构，本文将依次介绍这三种基本结构的使用原则。最后，还总结了一些不太常见的控制结构，如子程序多处返回、递归、关于goto语句的讨论。</p><a id="more"></a><h1 id="1-顺序语句"><a href="#1-顺序语句" class="headerlink" title="1. 顺序语句"></a>1. 顺序语句</h1><p>下面分别举了一个有前后明确的运行顺序的没有明显顺序的例子：</p><pre><code>// 有前后依赖关系的语句data = ReadData();results = CalculateResultsFromData(data);PrintResults(results);// 不太明显的前后依赖关系的语句revenue.ComputeMonthly();revenue.ComputeQuarterly();revenue.ComputeAnnual();</code></pre><p>如果语句之间存在依赖关系，并且这些关系要求你把语句按照一定的顺序加以排列，那么应设法使得这些依赖关系变得明显。下面是一些用于组织语句的简单原则。</p><ul><li>设法组织代码，使依赖关系变得非常明显</li><li>使子程序名能突显依赖关系</li><li>利用子程序参数明确显示依赖关系</li><li>用注释对不清晰的依赖关系进行说明：首先要尽力写没有顺序依赖关系的代码</li><li>用断言或者错误处理代码来检查依赖关系</li></ul><p>如果语句没有明显依赖关系，那也应该按一定原则来排列语句，使得其可读性更好，其中的指导原则就是就近原则：把相关的操作放在一起。<strong>要让程序易于自上而下阅读，而不是让读者的目光跳来跳去。</strong> 此外，还要把相关的语句组织在一起，一种检验的方法是，打印出要检验的程序代码（可以输出图片），然后把相关的语句画上框，如果方框彼此<strong>不交叠</strong>则相关语句组织得好。</p><h1 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2. 条件语句"></a>2. 条件语句</h1><h2 id="2-1-if-else语句"><a href="#2-1-if-else语句" class="headerlink" title="2.1 if-else语句"></a>2.1 if-else语句</h2><ul><li>首先写正常代码路径，再处理不常见情况</li><li>确保对于等量的分支是正确的：仔细考虑“&gt;”“&lt;”和“&gt;=”“&lt;=”的逻辑</li><li>把正常情况的处理放在if后面而不要放在else后面</li><li>不要在if分支执行空语句</li><li>考虑else分支：考虑是否真的仅仅只需要一个if分支就可满足，除非原因显而易见，否则也应考虑用注释来解释空else分支是没有必要的</li></ul><h2 id="2-2-switch-case语句"><a href="#2-2-switch-case语句" class="headerlink" title="2.2 switch-case语句"></a>2.2 switch-case语句</h2><ul><li>为case选择最有效的排列方式：按字母数字顺序，或者把正常的情况撞在前面，或者按执行频率高低</li><li>简化每种情况对应的操作：不要在case中堆一堆操作</li><li>不要为了使用case语句而刻意制造一个变量</li><li>把default子句用于检查真正的默认情况或检查错误</li><li>在case末尾明确无误地标明需要穿越执行的程序流程</li></ul><h1 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3. 循环语句"></a>3. 循环语句</h1><h2 id="3-1-循环的种类"><a href="#3-1-循环的种类" class="headerlink" title="3.1 循环的种类"></a>3.1 循环的种类</h2><ul><li>计数循环：执行次数一定，如for循环。<strong>不要在for循环中去修改下标值或中途退出。</strong></li><li>连续求值的循环：预先不知道循环次数，如while循环</li><li>无限循环：一旦启动就一直执行，除非在循环中间退出，如while循环带break中断</li><li>迭代器循环：容器类的常见操作，如foreach循环</li></ul><h2 id="3-2-循环的原则"><a href="#3-2-循环的原则" class="headerlink" title="3.2 循环的原则"></a>3.2 循环的原则</h2><ul><li>进入循环<ul><li>只从一个位置进入循环</li><li>把初始化代码紧放在循环前面</li><li>用<code>while(true)</code>表示无限循环</li><li>在适当的情况下多使用for循环；但如果while循环更适用的话，不要使用for循环：因为while循环需要在循环之前初始化条件，循环最后变更条件，容易出错和可读性较差</li></ul></li><li>处理循环体<ul><li>避免空循环</li><li>循环内务操作（循环变量的变更）要么放在循环的开始，要么放在循环的末尾</li><li>一个循环只做一件事：应该把循环体当做黑盒或子程序看待，读者只需要关心其循环条件是什么，而不需关心其内容</li></ul></li><li>退出循环<ul><li>设法确认循环能够终止：要考虑正常的情况、端点，及每一种异常情况</li><li>使循环终止条件看起来很明显</li><li>不要为了终止循环而胡乱改动for循环的下标</li><li>避免出现依赖于循环下标<strong>最终取值</strong>的代码：更具自我描述性的做法是，在循环体内某个适当的地方把这一最终取值赋给某个变量</li><li>考虑使用安全计数器：安全计数器是一个特殊变量，在每次循环之后都递增它，以便判断该循环的执行次数是不是过多</li><li>考虑在while循环中使用break语句而不用布尔标记</li><li>小心那些有很多break散布在循环各处</li><li>在循环开始处用continue进行判断：可以避免用一个让整个循环体的缩进的if块</li><li>除非你已经考虑过各种替换方案，否则不要使用break：使用break消除了把循环看做黑盒子的可能性</li></ul></li><li>检查端点：既要在脑海中模拟，也要手工检查一遍</li><li>循环变量<ul><li>用整数或者枚举类型表示数组和循环的边界</li><li>在嵌套循环中使用有意义的变量名来提高其可读性：避免i、j、k及下标串话误用</li><li>把循环下标变量的作用域限制在本循环内</li></ul></li><li>循环的长度<ul><li>循环要尽可能地短，以便能够一目了然：建议限制在一屏之内</li><li>把嵌套限制在3层以内</li><li>把长循环的内容移到子程序里</li><li>要让长循环格外清晰</li></ul></li></ul><h1 id="4-不太常见的控制结构"><a href="#4-不太常见的控制结构" class="headerlink" title="4. 不太常见的控制结构"></a>4. 不太常见的控制结构</h1><h2 id="4-1-子程序多处返回"><a href="#4-1-子程序多处返回" class="headerlink" title="4.1 子程序多处返回"></a>4.1 子程序多处返回</h2><p>子程序的多处返回是指一个子程序中有多处地方出现return。通常来说，应该用防卫子句（早返回或早退出）来简化复杂的错误处理，不要使用过多的缩进嵌套，并且减少每个子程序中return的数量。下面的例子很好地体现了这些原则。</p><pre><code>if (!file.validName()) {    errorStatus = FileError.InvalidFileName;    return;}if (!file.Open()) {    errorStatus = FileError.CantOpenFile;    return;}if (!encryptionKey.valid()) {    errorStatus = FileError.InvalidEncryptionKey;    return;}// 此处为处理正常情况的代码</code></pre><h2 id="4-2-递归"><a href="#4-2-递归" class="headerlink" title="4.2 递归"></a>4.2 递归</h2><p>递归并不常用，但如果使用得谨慎，一些小范围内的问题还是可以得到非常优雅的解。对于大多数问题，它所带来的解将会是极其复杂的——在那些情况下，使用简单的迭代通常会比较容易理解。</p><ul><li>确认递归能够停止</li><li>使用安全计数器防止出现无穷递归：安全计数器必须是一个不随每次子程序调用而重新创建的变量</li><li>把递归限制在一个子程序内：循环边归（A调用B, B调用C, C调用A）非常危险</li><li>留心栈空间：给安全计数器设置上限时考虑给递归子程序分配多少栈空间，并观察递归函数中局部变量的分配情况</li><li>不要用递归去计算阶乘或者斐波纳契数列：最重要的，在用递归之前你应该考虑它的替换方案</li></ul><h2 id="4-3-关于goto语句"><a href="#4-3-关于goto语句" class="headerlink" title="4.3 关于goto语句"></a>4.3 关于goto语句</h2><p>入们反对使用goto的普遍理由是：含有goto的代码很难安排好格式；使用goto也会破坏编译器的优化特性。关于goto的讨论非常多，而且其现代版本仍在以各种各样的形式出现。用不用goto是一个<strong>信仰问题</strong>。《代码大全》作者的信条是：</p><blockquote><p>在现代语言里，你可以很容易地把九成的goto替换成与之等价的顺序结构。对于这些简单的情况，你应该把goto替换掉并把这当成习惯。对于复杂的情况，你仍有九成不用goto的可能：你可以把代码拆分成小的子程序，使用try-finally，使用嵌套if，检测并重新检测某个状态变量，或者重新设置条件结构。对于这些情况，想消除goto相对来说比较难，但这是一种很好的智力训练……<br>对于剩下的那1%的情况，即当使用goto是解决问题的合理办法的时候，请在使用的同时予以详细的说明。如果你穿着雨鞋，那么就没有必要绕开泥潭走路了。不过也要虚心参考别的程序员提出的不用goto的方法。也许他们发现了一些被你忽视的东西。</p></blockquote><ul><li>在那些不直接支持结构化控制语句的语言里，用goto去模拟那些控制结构。在做这些的时候，应该准确地模拟，不要滥用goto所带来的灵活性</li><li>如果语言内置了等价的控制结构，那么就不要用goto</li><li>如果是为提高代码效率而使用goto，请衡量此举实际带来的性能提升</li><li>除非你要模拟结构化语句，否则尽量在每个子程序内只使用一个goto标号</li><li>除非你要模拟结构化语句，否则尽量让goto向前跳转而不要向后跳转</li><li>确认所布的goto标号都被用到了。没用到的goto标号表明缺少了代码，即缺少了跳向该标号的代码。如果某些标号没有用，那么就删掉它们</li><li>确认goto不会产生某些执行不到的代码</li><li>如果你是一位经理，那么就应该持这样的观点：对某一个goto用法所展开的争论并不是事关全局的。如果程序员知道存在替换方案，并且也愿意为使用goto辩解，那么用goto也无妨</li></ul><p>参考文献：电子工业出版社《代码大全（第2版）》第14-17章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（五）——各种数据类型的使用原则</title>
      <link href="/tech/complex/software/software-construction-5/"/>
      <url>/tech/complex/software/software-construction-5/</url>
      
        <content type="html"><![CDATA[<p>几乎所有的常见编程语言，都包含了整数、浮点数、字符串、布尔等等数据类型，而通过基本的数据类型又可以复合出各种数据结构。本文总结了常用的数据类型（整数、浮点数、字符、字符串、布尔、枚举、数组等等）以及一些不常见的数据类型（结构体、指针等等）的使用原则。最后总结了关于全局数据的一些风险和使用原则。</p><a id="more"></a><h1 id="1-常用的数据类型使用原则"><a href="#1-常用的数据类型使用原则" class="headerlink" title="1. 常用的数据类型使用原则"></a>1. 常用的数据类型使用原则</h1><h2 id="1-1-使用数值的原则"><a href="#1-1-使用数值的原则" class="headerlink" title="1.1 使用数值的原则"></a>1.1 使用数值的原则</h2><ul><li>普遍原则<ul><li>避免使用“神秘数值”，即硬编码数字：这是为了使修改变得可靠容易，并更有可读性</li><li>如果需要，可以使用硬编码的0和1：通常用于增减量或循环的第一个元素</li><li>预防除零错误</li><li>使类型转换变得明显：不要依赖隐式类型转换</li><li>避免混合类型的比较：同样不要依赖隐式类型转换，确保比较的两个数是同种类型的</li><li>注意编译器的警告</li></ul></li><li>整数<ul><li>检查整数除法：小心<strong>整数除</strong>和现实除法的差异</li><li>检查整数溢出和中间结果溢出</li></ul></li><li>浮点数<ul><li>避免数量级相差巨大的数之间的加减运算：由于精度问题，对于32位浮点数，小心1000000.00 + 0.1得到的结果和期望不同。如果要把一系列差异巨大的数相加，解决方法是先排序，再从最小值开始加起，这样可以把影响减少到最低限度</li><li>避免直接进行等量比较：应自己编写equals函数判断两者之差是否小于某阈值</li><li>处理舍入误差问题：考虑换用更高精度的类型，或者把浮点数放大n倍用整型类型做计算</li><li>使用语言和函数库对特定数据类型的支持</li></ul></li></ul><h2 id="1-2-字符和字符串"><a href="#1-2-字符和字符串" class="headerlink" title="1.2 字符和字符串"></a>1.2 字符和字符串</h2><ul><li>避免使用神秘字符和字符串：除了数值所提到的理由之外，还有这些理由：分离字符串到字符串资源文件更容易实现i18n，字符串字面量会占用较多的存储空间</li><li>了解你的语言和开发环境是如何支持Unicode的</li><li>在程序生命期中尽早决定国际化/本地化策略</li><li>如果你知道只需要支持一种文字的语言，考虑使用ISO8859字符集，否则使用Unicode</li><li>采用某种一致的字符串类型转换策略</li><li>针对C语言字符串的建议：<ul><li>注意字符串指针和字符数组之间的差异：警惕任何包含字符串和等号的表达式；通过命名规则区分变量是字符数组还是字符串指针</li><li>把C-style字符串的长度声明为<code>STRING_LENGTH + 1</code>：统一约定这条规则，有助于减少脑力消耗以及编程失误</li><li>用null初始化字符串以避免没有终端的字符串</li><li>如果内存不是限制性的因素，就用字符数组取代C中的指针</li><li>用strncpy()取代strcpy()以避免无终端的字符串</li></ul></li></ul><h2 id="1-3-布尔变量"><a href="#1-3-布尔变量" class="headerlink" title="1.3 布尔变量"></a>1.3 布尔变量</h2><p><strong>用布尔变量对程序加以文档说明，并用来简化复杂的判断。</strong>通过下面的例子来了解布尔变量的正确用法：</p><pre><code>// 目的不明确的布尔判断，咋一看根本不知道要判断什么if ( (elementindex &lt; 0 ) || (MAX_ELEMENTS &lt; elementIndex) || (elementIndex == lastElementIndex) ) { ... }// 目的明确的布尔判断bool finished = (elementindex &lt; 0 ) || (MAX_ELEMENTS &lt; elementIndex);bool repeatedEntry = (elementIndex == lastElementIndex);if (finished || repeatedEntry) { ... }</code></pre><h2 id="1-4-枚举类型"><a href="#1-4-枚举类型" class="headerlink" title="1.4 枚举类型"></a>1.4 枚举类型</h2><ul><li>用枚举类型来提高可读性和可靠性：如果仅使用具名常量，编译器无法知道是否使用了非法的数值</li><li>将枚举类型作为布尔变量的替换方案：有时布尔变量无法充分表达它所需要表达的含义（比如出错信息），那么用枚举</li><li>定义出枚举的第一项和最后一项，以使用于循环边界，把枚举类型的第一个元素留做非法值：如<code>enum Country {InvalidFirst = 0, First = 1, China = 1, England = 2, Usa = 3, Last = 4}</code>，但是这样做也可能造成混乱，一定要<strong>明确定义项目代码编写标准，并在使用时保持一致，否则就不要用</strong></li><li>警惕给枚举元素明确赋值而带来的失误：当定义0，1，2，4，8这样的枚举值时，不要去遍历</li></ul><h2 id="1-5-数组"><a href="#1-5-数组" class="headerlink" title="1.5 数组"></a>1.5 数组</h2><ul><li>确认所有的数组下标都没有超出数组的边界</li><li>考虑用合适的容器（栈、队列、集合、列表等等）来取代数组</li><li>检查数组的边界点</li><li>如果数组是多维的，确认下标的<strong>使用顺序</strong>是正确的：如很容易把<code>array[i][j]</code>搞混成<code>array[j][i]</code></li><li>提防下标串话：如把<code>array[i]</code>写成<code>array[j]</code>，和上一条一样，如果使用比i和j更有意义的下标名，这种错误就很难发生</li></ul><h1 id="2-不常见的数据类型"><a href="#2-不常见的数据类型" class="headerlink" title="2. 不常见的数据类型"></a>2. 不常见的数据类型</h1><h2 id="2-1-结构体"><a href="#2-1-结构体" class="headerlink" title="2.1 结构体"></a>2.1 结构体</h2><p>在Java和C++里面，类有时表现得也像结构体一样（当类完全由公用的数据成员组成，而不包含公用子程序的时候）。通常情况下，你会希望创建类而非结构体，下面列出了一些使用结构体的理由：</p><ul><li>用结构体来明确数据关系</li><li>用结构体简化对数据块的操作</li><li>用结构体来简化参数列表</li><li>用结构体来减少维护</li></ul><h2 id="2-2-指针"><a href="#2-2-指针" class="headerlink" title="2.2 指针"></a>2.2 指针</h2><p>指针的使用是现代编程中最容易出错的领域之一，即便你的语言不要求你使用指针，很好地理解指针也会有助于你理解你的编程语言是如何工作的。从概念上看，每一个指针都包含两个部分：内存中的某处位置（实质是一个整数值，常用16进制表示），以及如何解释指针所指的内容（由指针的基类型决定）。</p><p>通常，指针错误都产生于指针指向了它不应该指向的位置。因此，更正指针错误的大部分工作量便是找出它的位置。正确地使用指针要求程序员采用一种双向策略，首先要避免造成指针错误，其次在编写代码之后尽快地检测出指针错误来。下面说明如何实现这些目标。</p><ul><li>把指针操作限制在子程序或者类里面</li><li>同时声明和定义指针</li><li>在与指针分配相同的作用域中删除指针</li><li>在使用指针之前确保指针所指向的内存位置是合理的</li><li>先检查指针所引用的变量内容再使用它</li><li>用标记字段来检测损毁的内存：分配内存时多分配4个字节，将前4个字节设为标记字段，返回这4个字节后的内存的指针，到了需要删除该指针的时候，检查这个标记，如果标记的值是正确的，就把它设为NULL，最后删除该指针</li><li>增加明显的冗余：将某些特定字段重复两次，以此替代标记字段的方案，但是这样会带来很高的成本</li><li>用额外的指针变量来提高代码清晰度：如不要写绕口的诸如<code>pointer-&gt;next-&gt;last-&gt;next</code></li><li>画一个图理清指针之间的结构关系</li><li>按照正确的顺序删除链表中的指针</li><li>分配一片保留的内存后备区域：如果使用动态内存，最好预先分配一片内存后备，防止程序忽然用尽内存</li><li>在删除或者释放指针之后把它们设为空值</li><li>在删除变量之前检查非法指针</li><li>跟踪指针分配情况：维护一份你已经分配的指针的列表</li><li>编写覆盖子程序，集中实现避免指针问题的策略：如编写<code>SAFE_NEW</code>和<code>SAFE_DELETE</code>宏来统一包装指针的操作</li><li>采用非指针的技术</li></ul><p>还有一些特定的针对C++和C语言的指针使用技巧，此处不赘述。</p><h1 id="3-全局数据"><a href="#3-全局数据" class="headerlink" title="3. 全局数据"></a>3. 全局数据</h1><p>全局数据可以在程序中任意一个位置访问，这一概念有时被延伸到作用域比局部变量更广的变量，例如可以在一个包或一个命名空间内任意位置访问。一般来说，使用全局数据的风险比使用局部数据大，只有在万不得已时才使用，如果要用也应该遵循一些使用原则来降低风险。</p><h2 id="3-1-使用全局数据的风险"><a href="#3-1-使用全局数据的风险" class="headerlink" title="3.1 使用全局数据的风险"></a>3.1 使用全局数据的风险</h2><ul><li>无意间修改了全局数据</li><li>与全局数据有关的别名问题：当一个全局变量被传递给一个子程序，然后该子程序将它既用作全局变量又用作参数使用的情况下会出现这种问题</li><li>多线程下风险很大</li><li>全局数据阻碍代码重用</li><li>与全局数据有关的非确定的初始化顺序事直</li><li><strong>全局数据破坏了模块化和智力上的可管理性</strong></li></ul><h2 id="3-2-全局数据的使用原则"><a href="#3-2-全局数据的使用原则" class="headerlink" title="3.2 全局数据的使用原则"></a>3.2 全局数据的使用原则</h2><ul><li>创建一种命名规则来突出全局变量：例如使用g_前缀</li><li>为全部的全局变量创建一份注释良好的清单</li><li>不要用全局变量来存放中间结果</li><li>不要把所有的数据都放在一个大对象中并到处传递，以说明你没有使用全局变量：这纯粹是一种负担，如果要用全局数据，就大胆公开地用</li></ul><p>参考文献：电子工业出版社《代码大全（第2版）》第12、13章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（四）——变量的使用原则</title>
      <link href="/tech/complex/software/software-construction-4/"/>
      <url>/tech/complex/software/software-construction-4/</url>
      
        <content type="html"><![CDATA[<p>变量的好与坏就在很大程度上取决于它的命名的好坏，在给变量命名的时候需要小心谨慎。本文首先详细讲述构建活动中的基本组成成分，即变量的使用原则，接着再讲述适用于为变量——对象和基本数据——命名的原则。这些原则也适用于类、包、文件及其他的编程实体。</p><a id="more"></a><h1 id="1-使用变量的原则"><a href="#1-使用变量的原则" class="headerlink" title="1. 使用变量的原则"></a>1. 使用变量的原则</h1><h2 id="1-1-变量初始化原则"><a href="#1-1-变量初始化原则" class="headerlink" title="1.1 变量初始化原则"></a>1.1 变量初始化原则</h2><p>不恰当的变量初始化所导致的一系列问题都源于变量的默认初始值与你的预期不同，下面给出一些避免产生初始化错误的建议。</p><ul><li>在声明变量的时候初始化</li><li>在靠近变量第一次使用的位置初始化它</li><li>理想情况下， 在靠近第一次使用变量的位置声明和定义该变量</li><li>在可能的情况下使用final或者const关键字</li><li>注意计数器和累加器，在下次使用前要重置</li><li>在类的构造函数里初始化该类的数据成员</li><li>利用编译器的警告信息检查是否使用了未经初始化的变量</li><li>在程序开始时初始化工作内</li></ul><h2 id="1-2-变量的作用域"><a href="#1-2-变量的作用域" class="headerlink" title="1.2 变量的作用域"></a>1.2 变量的作用域</h2><p>关于变量引用局部化的指标：</p><ul><li>跨度：衡量一个变量的不同引用点的靠近程度，具体数字为对变量前后引用之间的代码行数</li><li>存活时间：一个变量存在期间（被引用的第一条语句至结束引用它的最后一条语句）所跨越的语句总数</li></ul><p>尽可能缩短变量的跨度和存活时间，可以减少初始化错误的可能，让自己对的代码有更准确的认识，使代码更具可读性。像全局变量的跨度和存活时间都很长，应尽量避免使用。下面是一些减小作用域的一般原则：</p><ul><li>在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量</li><li>直到变量即将被使用时再为其赋值</li><li>把相关语句放到一起</li><li>把相关语句组提取成单独的子程序</li><li>开始时采用最严格的可见性，然后根据需要扩展变量的作用</li></ul><h2 id="1-3-变量的使用原则"><a href="#1-3-变量的使用原则" class="headerlink" title="1.3 变量的使用原则"></a>1.3 变量的使用原则</h2><ul><li>每个变量只用于单一用途：不要将临时变量如temp用于两种用途</li><li>避免让变量具有隐含含义，以下做法都是<strong>不可取</strong>的<ul><li>pageCount表示已打印纸张的数量，如果是-1表示有错误发生</li><li>bytesWritten表示写入输出文件的字节数，如果取值为负，表示用于输出的磁盘驱动器的号码</li></ul></li><li>确保使用了所有己声明的变量</li></ul><p>关于变量的绑定时间，通常来说越晚绑定会有更多的灵活性，但复杂度也会越低。看看下面演示的例子，应酌情选择变量绑定时间：</p><pre><code>// 编写代码时绑定：硬编码（使用“神秘数字”）很糟糕，一旦要修改颜色则代码其他地方很难保持一致titleBar.color = 0xFF;// 编译时绑定：用具名常量可以增加可读性，还能只修改一处就对所有位置生效private static final int COLOR_BLUE = 0xFF;private static final int TITLE_BAR_COLOR = COLOR_BLUE;titleBar.color = TITLE_BAR_COLOR;// 运行时绑定：程序运行期间读取，可能从配置文件读取，也可能从注册表读取，这是相对最灵活的方式titleBar.color = ReadTitleBarColor();// 此外还有对象实例化时绑定（如每次窗体创建时读取数据），甚至即时绑定（如每次窗体重绘时读取数据）</code></pre><h1 id="2-变量的命名规范"><a href="#2-变量的命名规范" class="headerlink" title="2. 变量的命名规范"></a>2. 变量的命名规范</h1><h2 id="2-1-选择好变量名的注意事项"><a href="#2-1-选择好变量名的注意事项" class="headerlink" title="2.1 选择好变量名的注意事项"></a>2.1 选择好变量名的注意事项</h2><ul><li>名字要完全、准确地描述出该变量所代表的事物，<strong>这是最重要的命名注意事项</strong></li><li>以问题为导向：好记的名字反映的通常都是问题，而不是解决方案，例如表示打印机准备状态，printerReady就比bitFlag要更准确描述问题</li><li>最适当的名字长度：建议平均8-20个字符，举个例子numberOfPeopleOnTheUsOlympicTeam太长，ntm太短，numTeamMembers正好</li><li>较长的名字适用于很少用到的变量，较短的名字适用于局部变量或循环变量</li><li>对位于全局命名空间中的名字加以限定词：用namespace、1g_前缀等等</li><li><strong>把限定词放到最后，为变量赋予主要含义的部分应位于最前面</strong>：例如revenueTotal要优于totalRevenue。这条规则非常适用于项目内约束以提高一致性<ul><li>常用的限定词：Total、Sum、Average、Max、Min、Record、Pointer等等</li><li>Num限定词是个例外，通常customerNum表示下表，而numCustomers表示员工总数。但最好的办法是避免用Num，而改用Count或Total来表示总数，用Index表示下标</li></ul></li></ul><p>下表给出一些名字好坏的对比：</p><table><thead><tr><th>变量用途</th><th>描述清晰的好名字</th><th>描述不到位的坏名字</th></tr></thead><tbody><tr><td>支票累计额</td><td>runningTotal, checkTotal</td><td>written, ct, checks, CHKTTL</td></tr><tr><td>列车的运行速度</td><td>trainVelocity, velocityInMph</td><td>velt, v tv, train</td></tr><tr><td>当前日期</td><td>currentDate, todaysDate</td><td>cd, current, c, date</td></tr><tr><td>每页的行数</td><td>linesPerPage</td><td>lpp, lines, l, x, x1, x2</td></tr></tbody></table><h2 id="2-2-为特定类型的数据命名"><a href="#2-2-为特定类型的数据命名" class="headerlink" title="2.2 为特定类型的数据命名"></a>2.2 为特定类型的数据命名</h2><ul><li>循环下标：i、j、k作为下标是约定俗称的。若循环较长会有多层嵌套，最好用xxxIndex的描述性名字做下标</li><li>状态变量：取一个比xxxFlag更好的名字，例如reportType要比statusFlag要更清晰。也建议状态变量采用具名常量或枚举类型来表达</li><li>临时变量：取一个比temp更具描述性的名字</li><li>布尔变量：done表示某件事是否完成，error表示是否发生错误，found表示是否找到，success表示是否成功。布尔变量的名字要明确反映true或false。此外，要使用<strong>肯定</strong>的名字，不要取notFound、notSuccessful之类的</li><li>常量：根据常量所表示的含义取名，而不是为其数值取名</li></ul><h2 id="2-3-应该避免的名字"><a href="#2-3-应该避免的名字" class="headerlink" title="2.3 应该避免的名字"></a>2.3 应该避免的名字</h2><ul><li>避免使用令人误解的名字或缩写</li><li>避免使用具有相似含义的名字：如input和inputValue，recordNum和numRecords等等</li><li>避免使用具有不同含义却又相似名字的变量：如clientRecs和clientReps</li><li>避免使用发音相近的名字：如wrap和rap</li><li>避免在名字中使用数字</li><li>避免在名字中拼错单词</li><li>避免使用英语中常常拼错的单词</li><li>不要仅靠大小写来区分变量</li><li>不要使用与变量含义完全无关的名字</li><li>避免在名字中包含易混淆的字符</li></ul><h1 id="3-制定命名规范"><a href="#3-制定命名规范" class="headerlink" title="3. 制定命名规范"></a>3. 制定命名规范</h1><p>命名规则在各种编程语言，乃至各个公司都是不同的，但也有一些比较通用的规范可以注意。限于篇幅本文不阐述变量的命名的规范，下面只提一下为何要制定命名规范：</p><ul><li>当多个程序员合作开发一个项目时</li><li>当你计划把一个程序转交给另一位程序员来修改和维护的时候（这几乎总是会发生）</li><li>当你所在组织中的其他程序员评估你写的程序的时候</li><li>当你写的程序规模太大，以致于你无法在脑海里同时了解事情的全貌，而必须分而治之的时候</li><li>当你写的程序生命期足够长，长到你可能会在把它搁置几个星期或几个月之后又重新启动有关该程序的工作时</li><li>当在一个项目中存在一些不常见的术语，并且你希望在编写代码阶段使用标准的术语或者缩写的时候</li></ul><p>不同规范所要求的正式程度也有所不同。通常，一个项目所需的规范正式程度取决于为项目组的人员数量，程序的规模，以及程序预期的生命周期。对于微小的、用完即弃的项目而言，实施严格的规则可能就没什么必要。但对于多人协作的大型项目而言，无论是在开始阶段还是贯穿整个程序的生命周期，正式规范都是成为提高可读性的必不可少的辅助手段。</p><p>参考文献：电子工业出版社《代码大全（第2版）》第10、11章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（三）——高质量的类和子程序</title>
      <link href="/tech/complex/software/software-construction-3/"/>
      <url>/tech/complex/software/software-construction-3/</url>
      
        <content type="html"><![CDATA[<p>在计算时代的早期，程序员基于语句思考编程问题。到了20世纪七八十年代，程序员开始基于子程序去思考编程。进入21世纪，程序员以类为基础思考编程问题。类是由一组数据和子程序构成的集合，这些数据和子程序共同拥有一组内聚的、明确定义的职责。由此可见类和子程序在现代编程中的地位。本文将就如何创建高质量的类和子程序提供一些建议。</p><a id="more"></a><h1 id="1-高质量的类"><a href="#1-高质量的类" class="headerlink" title="1. 高质量的类"></a>1. 高质量的类</h1><h2 id="1-1-类的基础：抽象数据类型（ADT）"><a href="#1-1-类的基础：抽象数据类型（ADT）" class="headerlink" title="1.1 类的基础：抽象数据类型（ADT）"></a>1.1 类的基础：抽象数据类型（ADT）</h2><p>要想理解面向对象编程，首先要理解ADT（Abstract Data Type）。ADT是指一些数据以及对这些数据所进行的操作的集合。这些操作既向程序的其余部分描述了这些数据是怎么样的，也允许程序的其余部分改变这些数据。抽象数据类型可以让你像在现实世界中一样操作实体，而不必纠结在低层如何实现上。</p><h3 id="1-1-1-使用ADT的好处"><a href="#1-1-1-使用ADT的好处" class="headerlink" title="1.1.1 使用ADT的好处"></a>1.1.1 使用ADT的好处</h3><ul><li>可以隐藏实现细节</li><li>改动不会影响到整个程序</li><li>让接口能提供更多信息</li><li>更容易提高性能</li><li>程序更具自我说明性</li><li>无须在程序内到处传递数据</li><li>可以像在现实世界中那样操作实体，而不用在底层实现上操作它</li></ul><h3 id="1-1-2-使用ADT的指导建议"><a href="#1-1-2-使用ADT的指导建议" class="headerlink" title="1.1.2 使用ADT的指导建议"></a>1.1.2 使用ADT的指导建议</h3><ul><li>把常见的底层数据类型创建为ADT并使用这些ADT，而不再使用底层数据类型（要尽可能选择最高的抽象层次）</li><li>把像文件这样的常用对象当成ADT</li><li>简单的事物也可当做ADT（如灯的“开”“关”操作可以放到单独的方法）</li><li>不要让ADT依赖于其存储介质</li></ul><h2 id="1-2-良好的类接口"><a href="#1-2-良好的类接口" class="headerlink" title="1.2 良好的类接口"></a>1.2 良好的类接口</h2><p>上一节所讲的ADT构成了类的基础，类可以看成是抽象数据类型再加上继承和多态两个概念。创建高质量的类最重要的一步是创建一个好的接口，包括通过接口来展现良好的抽象，并确保细节被很好地封装在类中。封装是一个比抽象更强的概念：抽象通过提供一个可以让你忽略实现细节的模型来管理复杂度，而封装则强制阻止你看到细节。一般来说，抽象和封装要么两者皆有，要么两者皆无。</p><h3 id="1-2-1-良好的抽象"><a href="#1-2-1-良好的抽象" class="headerlink" title="1.2.1 良好的抽象"></a>1.2.1 良好的抽象</h3><ul><li>类的接口应该展现一致的抽象层次：每一个类应该<strong>只实现一个ADT</strong></li><li>一定要理解类所实现的抽象是什么</li><li>提供成对的服务：例如开和关，添加和删除，但一定要考虑是否真的需要，不要盲目创建相反的操作</li><li>把不相关的信息转移到其他类</li><li>尽可能让接口可编程，而不是表达语义：可编程的部分能被编译器检查，但语义部分是由“本接口将会被怎样使用”的假定组成（比如“ RoutineA必须在RoutineB之前被调用”或“如果dataMember未经初始化就传给RoutineA的话，将会导致RoutineA崩溃”）</li><li>谨防在修改时破坏接口的抽象：在对类进行修改和扩展时要特别注意</li><li>不要添加与接口抽象不一致的公用成员</li><li>同时考虑抽象性和内聚性</li></ul><h3 id="1-2-2-良好的封装"><a href="#1-2-2-良好的封装" class="headerlink" title="1.2.2 良好的封装"></a>1.2.2 良好的封装</h3><ul><li>尽可能地限制类和成员的可访问性</li><li>不要公开暴露成员数据：使用get、set访问器来访问</li><li><em>避免把私用的实现细节放入类的接口中</em>（特指C++）：应尽量避免在类的头文件中查看private的内容。《Efective C++》第2版第34条建议，把类的接口与类的实现隔离开，并在类的声明中包含一个指针，让该指针指向类的实现，但不能包含任何其他实现细节。</li><li><em>避免使用友元类</em>（特指C++）</li><li>不要因为一个子程序里仅使用公用子程序，就把它归入公开接口</li><li>不要对类的使用者做出任何假设，要格外警惕从语义上破坏封装：<strong>每当你发现自己是通过查看类的内部实现来得知该如何使用这个类的时候，你就不是在针对接口编程了，而是在透过接口针对内部实现编程了</strong></li></ul><h2 id="1-3-有关设计和实现类的问题"><a href="#1-3-有关设计和实现类的问题" class="headerlink" title="1.3 有关设计和实现类的问题"></a>1.3 有关设计和实现类的问题</h2><p>通常类和类之间的关系，有“包含”和“继承”两种。继承需要更多的技巧，而且更容易出错，包含才是面向对象编程中的主力技术。以下是一些关于包含和继承技术的参考原则：</p><ul><li>警惕包含超过约7个数据成员的类</li><li>要么使用继承并进行详细说明，要么就不要用它：如果某个类并未设计为可被继承，要明确声明不可被继承</li><li>遵循<a href="http://baike.baidu.com/view/1688346.htm" target="_blank" rel="noopener">里氏替换原则</a></li><li>确保只继承需要继承的部分：注意父类方法的<strong>默认实现</strong>和子类方法的<strong>覆盖（override）性</strong></li><li>不要“覆盖”一个不可覆盖的成员函数：换种说法，即子类方法不要和父类的private方法同名</li><li>把共用的接口、数据及操作放到继承树中尽可能高的位置</li><li>只有一个实例的类是值得怀疑的：可以考虑用单例模式</li><li>只有一个派生类的基类也值得怀疑：不要“提前设计”任何非绝对必要的继承结构</li><li>派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀：这表明基类的设计有错误</li><li>避免让继承体系过深</li><li>尽量使用多态，避免大量的类型检查：警惕频繁重复出现的switch case语句</li><li>避免创建万能类/避免用动词命名的类/消除无关紧要的类</li></ul><p>关于类的数据和方法（包括构造函数）的参考原则：</p><ul><li>让类中子程序的数量尽可能少</li><li>禁止隐式地产生你不需要的成员函数和运算符</li><li>减少类所使用的不同子程序的数量</li><li>对其他类的子程序的间接调用要尽可能少</li><li>如果可能，应该在所有的构造函数中初始化所有的数据成员</li><li>用private构造函数来强制实现单例属性</li><li>优先采用深拷贝，除非论证可行才使用浅拷贝</li></ul><p><strong><a href="http://www.kancloud.cn/raytaylorlin/code-complete-checklist/135274" target="_blank" rel="noopener">核对表：类的质量</a></strong></p><h1 id="2-高质量的子程序"><a href="#2-高质量的子程序" class="headerlink" title="2. 高质量的子程序"></a>2. 高质量的子程序</h1><h2 id="2-1-创建子程序的理由"><a href="#2-1-创建子程序的理由" class="headerlink" title="2.1 创建子程序的理由"></a>2.1 创建子程序的理由</h2><p>创建子程序的理由包括但不限于：降低复杂度，引入中间的、易懂的抽象，避免代码重复，支持子类化，隐藏顺序，隐藏指针操作，提高可移植性，简化复杂的逻辑判断，改善性能。同样很多创建类的理由也是创建子程序的理由。</p><p>注意一些过于简单的看上去似乎没必要写成子程序的操作，写一个只有两三行代码的子程序看起来有些大才小用，经常会成为心理障碍。但实际上小的子程序有许多优点，可以看看以下这个例子。</p><pre><code>/* 不使用子程序：经常可以看到以下代码出现在十几处地方 */// 从设备单位（device unit）到磅数（point）的转换计算points = deviceUnits * （POINTS_PER_INCH / DeviceUnitsPerInch());/* 使用子程序：不仅更具可读性（甚至达到自我注解的程度），可以更易于维护和测试 */int DeviceUnitsToPoints(int deviceUnits) {    if (DeviceUnitsPerInch() != 0)        return deviceUnits * （POINTS_PER_INCH / DeviceUnitsPerInch();    else        return 0;}points = DeviceUnitsToPoints(deviceUnits);</code></pre><h2 id="2-2-好的子程序名字"><a href="#2-2-好的子程序名字" class="headerlink" title="2.2 好的子程序名字"></a>2.2 好的子程序名字</h2><p>一个子程序由名字、参数列表和程序体组成。一个好的名字能清晰地描述子程序所做的一切，是一个好的子程序的起点。子程序命名应该遵循如下原则：</p><ul><li>描述子程序所做的<strong>所有</strong>事情</li><li>避免使用无意义的、模糊或表述不清的动词：像<code>Handle</code>、<code>Perform</code>、<code>Process</code>等等动词都没有精确地描述操作，例如把<code>HandleOutput()</code>改为<code>FormatAndPrintOutput()</code>就能更容易看清楚子程序的功能。</li><li>不要仅通过数字来形成不同的子程序各字：不要出现像<code>OutputUser1</code>、<code>OutputUser2</code>子程序然后将它们组成一个大程序的情况。</li><li>根据需要确定子程序名字的长度：变量名的最佳长度是9到15个字符，而子程序要更复杂些，长短要视该名字是否清晰易懂而定。</li><li>给函数命名时要对返回值有所描述：<code>customerid.Next()</code>、<code>printer.IsReady()</code>、<code>pen.CurrentColor()</code>等都是不错的例子。</li><li>给过程起名时使用语气强烈的动词加宾语的形式：如<code>PrintDocument()</code>、<code>CheckOrderInfo()</code>。对于面向对象语言是特例，因为对象（宾语）本身已经包含在调用语句中了，如<code>document.Print()</code>。</li><li>为常用操作确立命名规则：在实际项目中，约定一套语义命名规则。避免出现不同人写出像<code>employee.id.Get()</code>，<code>employee.GetId()</code>，<code>employee.id()</code>这样难以记住的细节。</li><li>准确使用对仗词：有助于保持一致性和可读性<ul><li><code>add/remove</code>，<code>open/close</code>，<code>begin/end</code>，<code>insert/delete</code>，<code>show/hide</code>，<code>create/destroy</code>，<code>source/target</code>，<code>first/last</code>，<code>min/max</code>，<code>start/stop</code>，<code>get/set</code>，<code>next/previous</code></li></ul></li></ul><h2 id="2-3-写好子程序的参数"><a href="#2-3-写好子程序的参数" class="headerlink" title="2.3 写好子程序的参数"></a>2.3 写好子程序的参数</h2><ul><li>按照输入-修改-输出的顺序排列参数：不要随机地或按字母顺序排列参数</li><li><em>考虑自己创建IN和OUT关键字</em>（特指C++）：定义无值的宏扩展C++语言，在项目中要极其谨慎</li><li>如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致：如C语言中的<code>fprintf()/printf()</code>，<code>strncpy()/memcpy()</code></li><li>使用所有的参数：既然往子程序中传递了一个参数，就一定要用到这个参数。<em>使用条件编译而忽略了某一些参数的情况除外。</em></li><li>把状态或出错变量放在最后</li><li>不要把子程序的参数用做工作变量：<strong>不要修改任何输入参数</strong>，应明确引入一些中间的工作变量</li><li>在接口中对参数的假定加以说明：用注释甚至断言，说明参数的单位、状态或错误值的含义、数值的范围、不该出现的特定数值等等</li><li>把子程序的参数个数限制在大约7个以内：若传参过多，说明子程序之间的耦合过紧，应重新设计子程序</li><li>考虑对参数采用某种表示输入、修改、输出的命名规则：如i_、m_、Output_等前缀</li><li>为子程序传递用以维持其接口抽象的变量或对象：考虑传入的是若干底层数据，还是一个包装对象</li><li>确保实际参数与形式参数的类型相匹配：注意传入参数时可能发生的隐式类型转换</li></ul><h2 id="2-4-子程序的内容"><a href="#2-4-子程序的内容" class="headerlink" title="2.4 子程序的内容"></a>2.4 子程序的内容</h2><p>关于子程序的长度没有定论。与其对子程序的长度强加限制，还不如让下面这些因素——如子程序的内聚性、嵌套的层次、变量的数量、决策点的数量、解释子程序用意所需的注释数量以及其他些跟复杂度相关的考虑事项等——来决定子程度的长度。但是，这里要引用一下《代码整洁之道》3.1节“短小”中的内容来辅助参考子程序应该达到的长度。我个人总结，决定子程序的长短的唯一标准，是<strong>一个函数只做一件事</strong>。</p><blockquote><p>……经过漫长的试错，经验告诉我，函数就该小……函数也不该有100行那么长，20行封顶最佳……每个函数都一目了然。每个函数都只说一件事。而且，每个函数都依序把你带到下一个函数。这就是函数应该达到的短小程度！……通常来说，应该短于代码清单3-2中的函数（该函数有10行）……</p></blockquote><p>在子程序的设计上，应该注重其内聚性，即子程序中各种操作之间联系的紧密程度。我们的目标是让<strong>每个子程序只把一件事做好，不再做任何其他事情</strong>。理解下面几个关于内聚性层次的概念有助于思考如何让子程序尽可能地内聚。</p><ul><li>最好的内聚<ul><li>功能的内聚性：如<code>GetCustomerName()</code>、<code>EraseFile()</code>，前提是子程序所执行的操作与其名字相符。</li></ul></li><li>不够理想的内聚<ul><li>顺序上的内聚性：子程序内包含有需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有在全部执行完毕后才完成了一项完整的功能。</li><li>通信上的内聚性：一个子程序中的不同操作使用了同样的数据，但不存在其他任何联系。</li><li>临时的内聚性：含有一些因为需要同时执行才放到一起的操作的子程序，如<code>Startup()</code>中塞进一堆互不相关的初始化代码，应该把临时性的子程序看做是一系列事件的组织者，并去调用其他子程序。</li></ul></li><li>不可取的内聚<ul><li>过程上的内聚性：一个子程序中的操作是按特定的顺序进行的。</li><li>逻辑上的内聚性：若干操作被放入同一个子程序中，通过传入的控制标志（由if/else或switch/case控制）选择执行其中的一项操作。这种情况下子程序唯一的功能应该是发布各种命令调用底层子程序，其自身并不做任何处理。</li><li>巧合的内聚性：指子程序中的各个操作之间没有任何可以看到的关联。</li></ul></li></ul><p><strong><a href="http://www.kancloud.cn/raytaylorlin/code-complete-checklist/135273" target="_blank" rel="noopener">核对表：高质量的子程序</a></strong></p><p>参考文献：电子工业出版社《代码大全（第2版）》第6、7章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（二）——架构与设计</title>
      <link href="/tech/complex/software/software-construction-2/"/>
      <url>/tech/complex/software/software-construction-2/</url>
      
        <content type="html"><![CDATA[<p>软件架构（software architecture）是软件设计的高层部分，是用于支撑更细节的设计的框架。本文关注的并不是如何开发一个软件的架构，而是设计一个架构时应该关注的部分。此外，设计就是把需求分析和编码调试连在一起的活动，好的高层设计能提供一个可以稳妥容纳多个较低层次设计的结构，其对于小型项目非常有用，对大型项目更是不可或缺。因此，本文将总结软件构建中设计的基础概念及基本方法。</p><a id="more"></a><h1 id="1-软件构建的主要活动"><a href="#1-软件构建的主要活动" class="headerlink" title="1. 软件构建的主要活动"></a>1. 软件构建的主要活动</h1><h2 id="1-1-软件架构的概念"><a href="#1-1-软件架构的概念" class="headerlink" title="1.1 软件架构的概念"></a>1.1 软件架构的概念</h2><p>一个经过慎重考虑的架构为“从顶层到底层维护系统的概念完整性”提供了必备的结构和体系，它为程序员提供了指引，将工作分为几个部分，使多个开发者可以独立工作。好的架构使得构建活动变得更容易。糟糕的架构则使构建活动几乎寸步难行。在构建期间或者更晚的时候进行架构变更，代价也是高昂的。</p><h2 id="1-2-架构的典型组成部分"><a href="#1-2-架构的典型组成部分" class="headerlink" title="1.2 架构的典型组成部分"></a>1.2 架构的典型组成部分</h2><ul><li>程序组织：定义程序的主要构造块（子系统或模块），它们的责任以及它们之间的通信规则</li><li>主要的类：指出每个主要的类的责任，以及该类如何与其他类交互（继承体系、状态转换、对象持久化等）</li><li>数据设计：描述所用到的主要数据文件和数据表的设计</li><li>业务规则：描述某些特殊的业务规则对系统设计的影响</li><li>用户界面设计：架构应模块化，以便替换UI部分</li><li>资源管理：描述管理稀缺资源（数据库连接、线程、内存等）的计划</li><li>安全性：描述实现设计层面和代码层面的安全性的方法，并建立威胁模型</li><li>性能：如果需要关注性能，就应该在需求中详细定义性能目标</li><li>可伸缩性：描述系统如何应对未来需求的增长（如用户数量、服务器数量、网络节点数量等等）</li><li>国际化/本地化：考虑典型的字符串和字符集问题</li><li>输入/输出：定义数据的读取和写入策略</li><li>错误处理：确定一种“一致处理错误”的策略（纠正还是检测错误？主动还是被动检测错误？程序如何传播错误？程序在什么层次处理错误？等等）</li><li>容错性：考虑系统在出错时，让系统转入“部分运转”状态，还是某种“功能退化”状态，甚至自动关闭或重启</li><li>架构的可行性：必须论证系统在技术上是否可实现</li><li>关于“买”还是“造”的决策：决定购买组件，使用第三方组件，还是自己造轮子</li><li>关于复用的决策：说明如何对复用的软件进行加工，使之符合其他架构目标</li><li>变更策略：考虑如何让架构足够灵活，能够适应可能出现的变化</li></ul><p><strong><a href="http://www.kancloud.cn/raytaylorlin/code-complete-checklist/133369" target="_blank" rel="noopener">核对表：架构</a></strong></p><h1 id="2-软件构建中设计的基础"><a href="#2-软件构建中设计的基础" class="headerlink" title="2. 软件构建中设计的基础"></a>2. 软件构建中设计的基础</h1><h2 id="2-1-理解设计的挑战"><a href="#2-1-理解设计的挑战" class="headerlink" title="2.1 理解设计的挑战"></a>2.1 理解设计的挑战</h2><ul><li>设计是一个险恶的问题：必须首先把这个问题“解决”一遍以便能够明确地定义它，然后再次解决该问题</li><li>设计是个了无章法的过程：设计过程中会犯很多错，并且很难判断设计何时算是“足够好”</li><li>设计就是确定取舍和调整顺序的过程</li><li>设计受到诸多限制：时间、资源、空间等等</li><li>设计是不确定的：让三个人设计同一套程序，可能会做出三套截然不同而且都不错的设计</li><li>设计是一个启发式过程：由于充满不确定性，设计是具有探索性的不是能保证产生预期结果的可重复过程</li></ul><h2 id="2-2-关键的设计概念"><a href="#2-2-关键的设计概念" class="headerlink" title="2.2 关键的设计概念"></a>2.2 关键的设计概念</h2><p><strong>软件的首要技术使命便是管理复杂度。</strong>在软件架构的层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。子系统间的相互依赖越少，就越容易在同一时间里专注问题的一小部分。精心设计的对象关系使关注点相互分离，从而使你能在每个时刻只专注于一件事情。可以用这两种方法来管理复杂度：把任何人在同一时间需要处理的本质复杂度的量减到最少；不要让偶然性的复杂度无谓地快速增长。一旦你能理解软件开发中任何其他技术目标都不如管理复杂度重要时，众多设计上的考虑就都变得直截了当了。</p><h2 id="2-3-理想的设计特征"><a href="#2-3-理想的设计特征" class="headerlink" title="2.3 理想的设计特征"></a>2.3 理想的设计特征</h2><ul><li>最小的复杂度：设计要简单且易于理解</li><li>易维护：为做维护工作的程序猿着想</li><li>松散耦合：让程序的各个组成部分之间关联最小</li><li>可扩展性：增强系统的功能而无须破坏其底层结构</li><li>可重用性：系统的组成部分能在其他系统中重复使用</li><li>高扇入：让大量的类使用某个给定的类（系统很好地利用了在较低层次上的工具类）</li><li>低扇出：让一个类里少量或适中地使用其他的类</li><li>可移植性：方便移植到其他环境中</li><li>精简性：系统没有多余的部分</li><li>层次性：保持系统各个分解层的层次性，使你能在任意的层面观察系统，并得到某种具有一致性的看法</li><li>标准技术：尽量用标准化的、常用的方法，而不是依赖许多外来的稀奇古怪的技术或组件</li></ul><h2 id="2-4-设计的层次"><a href="#2-4-设计的层次" class="headerlink" title="2.4 设计的层次"></a>2.4 设计的层次</h2><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fsoftware%2F%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%B1%82%E6%AC%A1.png" alt="一个软件系统的设计层次"></p><h1 id="3-软件构建中设计的方法"><a href="#3-软件构建中设计的方法" class="headerlink" title="3. 软件构建中设计的方法"></a>3. 软件构建中设计的方法</h1><h2 id="3-1-启发式方法"><a href="#3-1-启发式方法" class="headerlink" title="3.1 启发式方法"></a>3.1 启发式方法</h2><p>由于软件设计是非确定性的，因此灵活熟练地运用一组有效的启发式方法（试探法），便成了合理的软件设计的核心工作。下面根据管理软件复杂度的原则，给出了一些参考的启发式设计方法。</p><ul><li>找出现实世界中的对象<ul><li>辨识对象及其属性（数据）</li><li>确定可以对各个对象进行的操作（方法）</li><li>确定各个对象能对其他对象进行的操作</li><li>确定对象的哪些部分对其他对象不可见</li><li>定义每个对象的公开接口</li></ul></li><li>形成一致的抽象：注意参考2.4中层次对系统分层抽象，抽象可以让你忽略无关的细节</li><li>封装实现细节：抽象可以“让你从高层的细节来看待一个对象”，而封装则让你“不能看到对象的任何其他细节层次”</li><li>信息隐藏<ul><li>类的接口应该尽可能少地暴露其内部工作机制</li><li>隐藏复杂度，包括复杂的数据类型、文件结构、布尔判断以及晦涩的算法</li><li>隐藏变化源，当变化发生时，其影响就能被限制在局部范围内</li></ul></li><li>当继承能简化设计时就继承：继承很强大，但如果使用不当，也有极大的弊端</li><li>找出容易改变的区域<ul><li>应对变化的措施：找出看起来容易变化的部分，单独划分成类，并设计好类接口将变化隔离开来</li><li>容易变化的区域：业务规则、对硬件的依赖、输入输出、非标准的编程语言特性、困难的设计区域和构建区域、状态变量、数据量的限制等等</li></ul></li><li>保持松散耦合<ul><li>衡量模块间耦合度的参考标准：规模（模块间的连接数）、可见性（模块间连接的显著程度）、灵活性（模块间的连接是否容易改动）</li><li>耦合的种类：简单数据参数耦合（模块间传简单类型数据，<strong>正常</strong>）、简单对象耦合（一个模块实例化一个对象，<strong>正常</strong>）、对象参数耦合（模块间传对象参数，<strong>谨慎</strong>）、语义上的耦合（必须知道另一个模块内部工作细节才能使用，<strong>危险</strong>）</li></ul></li><li>查阅常用的设计模式<ul><li>通过提供现成的抽象来减少复杂度</li><li>通过把常见解决方案的细节予以制度化来减少出错</li><li>通过提供多种设计方案而带来启发性的价值</li><li>通过把设计对话提升到一个更高的层次上来简化与同事间的交流</li></ul></li><li>其他启发式方法<ul><li>高内聚性：使类所达到的目标（内聚性）尽可能高</li><li>为测试而设计：思考诸如“如果为了便于测试而设计这个系统，那么系统会是什么样子”的问题很有益处</li><li>避免失误：充分考虑系统可能的失败模式</li><li>画一个图：图可以在一个更高的抽象层次上表达问题</li><li>创建中央控制点</li><li>考虑使用蛮力突破</li></ul></li></ul><h2 id="3-2-设计实践"><a href="#3-2-设计实践" class="headerlink" title="3.2 设计实践"></a>3.2 设计实践</h2><ul><li>迭代：在备选的设计方案之中<strong>循环并且尝试一些不同的做法</strong>时，将同时从高层和低层的不同视角去审视问题。</li><li>分而治之：把程序分解为不同的关注区域，然后分别处理每一个区域。</li><li>自上而下和自下而上：前者始于抽象，逐步向底层分解；后者始于细节，向一般性延伸。两者并不冲突，可以相互协作。</li><li>建立试验性原型：写出用于<strong>回答特定设计问题的、量最少且能够随时扔掉</strong>的代码。注意不要把原型用在最终产品中。</li><li>合作设计：与同事讨论，审查，甚至共同设计</li><li>要做多少设计才够：若编码前还判断不了应该坐多深入的设计，宁可继续做更详细的设计，也不要事后才发现设计得还不够。</li><li>记录设计成果：把设计文档插入到代码里、用Wiki来记录设计讨论和决策、写总结邮件、拍照、保留设计挂图、使用CRC（类、职责、合作者）卡片、在适当的细节层创建UML图</li></ul><p><strong><a href="http://www.kancloud.cn/raytaylorlin/code-complete-checklist/134109" target="_blank" rel="noopener">核对表：软件构造中的设计</a></strong></p><p>参考文献：电子工业出版社《代码大全（第2版）》3.5节，第5章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建（一）——软件构建基础</title>
      <link href="/tech/complex/software/software-construction-1/"/>
      <url>/tech/complex/software/software-construction-1/</url>
      
        <content type="html"><![CDATA[<p>开发计算机软件是一个非常复杂的过程，而软件“构建”是指建设过程中“动手”的部分，其中不仅仅包括“写代码”，还包含了计划、设计、测试、集成等等其他工作。本文首先总结软件构建的含义以及其主要活动；接着列举了一个比较合理的隐喻——建造房子——来理解软件开发；最后阐述了软件构建的前期准备工作的重要性，阐述了定义问题和分析需求的重要性，以及应该准备哪些事情。</p><a id="more"></a><h1 id="1-软件构建的主要活动"><a href="#1-软件构建的主要活动" class="headerlink" title="1. 软件构建的主要活动"></a>1. 软件构建的主要活动</h1><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fsoftware%2F%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B4%BB%E5%8A%A8.png" alt="软件构建的主要活动（阴影覆盖的部分）"></p><p>如图所示，软件构建活动主要是编码与调试，但也涉及详细设计、规划构建、单元测试、集成、集成测试等其他活动。下面列出一些具体的构建活动中的任务：</p><ul><li>验证有关的基础工作已经完成，因此构建活动可以顺利地进行下去</li><li>确定如何测试所写的代码</li><li>设计并编写类和子程序</li><li>创建并命名变量和具名常量</li><li>选择控制结构，组织语句块</li><li>对代码进行单元测试和集成测试，并排除其中的错误</li><li>评审开发团队其他成员的底层设计和代码，并让他们评审你的工作</li><li>润饰代码，仔细进行代码的格式化和注释</li><li>将单独开发的多个软件组件集成为一体</li><li>调整代码，让它更快、更省资源</li></ul><h1 id="2-用隐喻来更充分地理解软件开发"><a href="#2-用隐喻来更充分地理解软件开发" class="headerlink" title="2. 用隐喻来更充分地理解软件开发"></a>2. 用隐喻来更充分地理解软件开发</h1><p>当向一个非程序员解释什么是软件开发的时候，最好的办法就是通过某种隐喻或类比来解释。隐喻把软件开发过程与其他你熟系的活动联系在一起，帮助你更好地理解。不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。</p><p>使用<strong>建造房子</strong>是一个很好的隐喻，此处做个引用摘录：</p><blockquote><p>首先你要决定准备建一个什么类型的房子一一在软件开发里的类似事项称为问题定义。接下来，你必须和某个建筑师探讨这一总体设计，并得到批准。这跟软件架构设计十分相似。然后你画出详细的蓝图，雇一个承包人，就像软件的详细设计。再然后，你要准备好建造地点，打好地基，搭建房屋框架，砌好边墙，盖好房顶，通好水、电、煤气等。这就如同是软件的构建一样。在房子大部分完成之后，庭院设计师、油漆匠和装修工还要来把你新盖的家以及里面的家什美化一番。这就好比软件的优化过程。在整个过程中，还会有各种监查人员来检查工地、地基、框架、布线以及其他需要检查的地方。这相当于软件复查评审。</p></blockquote><blockquote><p>建造一个房子的时候，你不会去试着建造那些能买得到的现成的东西。你会买洗衣机、烘干机、洗碗机、电冰箱以及冷藏柜……当开发软件时，你会大量使用高级语言所提供的功能，而不会自己去编写操作系统层次的代码。你可能还要用些现成的程序库，比如说一些容器类、科学计算函数、用户界面组件、数据库访问组件，等等。</p></blockquote><h1 id="3-前期准备"><a href="#3-前期准备" class="headerlink" title="3. 前期准备"></a>3. 前期准备</h1><h2 id="3-1-前期准备的重要性"><a href="#3-1-前期准备的重要性" class="headerlink" title="3.1 前期准备的重要性"></a>3.1 前期准备的重要性</h2><p>就像修建建筑物一样，项目的成败很大程度上在构建活动开始之前就已经注定了。建造住宅小区的施工人员，在开始建造第一栋房子之前，并不需要知道小区里面每一栋房子的每一个细节。但他会调查施工场所，制定下水道和电线的走向等。如果施工人员准备不充分，那么建造过程很可能会因为“需要在某所已经造好的房子的地下挖一条下水道”而延误。</p><p>准备工作的中心目标就是降低风险：一个好的项目规划者能够尽可能早地将主要的风险清除掉，以便项目的大部分工作能够尽可能平稳地进行。有时候用户在一开始并不完全确定自己想要的是什么，因此值得花费比理想情况下更多的力气，找出他们真正想要的东西。但这至少比“先做一个错误的东西出来，然后扔掉，并从头来过”的成本要低廉。</p><h2 id="3-2-准备工作和构建活动的平衡"><a href="#3-2-准备工作和构建活动的平衡" class="headerlink" title="3.2 准备工作和构建活动的平衡"></a>3.2 准备工作和构建活动的平衡</h2><p>真实项目大致可以分为“商业系统”（Web站点、游戏、信息管理系统等），“使命攸关的系统”（软件工具、盒装软件、Web服务等）和“使命攸关的嵌入式系统”（航空软件、医疗设备、操作系统等）三大类。不同种类的软件项目，需要在“准备工作”和“构建活动”之间做出不同的平衡。你应该首先确定哪些前期准备活动适合你的项目。有些项目在前期准备土面花的时间太少了，结果使得在构建活动中遇到大量不必要的反复修改，同时阻碍了项目的稳步前进。有些项目则预先做了太多的事情，固执地坚持原有的需求和计划，后来事实证明这些需求和计划是无效的，这同样阻止了构建活动的顺利进展。此外，项目的实际情况也决定了哪一种开发方法更加合适，下表给出了参考。</p><table><thead><tr><th></th><th>需求</th><th>设计</th><th>领域熟悉程度</th><th>项目风险</th><th>后期改动代价</th></tr></thead><tbody><tr><td>序列式开发</td><td>稳定</td><td>直截了当</td><td>熟悉</td><td>小</td><td>昂贵</td></tr><tr><td>迭代式开发</td><td>不稳定</td><td>复杂，有挑战性</td><td>不熟悉</td><td>大</td><td>较低</td></tr></tbody></table><h2 id="3-3-明确问题和需求"><a href="#3-3-明确问题和需求" class="headerlink" title="3.3 明确问题和需求"></a>3.3 明确问题和需求</h2><p>在开始构建之前，必须对这个系统要解决的<strong>问题</strong>做出清楚的描述。“问题定义”只定义了“问题是什么”，应该从客户的角度用客户的语言来描述问题，而不应该用计算机的专业术语叙述（除非需要解决的就是与计算机本身相关的问题）。</p><p><strong>需求</strong> 详细描述软件系统应该做什么。明确的需求有助于确保是用户（而不是程序员〉驾驭系统的功能，有助于减少开始编程开发之后的系统变更情况，有助于避免争论。但是在构建期间，需求通常会有25%的变化，要更好地应对需求变更，可以采用以下方式：</p><ul><li>使用<a href="http://www.kancloud.cn/raytaylorlin/code-complete-checklist/132375" target="_blank" rel="noopener">需求核对表</a>来评估你的需求的质量</li><li>确保每一个人都知道需求变更的代价</li><li>建立一套变更控制程序</li><li>使用能适应变更的开发方法（如演进原型、演进交付）</li><li>考虑项目的商业价值</li></ul><h2 id="3-4-花费在前期准备上的时间"><a href="#3-4-花费在前期准备上的时间" class="headerlink" title="3.4 花费在前期准备上的时间"></a>3.4 花费在前期准备上的时间</h2><p>一般说来，一个运作良好的项目会在需求、架构以及其他前期计划方面投入10%~20%的工作量和20%~30%的时间。如果需求不稳定，同时你从事的是一个大型正式项目，那你就很可能需要为“与需求分析师协商”预留一些时间，以解决构建活动早期指出的需求问题；如果从事的是小型非正式项目，要预留足够的时间，将需求定义足够清晰，让需求的不稳定性对构建活动的负面影响降至最低。</p><blockquote><p>这就好比你是一名承包商，有人请你建一栋房子。客户问你：“完成这项工作要花多少钱？”你会合理地询间：“你想要我做什么？”客户说：“我不能告诉你，不过我想知道需要花费多少钱？”你该明智地感谢他浪费了你的时间，然后转身回家。</p></blockquote><p>参考文献：电子工业出版社《代码大全（第2版）》第1-4章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构建 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新版Hexo主题Raytaylorism v2发布</title>
      <link href="/daily/hexo-theme-raytaylorism-v2/"/>
      <url>/daily/hexo-theme-raytaylorism-v2/</url>
      
        <content type="html"><![CDATA[<p>时隔两年多，我自制的Hexo主题Raytaylorism（<a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism" target="_blank" rel="noopener">Github地址</a>）终于喜迎v2版本的发布。这个项目可以说是我在学生时代Web前端领域中的收官之作，因此在本次升级主题的过程中，一切都尽量做到精细。例如所有的页面都经过重新设计，采用清新的的响应式的Material Design风格，加入了个性化的“读书”“关于”页面，以及皮肤自定义、分类目录、正文滚动目录、打赏等等特色功能，并且该主题支持最新的Hexo 3.1版本。由于主题的功能较为复杂，所有的安装说明和配置事项都写在了Github项目的README中，需要使用主题的同学请<strong>认真仔细阅读README</strong>哦，<strong>特别是<a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism#启用重要" target="_blank" rel="noopener">启用</a>那一节的说明很重要！很重要！很重要！一定要照做否则你会发现hexo启动不起来或最终效果和截图上的不一样。</strong> 使用过程中有任何问题欢迎给我开issue。下面正文将介绍主题在Github上没有详细解释但又非常有特色的功能。</p><a id="more"></a><h1 id="1-换肤功能"><a href="#1-换肤功能" class="headerlink" title="1. 换肤功能"></a>1. 换肤功能</h1><p>我个人非常喜欢Material Design这种简洁清新的设计风格，也非常喜欢其定义的各种颜色。博客主题是一种非常个性化的东西，我喜欢的配色方案（包括主题默认的indigo-pink方案）不一定是你喜欢的，因此raytaylorism在几乎所有带颜色的区域都预留了配置的接口（具体参见<a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism#样式" target="_blank" rel="noopener">README-样式-主题颜色配置</a>）。不过，总有一些设计感不强的同学不知道如何下手，所以下面给出了3款参考的皮肤配置方案，大家可以各取所需随意发挥。配色的一个基本原则，就是选好一种主色和强调色。</p><h2 id="1-1-夏日甜橙"><a href="#1-1-夏日甜橙" class="headerlink" title="1.1 夏日甜橙"></a>1.1 夏日甜橙</h2><p>主色：blue 强调色：deep-orange</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fdaily%2Fblue_deeporange.jpg" alt="夏日甜橙"></p><pre><code>color:    header: indigo    footer: indigo    page_nav: indigo    side_nav: indigo darken-1    tag: green accent-4    link: indigo    pagination: green    tab: green    archive_item: grey    fab: green    fab_2: blue    fab_3: orange    new: pink    about_header: indigo    about_title: indigo</code></pre><h2 id="1-2-绿野仙踪"><a href="#1-2-绿野仙踪" class="headerlink" title="1.2 绿野仙踪"></a>1.2 绿野仙踪</h2><p>主色：green 强调色：red</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fdaily%2Fgreen_red.jpg" alt="绿野仙踪"></p><pre><code>color:    header: green    footer: green    page_nav: green    side_nav: green darken-1    tag: red lighten-1    article_title_link: green    link: red    pagination: red    tab: red    archive_item: grey    fab: red    fab_2: cyan    fab_3: light-green    new: red    about_header: green    about_title: green</code></pre><h2 id="1-3-林地木屋"><a href="#1-3-林地木屋" class="headerlink" title="1.3 林地木屋"></a>1.3 林地木屋</h2><p>主色：brown 强调色：light-green</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fdaily%2Fbrown_lightgreen.jpg" alt="林地木屋"></p><pre><code>color:    header: brown darken-1    footer: brown darken-1    page_nav: brown darken-1    side_nav: brown darken-1    tag: light-green    article_title_link: brown    link: light-green    pagination: light-green    tab: light-green    archive_item: grey    fab: light-green    fab_2: red    fab_3: purple    new: light-green    about_header: brown darken-1    about_title: brown</code></pre><h1 id="2-文章分类目录"><a href="#2-文章分类目录" class="headerlink" title="2. 文章分类目录"></a>2. 文章分类目录</h1><p>如果点击我的博客菜单中的“分类”按钮，会发现左侧侧滑栏会出来一个带有多个层级的文章分类列表。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fdaily%2Fraytaylorism-category.png" alt="主题的分类目录"></p><p>如果你也想要得到类似的效果（包括标签tag），需要按照<a href="https://hexo.io/docs/front-matter.html#Categories-amp-Tags" target="_blank" rel="noopener">hexo官方的categories/tags说明文档</a>给你的博客文章设置正确的<code>categories</code>和<code>tags</code>配置项。也就是说你的每一篇博文的markdown文件中，需要设置类似于下方的几行配置：</p><pre><code>categories:- 一级目录- 二级目录- 三级目录tags:- 第一个标签- 第二个标签</code></pre><p>准确设置后，启动hexo时主题会自动解析所有文章并形成分类树，最终生成上图那样的分类层次。</p><h1 id="3-读书页面"><a href="#3-读书页面" class="headerlink" title="3. 读书页面"></a>3. 读书页面</h1><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fdaily%2Fraytaylorism-reading.png" alt="读书页面截图"></p><p>在<a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism#数据" target="_blank" rel="noopener">README-数据-读书页面</a>中其实已经说明了如何配置读书页面的数据，照着例子来改就行了。值得注意的是，“已读”“在读”“想读”这些标签的文字是可以通过<code>reading.json</code>中的<code>define</code>字段来修改的，甚至你还可以仿照读书页面，扩展出自己的专属页面，例如“作品”页面等。只要是满足这种列表条目的数据均可以在其上自由发挥。</p><h1 id="4-关于页面"><a href="#4-关于页面" class="headerlink" title="4. 关于页面"></a>4. 关于页面</h1><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fdaily%2Fraytaylorism-about.png" alt="关于页面截图"></p><p>在<a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism#数据" target="_blank" rel="noopener">README-数据-关于页面</a>中也说明了个<code>about.json</code>中各个字段的含义，照着例子改就行了。</p><p>另外关于页面的末尾还有一个“打赏”功能，点开后会出现微信和支付宝的二维码，这个需要你自己去制作自己的付款二维码，然后把<code>reward</code>字段的两个图片链接替换掉。如果暂时不需要的话请将该字段设为null，<strong>千万不要傻乎乎地把主题照搬让别人给我的账号打赏了=。=</strong></p><p>关于主题任何使用上的疑问，欢迎在<a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism/issues" target="_blank" rel="noopener">Issues</a>上提问。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015年秋季学期总结</title>
      <link href="/daily/2015-autumn-summary/"/>
      <url>/daily/2015-autumn-summary/</url>
      
        <content type="html"><![CDATA[<p>好久没有写学期总结了。2015年秋季学期是我研究生阶段的倒数第二个学期，时间线上主要由实习、找工作、学（zhuang）习（bi）和写论文组成。由于这学期找完工作之后导师没有给我安排什么实验室的工作，所以有比较大段的自由时间可以支配。在外人看来我好像这学期过得很悠闲，实际上是在自己的合理安排下过得非常充实，现在写篇简短的文章总结一下。</p><a id="more"></a><h1 id="关于实习"><a href="#关于实习" class="headerlink" title="关于实习"></a>关于实习</h1><p>本学期比较特殊，要从七八两个月份的实习开始说起，而这次实习也可以说是我择业的转折点。本来原先在实验室一直从事的是Web前端开发，在这个领域也小有建树，但不知道从什么时候起，早些年内心里埋下的游戏开发的种子就开始生根发芽快速成长，直到15年的五月份找实习时，开始打定主意抛弃前端，只找游戏开发的岗位，而且是<strong>只找广州和深圳的游戏开发岗</strong>。如此一来，其实真正理想的就只有腾讯和网易游戏两家可选。拿许总的话讲，就是“谈了多年的女孩到谈婚论嫁的时候，突然发现其实深爱的是另一个人”“自己给自己挖了一个巨大的坑”。突然的转行导致找实习乃至后面正式找工作都非常不顺，网易游戏是简历直接挂，腾讯游戏则是二面被刷。所幸后来拿到了多益网络的offer，抱着刷个游戏公司实习经历的想法，便果断放弃阿里的前端内推offer，义无反顾地投身到游戏开发的行业。</p><p>许多同学在其他互联网公司实习后都觉得没什么太大收获，但是我却在多益实习收获了许多。技术方面，是提高了Python和Cocos2d-x引擎的熟练度，项目经历让我第一次真正接触到了游戏真机性能优化的过程；项目方面，积累了项目管理和带小团队（3程序3策划）的经验，产出了2D游戏作品《跳跳格鲁特》（<a href="http://pan.baidu.com/s/1kTYrNfD" target="_blank" rel="noopener">演示视频【密码8mm5】</a>），以及利用下班时间个人打造的日式3D RPG demo《Fantasy Adventure》（<a href="http://pan.baidu.com/s/1bnVkv9P" target="_blank" rel="noopener">演示视频【密码dg67】</a>），这两个作品也成为后面找工作时简历打动面试官的重要筹码；人脉方面，结识了一帮热爱游戏的志同道合的朋友，即使实习结束后也还经常联系交流，其中甚至有好几位还即将成为我未来的同事。当然，公司待我们不薄，我也可以很负责任地为多益正一下名，基本上没有知乎上说的那么离谱，具体情况嘛，想去多益的倒是可以私底下找我了解。总而言之，多益实习的生活丰富多彩，确实是一段难忘的经历。</p><h1 id="关于找工作"><a href="#关于找工作" class="headerlink" title="关于找工作"></a>关于找工作</h1><p>实习结束回校之后，马上就开始投身到找工作的浪潮，目标依旧是腾讯和网易游戏。然而即使认真准备了C++、算法、Cocos2d-x源码、Unity3D的深入知识，即使有了游戏公司实习经历的光环，即使有两个较为成型游戏作品的加持，面对腾讯面试依旧是浑身使不上力的感觉，依旧挂在二面。所幸网易游戏看得起我，给了第一份理想的offer，让我解了游戏开发道路的后顾之忧。后来又经贵人相助，得到了直面腾讯天美的机会，几经折腾最终是拿到了理想公司的理想部门的理想岗位。到国庆，终于华丽转身，找工作尘埃落定。当然，整个过程就只找了两家公司，没有体验过offer收割机的快感，也算是小小的遗憾。</p><h1 id="自由学习期"><a href="#自由学习期" class="headerlink" title="自由学习期"></a>自由学习期</h1><p>可能是因为我的offer是大转行，找完工作后导师也没有安排什么任务给我，所以国庆过后两个月开始进入了一段相对较长的自由学（zhuang）习（bi）期。这段时期就是看书看书再看书，看似悠哉，其实产出还是比较大的，比如：</p><ul><li>看完《Windows游戏编程大师技巧（第2版）》</li><li>看完《DirectX 9.0 3D游戏开发编程基础》</li><li>看完《3D数学基础：图形与游戏开发》</li><li>看完《武器屋》</li><li>看完《圣剑传说》</li><li>看完《游戏设计的100个原理》</li><li>看完《Web全栈工程师的自我修养》</li><li>看一部分《网络游戏核心技术与实战》</li><li>看一部分DirectX 11 Tutorial</li><li>其他杂七杂八的资料……</li></ul><h1 id="关于实验室培训"><a href="#关于实验室培训" class="headerlink" title="关于实验室培训"></a>关于实验室培训</h1><p>学习期间，大概是导师看我实在太闲，便让我开始培训实验室一批新人Web前端。早在两年以前，我便在Github上建立了<a href="https://github.com/ITEC-ELWG/FE-Study" target="_blank" rel="noopener">ELWG前端学习</a>项目，旨在推行一套比较规范的流程，来作为实验室一代又一代新人的Web前端入门培训。趁着这一次机会，我精练了整个前端培训项目，再加入一些后端的知识，形成了新的培训项目<a href="https://github.com/ITEC-ELWG/WebSystemIntroduction" target="_blank" rel="noopener">Web系统导论</a>。在此基础上，本学期我在实验室一共开了8次课（其中3次后端课由屌刘同学主讲），并有7位新人培训毕业上了课程的<a href="https://github.com/ITEC-ELWG/FE-Study/blob/master/hero.md" target="_blank" rel="noopener">英雄榜</a>。</p><p>当然，带新人之余也不能忘了实验室中坚力量的培养。做完新人培训之后，经过一番酝酿终于收了两个真正意义上的徒弟（邱邱和刘贵）。我在实验室所剩时间不多，现在又转行不再做Web前端，因此希望在毕业前能够将他们培养成前端大神兼接班人。既然是要往大神方向培养，那就得按照大神的标准来训练，打字、编辑器、计算机科学素养、前端基础、前端进阶、后端基础、设计基础等等一个都不能少。如今两个徒弟按照我初步制定的<a href="https://www.processon.com/view/566543b8e4b0fd9299902eb4" target="_blank" rel="noopener">前端大神培养计划</a>稳步成长，我内心也甚是欣慰。</p><p>除了实验室这两条培养主线之外，还有许许多多其他的带新人支线，比如带一位新生学C#、面向对象和Unity3D，带点团队移动组两位新人学入门前端，协同两位徒弟开办了若干次技术交流会等等。虽然事情都比较小，但也要分散不少精力去备课，设计教程和题目，心虽累，但仍收获颇丰，乐在其中。</p><h1 id="关于毕业论文"><a href="#关于毕业论文" class="headerlink" title="关于毕业论文"></a>关于毕业论文</h1><p>到了十二月份，就开始考虑写论文的事情了。早在写本科毕业论文的时候，就受尽了垃圾Word的折磨，比如混乱的多级标题、低效率的多级交叉引用、经常出问题的目录生成等等。同理，配套的画图工具Visio也是用户体验特别差。既然是程序员，那写论文最好也要按照程序员的基本法。一般科研界的论文用的是Latex，而程序员则惯用markdown。于是我在前人的基础上推陈出新，建立了一个开源项目<a href="https://github.com/raytaylorlin/hust-graduation-thesis-pandoc" target="_blank" rel="noopener">hust-graduation-thesis-pandoc</a>可以使用markdown来华科的毕业论文，具体可以参见我之前的博文<a href="/tech/complex/project/write-thesis-using-markdown/">《使用markdown来写毕业论文》</a>。Anyway，Word辣鸡，Visio辣鸡。</p><p>Markdown在手，写起论文正文自然专注，正文还可以按章节拆分成多个md文件，用Git做版本控制，用<a href="https://coding.net/" target="_blank" rel="noopener">coding.net</a>做私有仓库托管。画图用<a href="https://www.processon.com" target="_blank" rel="noopener">ProcessOn</a>，打开浏览器即用，随时云端存储，又能导出矢量PDF，基本上可以抛弃Visio。绘制表格可以用<a href="http://www.tablesgenerator.com/" target="_blank" rel="noopener">TablesGenerator</a>在线可视化编辑再生成Latex粘贴到正文。交叉引用用<code>\label</code>和<code>\ref</code>设置，文献引用则用Google学术复制出bibtex来管理。经过了一个月的实践考验，学期结束的时候论文完成度已经达到90%，这套解决方案被证明是可行的，撰写体验也是愉悦的。</p><h1 id="关于新版博客"><a href="#关于新版博客" class="headerlink" title="关于新版博客"></a>关于新版博客</h1><p>新版博客大概计划在11月，但实施起来已经是寒假在家的时候了。这一次博客改版为了兼容最新版本的Hexo3（老版仅能支持Hexo2是一大痛点），几乎推翻了原有主题raytaylorism的所有设计，UI上采用全新的Material Design风格，内部结构和配置也重写以提高稳定性。大家看到这篇总结的时候，正是新版博客第一次正式亮相，也意味着hexo主题raytaylorism开始进入内测阶段（目前内测人员已招募完毕）。在内测过程中，我还会继续完善和优化这个项目，并计划推出全新的个人简介页面，等一两周之后再在Github上发布主题，敬请期待。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>回首上一学期，总体来说还是过得比较愉快和充实。下学期是研究生阶段的最后一个学期，除了正常的修改论文和答辩之外，基本上也没什么事了，所以计划还是以学习为主，毕业旅行为辅。抓紧最后的大段自由时光多打好技术基础，将会是下学期的主旋律。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Markdown来写毕业论文</title>
      <link href="/tech/complex/project/write-thesis-using-markdown/"/>
      <url>/tech/complex/project/write-thesis-using-markdown/</url>
      
        <content type="html"><![CDATA[<p>最近很长一段时间没有写博客，主要是因为“学”的时间减少了，但私底下“做”的时间增加了。作为研三的老人，马上就要进入写毕业论文的阶段了，所以最近一直都在准备论文的事情，所所以博客的更新也会稍微缓一缓，估计到放假回家就可以恢复正常了。</p><p>说到准备论文，最近一直都在研究如何使用Markdown来写毕业论文，而本文就是研究成果<a href="https://github.com/raytaylorlin/hust-graduation-thesis-pandoc" target="_blank" rel="noopener">hust-graduation-thesis-pandoc</a>的展示。项目现已放在Github上，欢迎各位使用和反馈。</p><a id="more"></a><p>实验室以前的学长学姐写毕业论文，都是规规矩矩地在前人的Word文档基础上修改。但是作为一个程序猿，用Word来写论文未免太不够档（zhuang）次（bi）。更重要的是用Word来写论文时，<strong>经常在格式上会出现一些莫名其妙的问题</strong>，比如保存时明明是好的下次打开时多级标题全错乱了啊，正文的字体有时会突然错乱了啊等等，而且无论怎么调都调不好，最后只能在那气得干瞪眼，然后重新找一份前人“及格”的文档重新编辑。</p><p>当然，科研界的投稿，很多都是用<a href="https://zh.wikipedia.org/wiki/LaTeX" target="_blank" rel="noopener">Latex</a>来编写。Latex虽然超级好用，但是学习曲线太陡峭了，并不适合我们这种在一个月内就要写完论文的人士。当然，经过考验的格式编排没有问题的Latex模板网上有很多，一般拿过来直接往里面填充内容就可以了。不管怎么说，除去折腾Latex的安装和模板的制作，直接站在前人的肩膀上使用Latex模板绝对要比使用Word模板靠谱得多。</p><p>但是Latex本身是“内容和样式”混排的，<a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown</a>这种简洁优雅只专注于内容的标记语言才是程序猿的最爱。至于用Markdown来写作的优势，此处就不赘述了，懂的人应该都懂的。而最近的研究成果，就是实现了一套方案，既能让人利用Markdown的语法优势快速编写内容，又能利用Latex的强大和稳定，生成漂亮的pdf论文。要注意的是，原生的Markdown提供的功能并不足以胜任论文的编写，因为论文可能会包含公式、表格、交叉引用等等。幸运的是，使用<a href="http://pandoc.org/README.html#pandocs-markdown" target="_blank" rel="noopener">Pandoc Markdown</a>这种增强版的Markdown语法，再混编一点点Latex指令，就可以解决我们的问题。</p><p>事实上，早在几年前我的好基友<a href="https://github.com/pyrocat101" target="_blank" rel="noopener">@pyrocat101</a>就已经用Markdown完成了他的本科毕业论文。而我的这个项目也是参考了他的项目<a href="https://github.com/Sicun/hust-thesis-pandoc" target="_blank" rel="noopener">hust-thesis-pandoc</a>，同时也略微修改了同系同学<a href="https://github.com/xu-cheng" target="_blank" rel="noopener">@xu-cheng</a>提供的<a href="https://github.com/hust-latex/hustthesis" target="_blank" rel="noopener">华中科技大学毕业论文Latex模板</a>，加上自己的一套构建方法而成。所以我也要向这两位伟大的先驱者致敬。</p><p>项目的使用方法和注意事项，Github项目的文档已经写得很清楚了，这里就只简单说下我所做的工作。</p><ol><li>@xu-cheng 提供的Latex模板适用于纯Latex用户，我运行了其提供的<code>makewin32.bat unpack</code>脚本，从<a href="https://github.com/hust-latex/hustthesis/blob/master/hustthesis/hustthesis.dtx" target="_blank" rel="noopener">hustthesis.dtx</a>模板中提取出了cls和bst文件，这两个才是编写latex时真正要用到的模板。</li><li>用Markdown写一份论文示例，使用<a href="http://pandoc.org/" target="_blank" rel="noopener">Pandoc</a>这款工具，将md转换为tex。</li><li>用<a href="https://www.tug.org/texlive/" target="_blank" rel="noopener">Tex Live</a>提供的<code>xelatex</code>工具（<code>lualatex</code>亦可），编译上述tex文件，生成最终的pdf文件。</li><li>参考机油项目中的<a href="https://github.com/Sicun/hust-thesis-pandoc/blob/master/Makefile" target="_blank" rel="noopener">Makefile</a>，编写一份<a href="http://gulpjs.com/" target="_blank" rel="noopener">Gulp</a>构建脚本，将上述过程自动化。</li><li>将latex模板中的个人信息、摘要、致谢等内容分离出单独的tex文件，并整理整个项目结构。</li></ol><p>本项目目前仍处于试验期，我会在写毕业论文期间不断维护这个项目，欢迎各位评测指正。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络游戏的基本架构</title>
      <link href="/tech/game/server/network-game-architecture/"/>
      <url>/tech/game/server/network-game-architecture/</url>
      
        <content type="html"><![CDATA[<p>游戏的最大价值就是可玩性，为了保持游戏的可玩性，游戏必须具备能够“顺畅进行”的特性，而网游还需要能够“快速响应”。本文前半部分先讨论如何维持网络游戏的可玩性，后半部分说明了网络游戏常用的物理架构（C/S、P2P）和逻辑架构（MO、MMO）。</p><a id="more"></a><h1 id="1-网络游戏编程的特性"><a href="#1-网络游戏编程的特性" class="headerlink" title="1. 网络游戏编程的特性"></a>1. 网络游戏编程的特性</h1><h2 id="1-1-游戏客户端的特性"><a href="#1-1-游戏客户端的特性" class="headerlink" title="1.1 游戏客户端的特性"></a>1.1 游戏客户端的特性</h2><p>视频游戏的最大特点是：为了最大限度发挥其可玩性，必须流畅地持续进行实时的高速处理，网络游戏程序还必须始终保持高速响应。为了达到这种要求，一般会将实时的数据存放在内存中（而不是在数据库中），这是因为：</p><ul><li>游戏数据要在“16毫秒”即1帧这一短暂的时间内持续变化</li><li>需要同时显示大量对象</li><li>不知道玩家会在什么时候进行操作，所以无法事先计算</li></ul><h2 id="1-2-网络游戏客户端的特性"><a href="#1-2-网络游戏客户端的特性" class="headerlink" title="1.2 网络游戏客户端的特性"></a>1.2 网络游戏客户端的特性</h2><ul><li>通信延迟低：不同类型的游戏对延迟的要求不同，但均无法避免由地域距离所带来的延迟</li><li>控制带宽传输量：C/S MMO每人10kbit/s~100kbit/s，P2P MO为前者的3倍</li><li>服务器成本估算：C/S MMO每台服务器有1000~3000个并发连接，P2P MO为前者的3~5倍</li><li>安全性：防作弊，放破坏<ol><li>动机：纯粹个人利益、与其他玩家相关的利益、与运营公司相关的利益</li><li>作弊手段：内存破解、数据包破解、数据文件破解、时钟破解、UI工具自动模拟、服务器攻击、伪造客户端</li><li>作弊的操作对象：本地内存和文件、其他玩家的内存和文件、数据中心服务器的内存和文件、本地和其他玩家之间的数据包、本地和中心服务器之间的数据包</li></ol></li></ul><h1 id="2-物理架构详解"><a href="#2-物理架构详解" class="headerlink" title="2. 物理架构详解"></a>2. 物理架构详解</h1><p>主流的网络游戏物理架构，大致可以分为C/S架构和P2P架构。网络拓扑结构主要使用星型（包括总线型）以及全网状结构（每个节点均和其他所有节点连接）。采用这些结构，主要是因为相对于游戏的容错性和吞吐量，优先级最高的还是要把通信延迟降至最低。</p><p>对于C/S架构，又分为纯服务器型和反射型，前者服务器会对各个客户端发送来的数据进行检测，后者只是单纯转发数据。对于P2P架构，有同步和异步两种方式。此外，还有C/S+P2P混合型架构和ad-hoc模式，因为比较少见，不赘述。</p><h1 id="3-逻辑架构详解"><a href="#3-逻辑架构详解" class="headerlink" title="3. 逻辑架构详解"></a>3. 逻辑架构详解</h1><ul><li>MO（Multiplayer Online）：同时在线人数2~100人，游戏时间较短，一般在几个小时，每次开始游戏时，游戏状态都会被重置，游戏数据时一次性的。适用于FPS、RTS等在线人数较少，实时性很高的游戏。</li><li>MMO（Massively Multiplayer Online）：同时在线人数达数百、数千以上，游戏时间长达几十个小时，也不能重置游戏数据，游戏数据时永久性的。</li><li>MMO和MO混合：根据游戏策划内容，有时需要采用这种混合架构，例如在MMO游戏的某些供少数人在短时间内重复进行游戏的特殊地图，会采用MO架构。</li></ul><h2 id="3-1-MO架构"><a href="#3-1-MO架构" class="headerlink" title="3.1 MO架构"></a>3.1 MO架构</h2><h3 id="3-1-1-同步方式与全网状架构"><a href="#3-1-1-同步方式与全网状架构" class="headerlink" title="3.1.1 同步方式与全网状架构"></a>3.1.1 同步方式与全网状架构</h3><p><strong>参与游戏的所有终端都拥有主数据，这些终端只互相传输所有的控制设备输入信息</strong>，在获得所有终端的输入数据之前，游戏始终处于等待状态。这种架构要成立，必须满足这些条件：初始状态完全相同；所有输入信息数据包都确确实实毫无遗漏地发送到其他所有终端；游戏过程数据不会随机变化（伪随机数没有问题）；游戏过程数据变化不会发生波动。要满足这些条件并不苦难，但这种架构依旧有如下问题：</p><ol><li>人数增加后，收发信息完整性极易崩溃。根据“混沌理论”，即使是细微的差异，经过不断重复单纯的规则，最终也会产生截然不同的结果。</li><li>最慢的终端会拖长整体的传输时间（同步方式都会存在）</li><li>不能中途加入游戏（同步方式都会存在）。因为在中途加入游戏的一刻，为了传输游戏状态数据，所有玩家都必须长时间暂停游戏。</li></ol><h3 id="3-1-2-同步方式与星型架构"><a href="#3-1-2-同步方式与星型架构" class="headerlink" title="3.1.2 同步方式与星型架构"></a>3.1.2 同步方式与星型架构</h3><p>网络中的一个玩家终端A充当服务器，客户端将控制设备上的输入信息发送至服务器，服务器在接收完所有数据前一直处于等待状态，接收完成后将信息同时发送给所有客户端。这种方式的最大优点就是，所需增加的传输线路与所增加的玩家数成正比，传输线路不会爆发性增长。但依旧有如下问题：</p><ol><li>响应较慢</li><li>若玩家A中途离线，游戏无法恢复，只能强行终止</li><li>程序结构比全网状结构稍微复杂</li><li>玩家A终端上的传输负荷比其他终端高出很多，不公平</li></ol><h3 id="3-1-3-异步方式"><a href="#3-1-3-异步方式" class="headerlink" title="3.1.3 异步方式"></a>3.1.3 异步方式</h3><p>异步方式下，各个终端的游戏状态是不同的，必须在游戏数据的一致性方面做出妥协。由于这种妥协，异步方式下可以使用更加不稳定和延迟更大的传输线路，也可以支持更多的同时在线数。另一方面，程序相比同步方式会略显复杂，且有些情况下游戏体验更差一些。在实现方面，对游戏数据做出何种妥协完全依赖于游戏的具体内容。异步实现的指导方针是：将游戏世界的基本要素分为三大类，即自己的状态，对手的状态和环境状态。这三大类之间的两两关系又需要分别对待处理，此处不赘述。（具体参见《网络游戏核心技术与实战》3.4.7-3.4.13）</p><h2 id="3-2-MMO架构——浏览器方式"><a href="#3-2-MMO架构——浏览器方式" class="headerlink" title="3.2 MMO架构——浏览器方式"></a>3.2 MMO架构——浏览器方式</h2><p>MMO游戏也被称为“持久的游戏”，因为其累计的游戏时长可能高达数千个小时。为此必须在服务器的内存和磁盘上准确无误地完整地保存各种游戏数据，当玩家需要时瞬间取出来展现给玩家。因为数据一致性方面的要求非常严苛，所以在构建系统时要<strong>将客户端和服务器完全分离</strong>。在MMO架构中，<strong>客户端将控制设备输入信息发送给服务器，服务器只想客户端发送游戏过程中的结果，客户端则把游戏结果可视化展现给玩家。</strong>这就是逻辑架构中所谓的浏览器方式。</p><p>在这种架构下，即使没有客户端，游戏也会在服务器上持续运行，所有的逻辑都在服务器上处理，而客户端只进行与渲染、音效、输入有关的处理。</p><p>最后，总结比较一下3种逻辑架构之间的差异：</p><ul><li>浏览器方式和同步方式：最大差异在“传输内容”，即同步方式下收发的都是玩家输入信息（原因），而在浏览器方式下，客户端发送玩家输入信息（原因），服务器发送游戏过程的结果。</li><li>同步方式和异步方式：两种方式下，所有终端都共享游戏过程的所有主数据</li></ul><p>参考文献：人民邮电出版社《网络游戏核心技术与实战》第3章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 服务器端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络游戏编程基础知识</title>
      <link href="/tech/game/server/network-programming/"/>
      <url>/tech/game/server/network-programming/</url>
      
        <content type="html"><![CDATA[<p>本文首先介绍网络游戏开发者需了解的网络编程基础，包括对应的OSI七层分层模型，与游戏架构的关系。然后介绍套接字API及RPC相关的内容。</p><a id="more"></a><h1 id="1-开发者需了解的网络编程基础"><a href="#1-开发者需了解的网络编程基础" class="headerlink" title="1. 开发者需了解的网络编程基础"></a>1. 开发者需了解的网络编程基础</h1><h2 id="1-1-网络游戏对应的OSI模型"><a href="#1-1-网络游戏对应的OSI模型" class="headerlink" title="1.1 网络游戏对应的OSI模型"></a>1.1 网络游戏对应的OSI模型</h2><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/server/网络游戏对应的OSI模型.png" alt="网络游戏对应的OSI模型"></p><p>一般来说，第4层以下的分层，交由操作系统来处理即可。第4层大多使用TCP，只有在有必要的情况下才使用UDP（例如<strong>发送那些与可靠性相比到达速度更为重要的数据</strong>（如FPS游戏），实现NAT遍历功能等等）。由于游戏类型和策划内容千差万别无法统一，第5层及以上的功能需要网游开发人员自己实现。</p><h2 id="1-2-网络编程特性与游戏架构的关系"><a href="#1-2-网络编程特性与游戏架构的关系" class="headerlink" title="1.2 网络编程特性与游戏架构的关系"></a>1.2 网络编程特性与游戏架构的关系</h2><ol><li>C/S架构游戏（C/S MMO、C/S MO）：高性能高功能服务器端编程+一般程度的客户端编程</li><li>P2P架构游戏（P2P MO）：一般程度的服务器编程+高性能高功能呢的客户端编程（因为客户端要扮演服务器的角色）</li></ol><p>高性能高功能服务器的特性：</p><ol><li>小带宽：每秒几次至20几次，达到几百位通信量的持续连接</li><li>极高的连接数：每台服务器需要维持数千至数万个连接</li><li>低延迟：处理并返回结果的延迟，只能在几毫秒至20毫秒以内</li><li>稳定：服务器端保持游戏状态、敌人等可以移动的物体实时地持续行动</li></ol><p>与服务器端相比，客户端的连接数较少，但是需要进行渲染等重要处理，还必须在延迟很低的情况下进行通信，并应对网络状况的多样性（如防火墙、各ISP的策略间差异等等）。</p><h1 id="2-套接字API"><a href="#2-套接字API" class="headerlink" title="2. 套接字API"></a>2. 套接字API</h1><h2 id="2-1-网络游戏中的套接字API"><a href="#2-1-网络游戏中的套接字API" class="headerlink" title="2.1 网络游戏中的套接字API"></a>2.1 网络游戏中的套接字API</h2><p><a href="https://zh.wikipedia.org/wiki/Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97" target="_blank" rel="noopener">BSD套接字API</a>（即Scoket API）是为了实现互联网连接而开发的API，是在所有操作系统上进行网络开发的首选。关于套接字API编程基础可见WIKI及网上各种资料。</p><p>使用第4层的套接字API，可以在不具可靠性的IP协议上实现两种类型的通信：一种是<strong>面向连接的流式（Stream）通信</strong>，在简历了连接的两台主机间维持通信线路畅通，保证通信持续进行；另一种是<strong>无连接的数据报（DGram）通信</strong>，只进行一次数据报交换，不维持主机间的通信线路。</p><p>套接字API中的<code>accept()</code>函数在“新的连接请求到来前一直等待着”，显然不能满足网络游戏服务器为多个客户端同时提供服务的要求。为了解决这个问题必须处理多个并发连接，方法大致有：</p><ol><li>每次连接时启动一个进程：<strong>不可用</strong>，因为网络游戏中需要多个用户连接实时共享同一个游戏状态</li><li>使用线程并行进行同步处理：<strong>不可用</strong>，几千个连接启动几千个线程会使服务器性能大幅下降</li><li>异步多重输入输出：使用<code>select</code>函数事先查询所带的消息（数据及连接请求）是否已经到达，即轮询。（使用<code>poll</code>及更高速的<code>epoll</code>函数也可实现同样的功能</li></ol><p>网络游戏编程中同时处理数千个可移动物体是很平常的，因此客户端和服务器端通常都使用select（或poll/epoll）在<strong>单线程</strong>中实现简单的<strong>事件驱动</strong>的<strong>非阻塞</strong>模式。通过这种模式，还可以充分发挥出<strong>多核</strong>服务器的性能。</p><p>实现服务器端的最佳程序库是<a href="http://libevent.org/" target="_blank" rel="noopener">libevent</a>，这是一个跨平台的基于事件和回调的库，全世界应用广泛，不管是性能还是稳定性都比较成熟。</p><h2 id="2-2-多核处理器与网络吞吐量"><a href="#2-2-多核处理器与网络吞吐量" class="headerlink" title="2.2 多核处理器与网络吞吐量"></a>2.2 多核处理器与网络吞吐量</h2><p>服务器通常用以太网连接至数据中心的网络中，通信速度为1Gbit。但是网游中经常会发送大量的小数据包，由于以太网在发送IP数据包时会向数据包中添加IP数据意外的信息一起发送，所以实际上应用程序能够使用的带宽要更小。</p><p>根据经验，将理论值的1/10作为基准，1Gbit/s以太网每秒可以发送100MB的数据，能够发送的数据包最好以每秒10W-15W为上限。如果在有10个内核的机器使用1Gbit/s以太网，每个内核可以处理大约1W个数据包，若同时连接数为每个内核1000个连接，则每个连接必须设计为发送频率限制在10次/s以内；或者，安装多个网络适配器，连接4根LAN电缆来实现4倍的吞吐量。</p><h1 id="3-RPC通信中间件"><a href="#3-RPC通信中间件" class="headerlink" title="3. RPC通信中间件"></a>3. RPC通信中间件</h1><p>远程过程调用协议RPC（Remote Procedure Call），将与通信有关的一些复杂细节封装起来，与一般的函数调用形式相同，是确保与远程主机进行简单、安全通信的一种方法。有了RPC，就不需要直接使用复杂的套接字API进行网络编程了。</p><h2 id="3-1-通信库的必要性"><a href="#3-1-通信库的必要性" class="headerlink" title="3.1 通信库的必要性"></a>3.1 通信库的必要性</h2><p>单纯使用套接字API之所以会很复杂，是因为会根据网络状况产生这些问题：不一定能成功收发期望数据，之后需要再次调用；可能会发生错误；发送缓存满了的话，write()函数会等待；发送了不完整的内容。</p><p>套接字API中的send在发送成功前不会阻塞，每次编写错误处理造成的代码重复也是引起很多错误的根源。因此需要一个能独自负责这些工作的程序库，这个库应首先针对网络的IO要求装入缓存中，接着准确地执行，再将数据发送出去直至完成，若一段时间内无法发送则返回错误信息。总而言之，通信库会对诸如<code>send</code>这样的函数进行封装，并确定像<code>[数据类型代码][数据内容]</code>的数据格式，来收发数据。</p><h2 id="3-2-网游中使用的RPC整体结构"><a href="#3-2-网游中使用的RPC整体结构" class="headerlink" title="3.2 网游中使用的RPC整体结构"></a>3.2 网游中使用的RPC整体结构</h2><p>RPC的基本原理是在本地模拟远程主机的函数调用，主要通过将数据流进行编码后发送出去，远程主机接收数据并解码，然后调用相应的函数。下图展示了网游中RPC的基本模式。注意到调用侧应用程序调用了<code>attackAtEnemy</code>函数，该函数定义在源文件“RPC存根代码”中，存根代码是用工具自动生成的，不需要手工编写。其中“123”固定值表示要调用<code>attackAtEnemy</code>这个函数，“99”表示要攻击id为99的敌人。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/server/网络游戏中使用的RPC模式.jpg" alt="网络游戏中使用的RPC模式"></p><p>RPC存根代码文件中调用方和被调用方的函数参数列表必须完全一致，如果有大量函数，应该采用RPC工具来自动生成。通常使用Ruby或Python等很容易进行DSL（领域特定语言）定义的语言来设计<a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">IDL（接口描述语言）</a>，然后执行脚本生成存根函数的源代码和头文件。</p><h1 id="4-确保开发效率和可移植性"><a href="#4-确保开发效率和可移植性" class="headerlink" title="4. 确保开发效率和可移植性"></a>4. 确保开发效率和可移植性</h1><ul><li>正式服务器采用Linux，但开发环境则是在Windows下用Visual Studio以高效地开发</li><li>服务器端和客户端在碰撞检测等方面使用相同的游戏处理代码，确保可移植性</li></ul><p>为了降低操作系统的差异性，需要对以下这些基础API进行封装以保持可移植性：</p><ul><li>内存管理：malloc几乎在所有的操作系统中都会使用，所以很容易封装</li><li>套接字API：Windows和UNIX系统（包括iOS）有所不同</li><li>线程：封装pthread的基本API即可</li><li>信号：远程管理服务器的情况下需要使用信号，但这是一种可移植性很低的方法，并不推荐</li><li>事件与计时：使用libevent</li></ul><p>网络编程中，对所有套接字调用select函数进行轮询，对于需要处理的内容执行read和write操作，调用回调函数来逐个处理；在客户端游戏编程中，对所有可移动物体以帧为单位进行轮询，对于需要进行处理的物体调用回调函数来使其行动。因此，无论是服务器端还是客户端，大多使用<strong>单线程</strong>来完成开发。</p><p>参考文献：人民邮电出版社《网络游戏核心技术与实战》第0章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 服务器端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cocos2d-x 3.0绘制系统</title>
      <link href="/tech/game/client/cocos2dx-render-system/"/>
      <url>/tech/game/client/cocos2dx-render-system/</url>
      
        <content type="html"><![CDATA[<p>在Cocos2d-x 3.0之前，Cocos2d-x每个元素的绘制逻辑都分布在每个元素内部的draw()方法里，并紧密地依赖UI树的遍历。Cocos2d-x 3.0对绘制部分进行了重构，新的架构将绘制部分从UI树的遍历中分离出来，其设计更优雅、更灵活、更易于扩展。本文将介绍Cocos2d-x 3.0新绘制系统的特点、架构及绘制细节。</p><a id="more"></a><h1 id="1-新绘制系统的特点"><a href="#1-新绘制系统的特点" class="headerlink" title="1. 新绘制系统的特点"></a>1. 新绘制系统的特点</h1><ul><li>将绘制逻辑从主循环中分离。</li><li>采用应用程序级别的视口剪裁。如果一个UI元素在场景中的坐标位移视口之外，那么它不会发送任何绘制命令到绘制栈上。</li><li>采用自动批绘制技术。如果一个场景中多个不同类型的UI元素使用相同的纹理，可以只调用一次绘制命令。</li><li>更简单地实现绘制的自定义。</li></ul><h1 id="2-绘制系统概览"><a href="#2-绘制系统概览" class="headerlink" title="2. 绘制系统概览"></a>2. 绘制系统概览</h1><p>Cocos2d-x 3.0新绘制系统分为三个阶段：生成绘制命令、对绘制命令进行排序、执行绘制命令。</p><p>首先，通过UI树的遍历给每个元素生成一个RenderCommand（定义了怎样绘制一个UI元素），并将该命令添加到renderer的绘制栈中，如下图所示。接着引擎使用<code>globalZOrder</code>及元素的遍历顺序对绘制命令进行排序。最后执行绘制命令，对一般的RenderCommand，按顺序执行，对Sprite使用的QuadCommand，若两个命令相邻且使用相同的纹理、着色器等，则会组合成一个命令（即自动批处理）。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/game/遍历UI树并将绘制命令发送到绘制栈.png" alt="遍历UI树并将绘制命令发送到绘制栈"></p><h2 id="2-1-RenderCommand概况"><a href="#2-1-RenderCommand概况" class="headerlink" title="2.1 RenderCommand概况"></a>2.1 RenderCommand概况</h2><p>每个RenderCommand实例包含一个<code>globalOrder</code>属性，用于决定绘制顺序，实际上，它们几乎都来自Node的<code>globalZOrder</code>属性</p><p>5种RenderCommand类型：</p><ul><li>QUAD_COMMAND：根据1个纹理和4个顶点绘制一幅图片，所有绘制图片的命令都会调用到这里，处理这个类型命令的代码就是绘制贴图的OpenGL代码。</li><li>GROUP_COMMAND：用于包装多个RenderCommand的集合，可以用来实现子元素剪裁（对应ClippingNode）和绘制子元素到纹理（对应RenderTexture）。</li><li>BATCH_COMMAND：用于绘制一个TextureAtalas，如Label、TileMap。这种类型的命令不能参与自动批绘制。</li><li>CUSTOM_COMMAND：自定义绘制命令</li><li>UNKNOWN_COMMAND：未知绘制命令</li></ul><h2 id="2-2-RenderQueue和GroupCommand概况"><a href="#2-2-RenderQueue和GroupCommand概况" class="headerlink" title="2.2 RenderQueue和GroupCommand概况"></a>2.2 RenderQueue和GroupCommand概况</h2><p>每个UI元素的RenderCommand会被发送到一个叫RenderQueue的绘制命令栈上，Renderer持有多个RenderQueue（用<code>_renderGroups</code>来存储）。<strong>但GroupCommand比较特殊，它只指向一个RenderQueue。可以认为一个RenderQueue就是一个GroupCommand，而创建一个GroupCommand时会将其作为一个普通的RenderCommand发送到当前的RenderQueue上，并在Renderer上创建一个新的RenderQueue。</strong></p><h2 id="2-3-RenderCommand的排序"><a href="#2-3-RenderCommand的排序" class="headerlink" title="2.3 RenderCommand的排序"></a>2.3 RenderCommand的排序</h2><p>由于每一帧都可能执行数百个RenderCommand，所以Cocos2d-x对此进行了优化，每个RenderQueue只对其包含的<strong>globalOrder非0</strong>的RenderCommand进行排序，而RenderCommand被添加到RenderQueue中的顺序使由Node的<code>localZOrder</code>决定的。所以，实际上只需要对少数特殊设置了globalOrder属性的Node进行排序即可。注意，每个RenderQueue实例中实际包含了3个RenderCommand数组，分别存放globalOrder小于0、等于0和大于0的RenderCommand，这样可以最大限度地减少排序的量。</p><h1 id="3-绘制系统相关机制"><a href="#3-绘制系统相关机制" class="headerlink" title="3. 绘制系统相关机制"></a>3. 绘制系统相关机制</h1><h2 id="3-1-QuadCommand"><a href="#3-1-QuadCommand" class="headerlink" title="3.1 QuadCommand"></a>3.1 QuadCommand</h2><p>QuadCommand用于绘制一个或多个矩形区域，每个矩形是一个纹理的一部分。这是最基础的绘制命令，包含了TextureID（使用的纹理）、Shader Program、BlendFunc（混合模式）和Quads（绘制的矩形区域的定义，包括每个点的坐标、颜色和纹理坐标）4部分内容。</p><p>Cocos2d-x使用<code>Renderer::render()</code>方法进行自动批绘制的过程是：</p><ol><li>第一次遇到一个QuadCommand时不会理你绘制，而是将其放到一个数组中缓存起来，然后继续迭代</li><li>若遇到第二个RenderCommand仍然是QuadCommand，并且使用相同的Material（纹理、着色器、混合模式等等），则继续添加到缓存数组，若不是，则首先绘制之前的缓存数组的指令。这样就能实现自动合并绘制命令。</li></ol><p>如何判断是否是相同的Material？<code>QuadCommand::generateMaterialID()</code>方法检查是否包含自定义的着色器（包含自定义着色器就不能参与批绘制），如果不包含就使用与着色器名称、纹理名称及混合方程相关的参数计算一个Hash值，Hash值相同表明是相同的Material。</p><h2 id="3-2-元素可见性"><a href="#3-2-元素可见性" class="headerlink" title="3.2 元素可见性"></a>3.2 元素可见性</h2><p>在OpenGL ES的图元装配阶段，渲染管线会对每个图元执行视锥体裁剪操作，位于视锥体之外的图元会被丢弃或裁剪。所谓的自动裁剪（Auto Culling）技术，是在遍历UI树时对Sprite进行位置计算，如果发现其位于屏幕之外，则不会发送绘制命令到Renderer中。Node类还有一个visible属性，用于控制一个元素是否显示，如果为false，则该元素在遍历UI树时会被忽略。</p><p>如果一个应用程序有很大的应用场景，则不应该完全依赖自动裁剪。因为自动裁剪只是减少了绘制命令调用的次数，而这些元素所使用的纹理仍然占据着内存，所以还要注意对纹理内存的管理。</p><h2 id="3-3-绘制时机"><a href="#3-3-绘制时机" class="headerlink" title="3.3 绘制时机"></a>3.3 绘制时机</h2><p>将绘制和UI树遍历分离带来一个问题：我们不知道元素什么时候被绘制了，我们只有等到下一帧才能确定所有绘制命令被执行了。这种机制对一些操作（如RenderTexture需要等到绘制完毕后操作纹理）显得很不方便，一般有两种方法来处理这种情况：</p><ol><li>注册一个一次性Schedule，在下一帧被执行时读取上一帧的绘制结果，并注销该Schedule。</li><li>若要精确把握绘制时机，可以添加一个CustomCommand，将其func属性重写为不包含GL命令调用的自定义回调。这样只要把CustomCommand放在合适的绘制位置（通过globalOrder或localZOrder来调节）。像RenderTexture中的saveToFile方法就是采用这种方法来控制绘制时机。</li></ol><p>参考文献：电子工业出版社《我所理解的Cocos2d-x》第4章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 游戏开发 </category>
          
          <category> 客户端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cocos2d-x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式六大原则</title>
      <link href="/tech/complex/DP/design-pattern-principles/"/>
      <url>/tech/complex/DP/design-pattern-principles/</url>
      
        <content type="html"><![CDATA[<p>设计模式除了常见的23种模式之外，还有六大原则。对这六个原则的遵守并非是和否的问题，而是多和少的问题。制定这六个原则的目的并不是要我们刻板的遵守，而需要根据实际情况灵活运用。</p><p>设计模式经常要涉及到UML类图，这里附上<a href="http://design-patterns.readthedocs.org/zh_CN/latest/index.html" target="_blank" rel="noopener">图说设计模式</a>中的一章<a href="http://design-patterns.readthedocs.org/zh_CN/latest/read_uml.html" target="_blank" rel="noopener">看懂UML类图和时序图</a>，以方便快速复习UML类图中各种符号的含义。</p><a id="more"></a><h1 id="1-单一职责原则（SRP"><a href="#1-单一职责原则（SRP" class="headerlink" title="1. 单一职责原则（SRP)"></a>1. 单一职责原则（SRP)</h1><p><strong>定义： 就一个类而言，应该仅有一个引起它变化的原因。</strong></p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意向不到的破坏。如果能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p><h1 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2. 里氏替换原则"></a>2. 里氏替换原则</h1><p><strong>定义：子类必须能够替换掉它们的父类</strong></p><p>软件里把父类替换成它的子类，程序的行为没有变化。只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</p><p>例子：一个鸟类，一个企鹅类。鸟有“飞”的行为，企鹅不会飞，所以企鹅不能以父类——鸟的身份出现，即企鹅类不能继承鸟类。</p><h1 id="3-依赖倒置原则"><a href="#3-依赖倒置原则" class="headerlink" title="3. 依赖倒置原则"></a>3. 依赖倒置原则</h1><p><strong>定义：高层模块不应该依赖底层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。</strong></p><p>要针对接口编程，不要对实现编程。在Java或C#语言中的表现就是：实现类之间不发生直接的依赖关系，依赖关系是通过接口产生的。依赖倒置是面向对象设计的标志，如果程序中所有的依赖关系都终止于抽象类或接口，就是面向对象的设计。</p><p>例子：</p><ol><li>CPU、内存等都是针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，就会出现换内存也要把主板换了的尴尬。</li><li>做项目大多要访问数据库，把访问数据库的代码写成函数，每次做新项目时去调用这些函数，这就叫高层模块依赖低层模块。做新项目时，发现业务逻辑的高层模块都是一样的额，但客户却希望使用不同的数据库，高层模块与低层的访问数据库绑定在一起，没办法复用高层模块。应该两者都依赖约定的接口。</li></ol><h1 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h1><p><strong>定义：客户端不应该依赖它不需要的接口（接口尽量细化），类见的依赖关系应该建立在最小的接口上。</strong></p><p>接口“小”是要有限度的，首先不能违反单一职责原则，其次是要高内聚。一个接口只服务于一个子模块或业务逻辑，通过业务逻辑压缩接口中的public方法。</p><h1 id="5-迪米特法则"><a href="#5-迪米特法则" class="headerlink" title="5. 迪米特法则"></a>5. 迪米特法则</h1><p><strong>定义：如果两个类不必彼此直接通信，那么这两个类就不应该发生直接的相互作用。一个对象应该对其他对象有最少的了解。</strong>如果一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。</p><p>该法则的根本思想，是强调了类之间的松耦合。一个类公开的public属性或方法越多，修改时涉及的面和风险也就越大。在设计时需要反复衡量：是否还可以再减少public方法和属性。<em>实践中，如果一个类跳转两次以上才能访问到另一个类，就说明系统过于复杂，需要想办法进行重构了。</em></p><h1 id="6-开闭原则"><a href="#6-开闭原则" class="headerlink" title="6. 开闭原则"></a>6. 开闭原则</h1><p><strong>定义：软件实体（类、模块、函数等等）应该可以扩展开放，对修改封闭。</strong></p><p>面对需求变化，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。但在最初编写代码时，难以预测到变化的产生，这就要求变化发生时，就创建抽象来隔离以后发生的同类变化。开发人员应该仅对程序中呈现出频繁变化的那些部分作出抽象，拒绝不成熟的抽象和抽象本身一样重要。</p><p>例子：书店管理图书，<code>IBook</code>接口有<code>getName</code>、<code>getPrice</code>、<code>getAuthor</code>方法，实现类<code>NovelBook</code>实现<code>IBook</code>接口，客户端类<code>BookStore</code>关联<code>IBook</code>接口。</p><ol><li>当<em>获取原价格</em>的业务变化成<em>获取打折处理后的价格</em>时，应该扩展一个子类（继承<code>NovelBook</code>）<code>OffNovelBook</code>，覆写<code>getPrice</code>方法来获取打折价格。</li><li>若要新增一种计算机类图书，且可以获取其领域，可以新增<code>IComputerBook</code>接口继承<code>IBook</code>，其中包含<code>getScope</code>方法，再增加一个<code>ComputerBook</code>实现类。</li></ol><p>最后总结一下：</p><ul><li>单一职责原则告诉我们实现类要职责单一</li><li>里氏替换原则告诉我们不要破坏继承体系</li><li>依赖倒置原则告诉我们要面向接口编程</li><li>接口隔离原则告诉我们在设计接口的时候要精简单一</li><li>迪米特法则告诉我们要降低耦合</li><li>开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭</li></ul><p>参考文献：《设计模式之禅（第2版）》第1-6章、《大话设计模式》</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua学习笔记（7）——面向对象编程</title>
      <link href="/tech/language/lua/lua-note-7/"/>
      <url>/tech/language/lua/lua-note-7/</url>
      
        <content type="html"><![CDATA[<p>Lua中的table就是一种对象，因为它和对象一样可以拥有状态，也拥有一个独立于其值的标识（一个self），也和对象一样具有独立于创建者的生命周期。但是Lua中没有类的概念，只能用元表来实现原型，用原型来模拟类和继承等面向对象特性。本文将介绍Lua关于面向对象编程的内容。</p><a id="more"></a><h1 id="1-对象与类"><a href="#1-对象与类" class="headerlink" title="1. 对象与类"></a>1. 对象与类</h1><h2 id="1-1-self与冒号语法"><a href="#1-1-self与冒号语法" class="headerlink" title="1.1 self与冒号语法"></a>1.1 self与冒号语法</h2><p>使用self参数是所有面向对象语言的一个核心，Lua只需使用冒号语法，就能隐藏该参数，例如下面两段代码是等价的。</p><pre><code>Account = {balance=0}funtion Account.withdraw(self, v)    self.balance = self.balance - venda1 = Account; Account = nila1.withdraw(a1, 100.0)  -- 注意这是可以运行的function Account:withdraw(v)    self.balance = self.balance - venda2 = Accounta2:withdraw(100.0)  -- 省略了a2参数传入</code></pre><h2 id="1-2-类的编写"><a href="#1-2-类的编写" class="headerlink" title="1.2 类的编写"></a>1.2 类的编写</h2><p>在一些基于原型的语言中，对象是没有类型的，但每个对象都有一个原型。原型是一种常规的对象，当其他对象遇到一个未知操作时，原型会先查找它。在这种语言中要表示一个类，只需创建一个专用做其他对象的原型。Lua中实现原型很简单，只需用元表的<code>__index</code>来实现继承。</p><p>（当访问一个table中不存在的字段key时，一般得到结果为nil。事实上，访问会促使解释器去查找一个叫<code>__index</code>的元方法，如果没有这个元方法，则访问结果如前述的nil，否则由这个元方法来提供结果。元方法除了是一个函数，还可以是一个table，如果是table则直接返回该table中key对应的内容。）</p><p>如果有两个对象a和b，要让b作为a的一个原型，只需<code>setmetatable(a, {__index=b})</code>。a就会在b中查找它没有的操作。</p><pre><code>function Account:new(o)    o = o or {}  -- 如果用户没有提供table，则创建一个    setmetatable(o, self)    self.__index = self    return oend</code></pre><p>当调用<code>a = Account:new{balance = 0}</code>时，a会将Account（函数中的self）作为其元表。当调用<code>a:withdraw(100.0)</code>时，Lua无法在table a中找到条目withdraw，则进一步搜索元表的<code>__index</code>条目，即<code>getmetatable(a).__index.withdraw(a, 100.0)</code>。由于new方法中做了<code>self.__index = self</code>，所以上面的表达式又等价于<code>Account.withdraw(a, 100.0)</code>，这样就传入了a作为self参数，又调用了Account类的withdraw函数。<strong>这种创建对象的方式不仅可以作用于方法，还可以作用于所有其他新对象中没有的字段。</strong></p><h2 id="1-3-继承"><a href="#1-3-继承" class="headerlink" title="1.3 继承"></a>1.3 继承</h2><p>现在要从Account类派生出一个子类SpecialAccount（以使客户能够透支），只需：</p><pre><code>SpecialAccount = Account:new()s = SpecialAccount:new{limit=1000.00}</code></pre><p>SpecialAccount从Account继承了new，当执行<code>SpecialAccount:new</code>时，其self参数为SpecialAccount，因此s的元表为SpecialAccount。当调用s不存在的字段时，会向上查找，也可以编写新的重名方法覆盖父类方法。</p><h2 id="1-4-多重继承"><a href="#1-4-多重继承" class="headerlink" title="1.4 多重继承"></a>1.4 多重继承</h2><p>上面介绍中为<code>__index</code>元方法赋值一个table实现了单继承，如果要实现多重继承，可以让<code>__index</code>字段成为一个函数，在该函数中搜索多个基类的方法字段。由于这种搜索具有一定复杂性，多重继承的性能不如单一继承。还有一种改进性能的简单做法是将继承的方法复制到子类中，但这种做法的缺点是当系统运行后就较难修改方法的定义，因为这些修改不会沿着继承体系向下传播。</p><h2 id="1-5-私密性"><a href="#1-5-私密性" class="headerlink" title="1.5 私密性"></a>1.5 私密性</h2><p>Lua在设计对象时，没有提供私密性机制（private），但其各种元机制使得程序员可以模拟对象的访问控制。这种实现不常用，因此只做基本的了解：通过两个table来表示一个对象，一个用来保存对象的状态，一个用于对象的操作（即接口）。</p><pre><code>function newAccount(initialBalance)    local self = {balance = initialBalance}    local withdraw = function(v)        self.balance = self.balance -v    end    return {        withdraw = withdraw    }end</code></pre><p>通过闭包的方式，将具有私密性的字段（如balance）保存在self table中，并只公开了withdraw接口，这样就能实现私密性机制。</p><p>参考文献：电子工业出版社《Lua程序设计（第2版）》第16章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua学习笔记（6）——环境与模块</title>
      <link href="/tech/language/lua/lua-note-6/"/>
      <url>/tech/language/lua/lua-note-6/</url>
      
        <content type="html"><![CDATA[<p>模块就是一个程序库，而包是一系列模块。Lua中可以通过require来加载模块，然后得到一个全局变量表示一个table。Lua将其所有的全局变量保存在一个被称为“环境”的常规table中。本文首先介绍环境的一些实用技术，然后介绍如何引用模块及编写模块的基本方法。</p><a id="more"></a><h1 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h1><p>Lua将环境table保存在一个全局变量<code>_G</code>中，可以对其访问和设置。有时我们想操作一个全局变量，而它的名称却存储在另一个变量中，或者需要通过运行时的计算才能得到，可以通过<code>value = _G[varname]</code>来获得动态名字的全局变量。</p><p>关于“环境”的一大问题是它是全局的，任何对它的修改都会影响程序的所有部分。Lua 5允许每个函数拥有一个子集的环境来查找全局变量，可以通过<code>setfenv</code>来改变一个函数的环境，第一个参数若是1则表示当前函数，2则表示调用当前函数的函数（依次类推），第二个参数是一个新的环境table。</p><pre><code>a = 1setfenv(1, {})print(a) -- 会报错，print是一个nil。这是因为一旦改变环境，所有的全局访问都会使用新的table</code></pre><p>为了避免上述问题，可以使用<code>setfenv(1, {_G = _G})</code>将原来的环境保存起来，然后用<code>_G.print</code>来引用。另一种组装新环境的方法是使用继承，下面的代码新环境从源环境中继承了print和a，任何赋值都发生在新的table中。</p><pre><code>a = 1local newgt = {}setmetatable(newgt, {__index = _G})setfenv(1, newgt)print(a)</code></pre><h1 id="2-模块与包"><a href="#2-模块与包" class="headerlink" title="2. 模块与包"></a>2. 模块与包</h1><h2 id="2-1-调用模块"><a href="#2-1-调用模块" class="headerlink" title="2.1 调用模块"></a>2.1 调用模块</h2><p>要调用模块mod中的foo方法，可以用<code>require</code>函数来加载，如：</p><pre><code>require &quot;mod&quot;mod.foo()-- 或者local m = require &quot;mod&quot;m.foo()</code></pre><p><code>require</code>函数的行为： （关于require使用的路径查找策略不赘述）<br>在<code>package.loaded</code>这个table中检查模块是否已加载<br>=&gt; 已加载，就返回相应的值（可见一个模块只会加载一次）<br>=&gt; 未加载，就试着在<code>package.preload</code>中查询传入的模块名<br>===&gt; 找到一个函数，就以该函数作为模块的加载器<br>===&gt; 找不到，则尝试从Lua文件或C程序库中加载模块<br>=====&gt; 找到Lua文件，通过<code>loadfile</code>来加载文件<br>=====&gt; 找到C程序库，通过<code>loadlib</code>来加载文件</p><h2 id="2-2-使用环境"><a href="#2-2-使用环境" class="headerlink" title="2.2 使用环境"></a>2.2 使用环境</h2><p>下面的代码说明了如何用环境来创建一个复数（complex）模块：</p><pre><code>-- 模块设置local modname = &quot;complex&quot;local M = {}_G[modname] = Mpackage.loaded[modname] = M-- 声明模块从外界所需的所有东西local _G = _G  -- 保留旧环境的引用，使用时需要像_G.print这样用local io = io-- 运行这句之后环境就变了setfenv(1, M)function new(r, i) return {r=r, i=i} endfunction add(c1, c2)    return new(c1.r + c2.r, c1.i + c2.i)end</code></pre><p>这样声明函数add时，就成为了<code>complex.add</code>，调用同一模块的其他函数也不需要加前缀。</p><h2 id="2-3-module函数"><a href="#2-3-module函数" class="headerlink" title="2.3 module函数"></a>2.3 module函数</h2><p>Lua 5.1提供了一个新函数<code>module</code>，囊括了上面一系列定义环境的功能。在开始编写一个模块时，可以直接用<code>module(&quot;modname&quot;, package.seeall)</code>来取代前面的设置代码。在一个模块文件开头有这句调用后，后续所有代码都不需要限定模块名和外部名字，同样也不需要返回模块table了。</p><h2 id="2-4-子模块与包"><a href="#2-4-子模块与包" class="headerlink" title="2.4 子模块与包"></a>2.4 子模块与包</h2><p>Lua支持具有层级的模块名，用一个点来分隔名称中的层级。例如一个模块名为<code>mod.sub</code>，就是mod的一个子模块。一个包（package）就是一个完整的模块树，它是Lua中发型的单位。注意，当搜索一个子模块文件时，require会把点号当做目录分隔符来搜索，也就是说调用<code>require &quot;a.b&quot;</code>会尝试打开<code>./a/b.lua</code>，<code>/usr/local/lua/a/b.lua</code>，<code>/usr/local/lua/a/b/init.lua</code>。通过这种加载策略，可以将包的所有模块组织到一个目录中。</p><p>参考文献：电子工业出版社《Lua程序设计（第2版）》第14-15章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua学习笔记（5）——迭代器，错误处理</title>
      <link href="/tech/language/lua/lua-note-5/"/>
      <url>/tech/language/lua/lua-note-5/</url>
      
        <content type="html"><![CDATA[<p>本文首先介绍如何编写适用于泛型for的迭代器，再介绍Lua的编译、执行与错误处理相关的内容。</p><a id="more"></a><h1 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1. 迭代器"></a>1. 迭代器</h1><h2 id="1-1-泛型for原理"><a href="#1-1-泛型for原理" class="headerlink" title="1.1 泛型for原理"></a>1.1 泛型for原理</h2><p>迭代器是一种可以遍历集合中所有元素的机制，在Lua中通常将迭代器表示为函数，每调用一次函数，就返回集合中“下一个”元素。每个迭代器都需要在每次成功调用之间保持一些状态，这样才能知道它所在的位置及如何步进到下一个位置，closure就可以完成此项工作。下面的示例是列表的一个简单的迭代器：</p><pre><code>function values(t)    local i = 0    return function() i = i + 1; return t[i] endend-- 循环调用t = {10, 20, 30}iter = values(t)while true do    local el = iter()    if el == nil then break end    print(el)end-- 泛型for调用for el in values(t) do print(el) end</code></pre><p>泛型for为一次迭代循环做了所有的簿记工作。它在内部保存了迭代器函数，并在每次迭代时调用迭代器，在迭代器返回nil时结束循环。实际上泛型for保存了3个值：迭代器函数f、恒定状态s、控制变量a。<strong>for做的第一件事就是对in后面的表达式求值，并返回3个值供for保存；接着for会以s和a来调用f。在循环过程中控制变量的值依次为<code>a1 = f(s, a0)</code>，<code>a2 = f(s, a1)</code>，依次类推，直至ai为nil结束循环。</strong></p><h2 id="1-2-迭代器的状态"><a href="#1-2-迭代器的状态" class="headerlink" title="1.2 迭代器的状态"></a>1.2 迭代器的状态</h2><p>无状态的迭代器本身不保存任何状态，for循环只会用恒定状态和控制变量来调用迭代器函数。这类迭代器典型例子就是ipairs，下面是ipairs的Lua实现：</p><pre><code>local function iter(s, i)    i = i + 1    local v = s[i]    if v then return i, v endendfunction ipairs(s)    return iter, s, 0end</code></pre><p>当for循环调用ipairs(list)时，会获得3个值，然后Lua调用iter(list, 0)得到list, list[1]，调用iter(list, 1)得到list, list[2]，知道得到一个nil为止。</p><p>虽然泛型for只提供一个恒定状态和一个控制变量用于状态的保存，但有时需要保存许多其他状态。这时可以用closure来保存，或者将所需的状态打包为一个table，并保存在恒定状态中。</p><h1 id="2-编译与错误机制"><a href="#2-编译与错误机制" class="headerlink" title="2. 编译与错误机制"></a>2. 编译与错误机制</h1><h2 id="2-1-编译"><a href="#2-1-编译" class="headerlink" title="2.1 编译"></a>2.1 编译</h2><p>尽管Lua是一种解释型语言，但它确实允许在运行代码前，先将代码预编译为一种中间形式。其实，<strong>区别解释型语言的主要特征并不在于是否能编译它们，而在于编译器是否是语言运行时库的一部分，即是否有能力执行动态生成的代码。</strong>可以说正因为存在了诸如<code>dofile</code>这样的函数，才可以将Lua称为解释型语言。</p><p><code>dofile</code>用于运行Lua代码块，而<code>loadfile</code>会从一个文件加载Lua代码块，然后编译代码，把编译结果作为一个函数返回。要注意<code>loadfile</code>不会引发错误，它只是返回错误值但不处理错误。<code>dofile</code>的基本原理如下：</p><pre><code>function dofile(filename)    local f = assert(loadfile(filename))    return f()end</code></pre><p><code>loadstring</code>是从一个字符串读取代码，并返回一个对应的函数。注意，<code>loadstring</code>总是在全局环境中编译它的字符串。此外，这些函数不会带来任何副作用，它们只是将程序块编译为一种中间表示，然后将结果作为一个匿名函数返回。此时如果不将此匿名函数赋值给一个变量并调用，是不会产生任何结果的。</p><h2 id="2-2-错误处理与异常"><a href="#2-2-错误处理与异常" class="headerlink" title="2.2 错误处理与异常"></a>2.2 错误处理与异常</h2><p>Lua遇到任何非预期条件都会引发一个错误，我们也可以显式地调用<code>error</code>函数并传入一个错误消息得参数来引发一个错误。像<code>if not &lt;condition&gt; then error(&lt;anything&gt;) end</code>这样的组合是非常通用的代码，所以可以用<code>assert(&lt;condition&gt;, &lt;msg&gt;)</code>来完成此类工作。另外一种处理的方式是返回错误代码（如nil）。</p><p><code>pcall</code>函数以一种“保护模式”来调用它的第一个参数，并捕获所有执行中引发的错误。如果没有发生错误，pcall会返回true及函数调用的返回值，否则返回false及错误消息。因此可以用error来抛出一个异常或使用pcall来捕获异常，错误消息则可以标识出错误的类型或内容。</p><pre><code>if pcall(function()    &lt;受保护的代码&gt;end) then    &lt;常规代码&gt;else    &lt;错误处理代码&gt;end</code></pre><h2 id="2-3-追溯错误"><a href="#2-3-追溯错误" class="headerlink" title="2.3 追溯错误"></a>2.3 追溯错误</h2><p>当<code>pcall</code>返回其错误消息时，它已经销毁了调用栈的部分内容（pcall到错误发生点之间的这部分调用）。而<code>xpcall</code>函数除了接受一个需要被调用的函数外，还接受一个<em>错误处理函数</em>。当发生错误时，Lua会在调用栈展开前调用这个错误处理函数，里面可以用debug库来获取错误的额外信息。如<code>debug.debug</code>会提供一个Lua提示符，让用户检查错误原因，<code>debug.traceback</code>获取当前执行的调用栈。</p><p>参考文献：电子工业出版社《Lua程序设计（第2版）》第7-8章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua学习笔记（4）——函数</title>
      <link href="/tech/language/lua/lua-note-4/"/>
      <url>/tech/language/lua/lua-note-4/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了Lua的函数，包括多重返回值、变长参数、具名实参，以及比较高级的主题如闭包、递归的尾调用等等。</p><a id="more"></a><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><p>调用函数都需要写圆括号，即使没有参数，但有一种特殊例外：函数若只有一个参数且参数是字面字符串或table构造式，则圆括号可有可无，如<code>dofile &#39;a.lua&#39;</code>，<code>f{x=10, y=20}</code>。</p><p>Lua为面向对象式的调用提供冒号操作符的特殊语法，如<code>o.foo(o, x)</code>等价于<code>o:foo(x)</code>。和Javascript类似，调用函数时提供的实参数量可以与形参数量不同，若实参多了则舍弃，不足则多余的形参初始化为nil。</p><h2 id="1-1-多重返回值"><a href="#1-1-多重返回值" class="headerlink" title="1.1 多重返回值"></a>1.1 多重返回值</h2><p>Lua允许函数返回多个结果，函数返回如<code>return max, index</code>，接收如<code>s, e = string.find(&quot;hello Lua world&quot;, &quot;Lua&quot;)</code>。如果一个函数调用不是一系列表达式的最后一个元素，则只产生一个值：</p><pre><code>function foo() return &quot;a&quot;, &quot;b&quot; endx, y = foo(), 20    -- x=&quot;a&quot;, y=20（foo的第二个返回值被丢弃）print(foo() .. &quot;x&quot;)    -- 输出ax，这是因为当函数出现在一个表达式中时，Lua会将其返回值数量调整为1</code></pre><p>另外，只有当一个函数调用作为最后一个元素时，返回值才不会被调整，在其他位置都会被调整为1个，如<code>t = {foo2()}</code>则t={“a”, “b”}，<code>t = {foo2(), 4}</code>则t={“a”, 4}。</p><p>特殊函数unpack接受一个数组作为参数，并从下标1开始返回该数组的所有元素，如<code>a, b = unpack({10, 20, 30})</code>，则30被丢弃。unpack的一项重要用途体现在“泛型调用”机制中。</p><h2 id="1-2-变长参数"><a href="#1-2-变长参数" class="headerlink" title="1.2 变长参数"></a>1.2 变长参数</h2><p>函数参数表中3个点（…）表示该函数可接受不同数量的实参。<strong>在Lua 5.0中，没有提供“…”表达式，如果要遍历变长参数，可以访问函数内隐含的局部变量<code>arg</code>。</strong>如果还有固定参数，则必须放在变长参数之前。</p><h1 id="2-高级主题"><a href="#2-高级主题" class="headerlink" title="2. 高级主题"></a>2. 高级主题</h1><h2 id="2-1-closure闭合函数"><a href="#2-1-closure闭合函数" class="headerlink" title="2.1 closure闭合函数"></a>2.1 closure闭合函数</h2><p>和Javascript的闭包基本是一个东西，此处不再赘述。从技术上说，Lua中只有closure，而不存在“函数”，因为函数本身就是一种特殊的closure。closure的应用很广泛，如用于高阶函数的参数、为GUI工具包创建回调、重定义函数并在新实现中调用旧实现、创建“沙盒”安全运行环境等等。</p><h2 id="2-2-非全局的函数"><a href="#2-2-非全局的函数" class="headerlink" title="2.2 非全局的函数"></a>2.2 非全局的函数</h2><p>大部分Lua库都采用了将函数存储在table中的机制（如io.read，math.sin），例如下面采用了三种方式来定义table的成员函数：</p><pre><code>MathLib = {    plus = function(x, y) return x + y end}MathLib.minus = function(x, y) return x - y endfunction MathLib.multiply(x, y) return x * y end</code></pre><p>局部函数的定义：</p><pre><code>local f = function(&lt;参数&gt;) &lt;函数体&gt; endlocal function f(&lt;参数&gt;) &lt;函数体&gt; end  -- Lua提供的语法糖</code></pre><p>**注意如果定义递归函数，不能使用上面第一种定义方式（因为在函数体调用f时，f尚未定义完毕），使用第二种“语法糖”则没问题；或者使用“前向声明”，先<code>local f</code>再<code>f = function ...</code>这样定义。</p><h2 id="2-3-正确的尾调用"><a href="#2-3-正确的尾调用" class="headerlink" title="2.3 正确的尾调用"></a>2.3 正确的尾调用</h2><p>当一个函数调用时另一个函数的最后一个动作时，该调用算是一条“尾调用”，例如<code>function f(x) return g(x) end</code>。由于在尾调用后程序不要保存任何关于该函数的栈信息，所以递归调用不会耗费栈空间，可以递归调用无数次。有一些看似是“尾调用”的代码，其实都违背了这条准则：</p><pre><code>function f(x) g(x) end    -- 调用g后，f没有立即返回，还需要丢弃g返回的临时结果function f(x) return g(x) + 1    -- 还要做一次加法function f(x) return x or g(x)    -- 必须调整为一个返回值</code></pre><p>所以，只有形如<code>return &lt;func&gt;(&lt;args&gt;)</code>这样的调用形式才算是尾调用。</p><p>参考文献：电子工业出版社《Lua程序设计（第2版）》第5-6章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记——用户及文件权限管理</title>
      <link href="/tech/linux/linux-user-and-file-manage/"/>
      <url>/tech/linux/linux-user-and-file-manage/</url>
      
        <content type="html"><![CDATA[<p>Linux是一个可以实现多用户登录的操作系统，本文记录了Linux的用户管理，包括查看、创建用户和用户组，以及文件的权限机制。</p><a id="more"></a><p>Linux是一个可以实现多用户登录的操作系统，比如李雷和韩梅梅都可以同时登陆同一台主机，他们共享一些主机的资源，但他们也分别有自己的用户空间，用于存放各自的文件。实际上他们的文件都是放在同一个物理磁盘上的甚至同一个逻辑分区或者目录里，但他们互相不可以看到或操作对方的文件，这正是Linux用户管理和权限机制。</p><h1 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h1><h2 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h2><p>直接使用<code>whoami</code>命令可以查看当前登录用户的用户名，此外还有<code>who</code>命令可以查看更多详细的信息。</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>root权限，是系统权限的一种。root是Linux和unix系统中的超级管理员用户帐户，该帐户拥有整个系统至高无上的权力，所有对象他都可以操作，所以很多黑客在入侵系统的时候，都要把权限提升到root权限。root账户就相当于Linux的“上帝”。</p><p>一般登录系统时都是以普通账户的身份登录的（即“凡人”）。如果要添加一个用户（上帝造人），那么需要“借用”一下上帝的权力，即使用<code>sudo</code>命令。使用这个命令有两个大前提，一是你要知道当前登录用户的密码，二是<strong>当前用户必须在sudo用户组</strong>。</p><ol><li><code>sudo adduser &lt;user&gt;</code>：创建一个新用户（默认会自动创建一个同名的用户组），同时会在<code>/home</code>目录下创建一个对应的文件夹</li><li><code>su -l &lt;user&gt;</code>：切换登录用户</li><li><code>exit</code>（或CTRL+D）：退出当前登录用户</li></ol><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>在linux里面每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源。一个用户可以属于多个用户组。</p><ol><li><code>groups &lt;user&gt;</code>：查看user属于哪个用户组。输出内容冒号之前表示用户，之后表示该用户所属的用户组。</li><li><code>cat /etc/group |sort</code>：输出如下所示。<code>/etc/group</code>文件内容包括用户组（Group）、用户组口令、GID及该用户组所包含的用户（User），每个用户组一条记录。格式为<code>group_name:password:GID:user_list</code>，其中密码字段为<em>表示密码不可见。<br> daemon:</em>:1:root<br> kmem:<em>:2:root<br> sys:</em>:3:root ……</li><li><code>usermod -G &lt;group&gt; &lt;user&gt;</code>：为用户添加用户组（需要root权限）。可以用这个命令把用户加入sudo组，这样这个用户就能借用root权限。</li><li><code>deluser &lt;user&gt; --remove-home</code>：删除用户（需要root权限）。<code>--remove-home</code>参数表示连带删除home目录下的文件夹。</li></ol><h1 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h1><p><code>ls</code>命令可以列出当前文件夹的文件，附带参数说明如下：</p><ul><li><code>-l</code>：以较详细的格式列出文件（如下所示）</li><li><code>-A</code>：显示除了<code>.</code>(当前目录)，<code>..</code>上一级目录之外的包含隐藏文件的所有文件（Linux下以<code>.</code>开头的文件为隐藏文件）</li><li><code>-dl &lt;dir&gt;</code>：查看某一个目录的完整属性，而不是显示目录里面的文件属性</li><li><p><code>-sSh</code>：小s为显示文件大小，大S为按文件大小排序，h显示所有文件大小，并以普通人类能看懂的方式呈现</p><p>  drwxr-xr-x@   11 root  wheel      374  1 25 22:23 usr</p></li></ul><p>从左到右依次是：文件类型和权限，链接数，所有者，所属用户组，文件大小，最后修改时间，文件名。</p><p>1、文件类型和权限（drwxr-xr-x@）</p><p>第1位d表示文件类型。其余文件类型有：</p><ul><li>d：目录</li><li>l：软链接</li><li>b：块设备</li><li>c：字符设备</li><li>s：Socket</li><li>p：管道</li><li>-：普通文件</li></ul><p>后面9位每3个1组，分为3组，分别是拥有者权限、所属用户组权限、其他用户权限，字符的意义是：</p><ul><li>r：允许读权限，比如可以使用<code>cat &lt;file name&gt;</code>之类的命令来读取某个文件的内容</li><li>w：允许写权限，表示你可以编辑和修改某个文件</li><li>x：允许执行权限，通常指可以运行的二进制程序文件或者脚本文件。Linux上不是通过文件后缀名来区分文件的类型。注意：<strong>一个目录要同时具有读权限和执行权限才可以打开，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</strong></li></ul><p>2、链接数</p><p>链接到该文件所在的inode结点的文件名数目（关于这个概念涉及到linux文件系统的相关概念知识，自行查阅）</p><p>3、文件大小</p><p>以inode结点大小为单位来表示的文件大小，可以给ls加上<code>-h</code>参数（表示，这才是给人看的）来更直观的查看文件的大小</p><p>使用<code>chown &lt;param&gt; &lt;file&gt;</code>命令可以修改文件file权限（需要root权限）。其中参数param可以是二进制形式，也可以是加减赋值操作形式。</p><p>二进制形式如<code>chown 755 some_file</code>，参数中3个数字分别表示拥有者，所属用户组，其他用户的权限值。权限值的计算由r、w、x决定，有权限为1，无权限为0，由二进制加权所得，如7代表rwx，5代表r-x。</p><p>加减赋值操作形式如<code>chmod go-rw some_file</code>，’g’’o’还有’u’，分别表示group，others，user,’+’,’-‘就分别表示增加和去掉相应的权限。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记——基本概念及操作</title>
      <link href="/tech/linux/linux-base/"/>
      <url>/tech/linux/linux-base/</url>
      
        <content type="html"><![CDATA[<p>本文记录了Linux终端的一些常用快捷键，通配符意义及如何在命令行中获取帮助。</p><a id="more"></a><h1 id="Linux终端"><a href="#Linux终端" class="headerlink" title="Linux终端"></a>Linux终端</h1><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table><thead><tr><th style="text-align:left">按键</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">Ctrl+d</td><td style="text-align:left">键盘输入结束或退出终端</td></tr><tr><td style="text-align:left">Ctrl+s</td><td style="text-align:left">暂定当前程序，暂停后按下任意键恢复运行</td></tr><tr><td style="text-align:left">Ctrl+z</td><td style="text-align:left">将当前程序放到后台运行，恢复到前台为命令fg</td></tr><tr><td style="text-align:left">Ctrl+a</td><td style="text-align:left">将光标移至输入行头，相当于Home键</td></tr><tr><td style="text-align:left">Ctrl+e</td><td style="text-align:left">将光标移至输入行末，相当于End键</td></tr><tr><td style="text-align:left">Ctrl+k</td><td style="text-align:left">删除从光标所在位置到行末</td></tr><tr><td style="text-align:left">Alt+Backspace</td><td style="text-align:left">向前删除一个单词</td></tr><tr><td style="text-align:left">Shift+PgUp</td><td style="text-align:left">将终端显示向上滚动</td></tr><tr><td style="text-align:left">Shift+PgDn</td><td style="text-align:left">将终端显示向下滚动</td></tr></tbody></table><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>终端里面输入的通配符是由shell处理的，不是由所涉及到命令语句处理的，它只会出现在命令的“参数值”里。当shell在“参数值”中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换（路径扩展）；否则就将该通配符作为一个普通字符传递给“命令”，然后再由命令进行处理。总之，通配符 实际上就是一种shell实现的路径扩展功能。在通配符被处理后，shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。</p><p>例如：<code>touch love_{1..10}_linux.txt</code>可以创建love_1_linux.txt到love_10_linux.txt共10个文件。</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">匹配0 或多个字符</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配任意一个字符</td></tr><tr><td style="text-align:left">[list]</td><td style="text-align:left">匹配 list 中的任意单一字符</td></tr><tr><td style="text-align:left">[!list]</td><td style="text-align:left">匹配 除list 中的任意单一字符以外的字符</td></tr><tr><td style="text-align:left">[c1-c2]</td><td style="text-align:left">匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]</td></tr><tr><td style="text-align:left">{string1,string2,…}</td><td style="text-align:left">匹配 sring1 或 string2 (或更多)其一字符串</td></tr><tr><td style="text-align:left">{c2..c2}</td><td style="text-align:left">匹配 c1-c2 中全部字符 如{1..10}</td></tr></tbody></table><h2 id="在命令行中获取帮助"><a href="#在命令行中获取帮助" class="headerlink" title="在命令行中获取帮助"></a>在命令行中获取帮助</h2><p><code>$ man &lt;command_name&gt;</code>可以获得某个命令的说明和使用方式的详细介绍。<code>man</code>命令是Manual page的缩写。使用这个命令显示手册时会进入一个类似VIM的编辑界面，可以使用VIM的快捷键来导航，如<code>/&lt;你要搜索的关键字&gt;</code>，查找到后你可以使用<code>n</code>键切换到下一个关键字所在处，<code>shift+n</code>为上一个关键字所在处。使用<code>Space</code>翻页，<code>Enter</code>向下滚动一行，或者使用<code>j</code>或<code>k</code>（vim编辑器的移动键）进行向前向后滚动一行。按下<code>h</code>键为显示使用帮助(因为man使用less作为阅读器，实为less工具的帮助)，按下<code>q</code>退出。</p><p>man手册的内容很多，为了便于查找，是做了分册（分区段）处理的，在Research Unix、BSD、OS X和Linux中，手册通常被分为8个区段，安排如下：</p><ol><li>一般命令</li><li>系统调用</li><li>库函数，涵盖了C标准函数库</li><li>特殊文件（通常是/dev中的设备）和驱动程序</li><li>文件格式和约定</li><li>游戏和屏保</li><li>杂项</li><li>系统管理命令和守护进程</li></ol><p>要查看相应区段的内容，就在man后面加上相应区段的数字即可，如：<code>$ man 3 printf</code></p><p>所有的手册页遵循一个常见的布局，其为通过简单的ASCII文本展示而优化，而这种情况下可能没有任何形式的高亮或字体控制。一般包括以下部分内容：</p><ul><li>NAME（名称）：该命令或函数的名称，接着是一行简介。</li><li>SYNOPSIS（概要）：对于命令，正式的描述它如何运行，以及需要什么样的命令行参数。对于函数，介绍函数所需的参数，以及哪个头文件包含该函数的定义。</li><li>DESCRIPTION（说明）：命令或函数功能的文本描述。</li><li>EXAMPLES（示例）：常用的一些示例。</li><li>SEE ALSO（参见）：相关命令或函数的列表。</li></ul><p>想要获得更详细的帮助，你还可以使用info命令，不过通常使用man就足够了。如果你知道某个命令的作用，只是想快速查看一些它的某个具体参数的作用，那么你可以使用–help参数，大部分命令都会带有这个参数。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Io语言特性（下）</title>
      <link href="/tech/language/other/io-language-2/"/>
      <url>/tech/language/other/io-language-2/</url>
      
        <content type="html"><![CDATA[<p>本文将接着上一篇<a href="/tech/language/other/io-language-1/">《Io语言特性（上）》</a>，讲述Io语言的消息，反射和并发。</p><a id="more"></a><h1 id="1-消息"><a href="#1-消息" class="headerlink" title="1. 消息"></a>1. 消息</h1><h2 id="1-1-消息反射与call方法"><a href="#1-1-消息反射与call方法" class="headerlink" title="1.1 消息反射与call方法"></a>1.1 消息反射与call方法</h2><p>Io语言中除了注释符和参数之间的逗号外，<strong>一切事物都是消息</strong>。消息反射是Io一项很重要的能力，可以通过反射查询任何消息的任何特性，再对它们执行适当的操作。</p><p>消息由三部分组成：发送者（sender）、目标（target）和参数（arguments），消息由发送者发送至目标，然后由目标执行该消息。可以用<code>call</code>方法访问任何消息的元信息。</p><pre><code>Io&gt; postOffice := Object clone// 下面的各个方法可以获取消息的各种元信息Io&gt; postOffice packageSender := method(call sender)Io&gt; postOffice messageTarget := method(call target)Io&gt; postOffice messageArgs := method(call message arguments)Io&gt; postOffice messageName := method(call message name)// 定义一个可以发送消息的mailer对象Io&gt; mailer := Object clone==&gt; Object_0x1005bfda0    // 注意这里尾号为0bfda0是mailer对象Io&gt; mailer deliver := method(postOffice packageSender)Io&gt; mailer deliver==&gt; Object_0x1005bfda0:  deliver = method(...)    // 可以看出消息发送者是deliver方法Io&gt; postOffice messageTarget==&gt; Object_0x1004ce658:  messageTarget = method(...)  packageSender = method(...)   // 从槽名可以看出消息目标是postOfficeIo&gt; postOffice messageArgs(&quot;one&quot;, 2, :three)==&gt; list(&quot;one&quot;, 2, :three)    // 直接输出了参数Io&gt; postOffice messageName==&gt; messageName    // 消息本身的名字</code></pre><p>大多数语言都将参数作为栈上的值传递，例如Java在调用方法时先计算参数的每个值，然后把值放到栈上。Io就不是这样，Io传递的事消息本身和上下文，再由接收者对消息求值。Io的if，形式是<code>if(booleanExpression, trueBlock, falseBlock)</code>，现在如果要再实现一个<code>unless</code>，实现方法可以是下面这样：</p><pre><code>// 这种方法是不行的，因为调用unless的时候，else和then都会被马上执行，实际我们需要的是当cond为true时，执行else，否则执行thenObject unless := method(cond, then, else,    if(cond, else, then))// 正确的延迟执行实现Object unless := method(    (call sender doMessage(call message argAt(0))) ifFalse(    call sender doMessage(call message argAt(1))) ifTrue(    call sender doMessage(call message argAt(2)))}unless(1 == 2, write(&quot;One is not two\n&quot;), write(&quot;one is two\n&quot;))  // 输出One is not two</code></pre><p>上面代码中的<code>doMessage</code>可以执行任意消息，有点类似于其他语言里面的<code>eval</code>。Io会对消息参数进行解释，但会延迟绑定和执行。</p><h2 id="1-2-对象反射"><a href="#1-2-对象反射" class="headerlink" title="1.2 对象反射"></a>1.2 对象反射</h2><p>下面的代码给Object定义了一个ancestors方法，这个方法会沿着原型链向上查找，输出每个原型的名称以及带有的槽名，直到Object为止。</p><pre><code>Object ancestors := method(    prototype := self proto    if(prototype != Object,        writeln(&quot;Slots of &quot;, prototype type, &quot;\n------------&quot;)        prototype slotNames foreach(slotName, writeln(slotName))        writeln        prototype ancestors    ))</code></pre><p>1.1的例子是消息反射的例子，处理消息的发送者、目标和消息体；这个例子是对象反射的例子，处理对象和对象的槽。</p><h1 id="2-其他特性"><a href="#2-其他特性" class="headerlink" title="2. 其他特性"></a>2. 其他特性</h1><h2 id="2-1-领域特定语言（DSL）"><a href="#2-1-领域特定语言（DSL）" class="headerlink" title="2.1 领域特定语言（DSL）"></a>2.1 领域特定语言（DSL）</h2><p>Io在定义DSL方面的能力非常强大，据说用Io实现C语言的一个子集仅需约40行代码！Io提供了非常多的控制方法来解析语言本身。假如我们想要解析一个普通的<code>test.json</code>文件：</p><pre><code>{    &quot;name&quot;: &quot;Ray Taylor&quot;,    &quot;lucky_numbers&quot;: [33, 6],    &quot;job&quot;: {        &quot;title&quot;: &quot;Web Front End Developer&quot;    }}</code></pre><p>如果是其他语言的话，可能会写一个语法分析器识别上面这段文本中不同元素，然后生成一个Io可理解的结构。但通过Io的强大特性，我们可以通过下面这段代码对Io做些改动（注释中已包含完整的解释），改动完之后Io就会认为上面这段文本的语法是正确的，并且构建出相应的散列表来。</p><pre><code>// 把一个“:”运算符添加到Io的赋值运算符表中，现在只要Io代码遇到“:”，就会把它转换成atPutNumber。所以遇到key:value时就会转换成atPutNumber(&quot;key&quot;, value)OperatorTable addAssignOperator(&quot;:&quot;, &quot;atPutNumber&quot;)  // Io代码遇到大括号（{}），就会调用curlyBrackets方法curlyBrackets := method(    // 创建一个空散列表，供存放数据    data := Map clone    // call message正是json大括号中的代码，arguments则是由逗号“,”分隔的参数列表。循环遍历参数列表就相当于处理json对象中的每一行    call message arguments foreach(arg,        // 以第1个arg（&quot;name&quot;: &quot;Ray Taylor&quot;）举例，data doMessage(arg)相当于执行data &quot;name&quot;: &quot;Ray Taylor&quot;，冒号翻译成atPutNumber，所以代码就相当于data atPutNumber(&quot;name&quot;, &quot;Ray Taylor&quot;)        data doMessage(arg)    )    // 最后相当于把data返回    data)// 解析中括号（[]），原理跟上面的基本一样，不再赘述squareBrackets := method(    arr := list()    call message arguments foreach(arg,        arr push(call sender doMessage(arg))    )    arr)  // 在Map对象上扩展一个atPutNumberMap atPutNumber := method(    // 其实算法的核心就是调用Map atPut槽    self atPut(        // 注意key:value总是会转换为atPutNumber(&quot;key&quot;, value)（key有字符串包围），所以要去掉原key的头尾字符串。由于消息是不可变的，为了去掉引号，要使用asMutable转化为一个可变值        call evalArgAt(0) asMutable removePrefix(&quot;\&quot;&quot;) removeSuffix(&quot;\&quot;&quot;),        call evalArgAt(1)    ))  // File是Io与文件交互的原型，with指定了文件名并返回一个文件对象，openForReading打开该文件并返回该文件对象，而contents返回该文件的内容s := File with(&quot;test.json&quot;) openForReading contents// doString把字符串求值为Io代码json := doString(s)json at(&quot;name&quot;) println  // Ray Taylorjson at(&quot;lucky_numbers&quot;) println  // list(6, 13)json at(&quot;job&quot;) at(&quot;title&quot;) println   // Web Front End Developer</code></pre><p>从上面的例子可以看到Io中可以随心所欲把运算符重定义为组成DSL的符号，从而改变Io的语法。</p><h2 id="2-2-forward方法"><a href="#2-2-forward方法" class="headerlink" title="2.2 forward方法"></a>2.2 forward方法</h2><p><strong>当你把消息发送给对象时，对象会计算所有参数（参数其实就是消息），获取消息的名称、目标和发送者，然后尝试用目标上的消息名称读取槽。如果槽存在，则返回其数据或触发其包含的方法；否则把消息转发给原型。</strong>当槽名不存在时，实际会调用系统的forward方法把消息转发给原型，这有点类似Ruby的method_missing，但因为Io没有类，所以改变forward会改变从Object获得基本行为的方式。所以覆盖forward方法的风险要更高一些，但如果用得恰当，会产生非常巧妙的效果。</p><p>下面的代码将构造一种新语法来对XML进行处理。这种新语法及对应的XML如图所示：</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/Script/利用Io代码来表示XML.png" alt="利用Io代码来表示XML"></p><pre><code>Builder := Object clone// 覆盖forward，使其可以接收任意方法Builder forward := method(    // 使用消息反射，输出开标签    writeln(&quot;&lt;&quot;, call message name, &quot;&gt;&quot;)    // 遍历消息的每个参数    call message arguments foreach(arg,        // 递归调用        content := self doMessage(arg);        // 如果消息是个字符串（字符串的类型是Sequence序列），则直接输出        if(content type == &quot;Sequence&quot;, writeln(content))    )    // 使用消息反射，输出闭标签    writeln(&quot;&lt;/&quot;, call message name, &quot;&gt;&quot;))Builder ul(          li(&quot;Io&quot;),          li(&quot;Lua&quot;),          li(&quot;Javascript&quot;))   // 输出看起来像HTML ul和li标签的内容</code></pre><p>虽然这种新语法未必比传统的XML有多大程度的提高，但这例子还是很有指导意义。你可以完全改变一个Io原型的继承运行机制，甚至定义自己的Object原型，并以这个新对象为基础创建其他原型，从而创建出一门和Io行为截然不同的新语言。</p><h2 id="2-3-并发"><a href="#2-3-并发" class="headerlink" title="2.3 并发"></a>2.3 并发</h2><h3 id="2-3-1-协程"><a href="#2-3-1-协程" class="headerlink" title="2.3.1 协程"></a>2.3.1 协程</h3><p>协程是并发的基础，它提供了进程的自动挂起和恢复执行的机制。可以把协程想象为带有多个入口和出口的函数，每次遇到<code>yield</code>都会自动挂起当前进程，把控制权转到另一进程中。通过在消息前加上@或@@，可以异步触发消息，前者返回future（下文讲述），后者返回nil，并在其自身线程中触发消息。</p><pre><code>lilei := Object clonelilei talk := method(    &quot;Hello.&quot; println    yield    &quot;Fine, thank you. And you?&quot; println    yield)hanmeimei := Object clonehanmeimei talk := method(    yield    &quot;How are you?&quot; println    yield    &quot;I am fine, thanks.&quot; println)// 异步触发两个人的方法lilei @@talk; hanmeimei @@talk// 这一行用来等待所有异步消息执行完毕，然后退出程序Coroutine currentCoroutine pause</code></pre><p>上面这段程序不难理解。通过异步触发两个人的talk，使两个不相干的Object实例并发执行，用yield消息在指定时刻自动把控制权交给另一方法，从而让两个需要彼此协作的进程轻松实现“对话”任务。</p><h3 id="2-3-2-actor"><a href="#2-3-2-actor" class="headerlink" title="2.3.2 actor"></a>2.3.2 actor</h3><p>actor是通用的并发原语，它可以发送消息、处理消息以及创建其它actor。actor接收到的消息是并发的。一个actor改变其自身的状态，并通过严格控制的队列接触其它actor</p><p>参考资料：《七周七语言》第3章Io</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> 其它语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Io language </tag>
            
            <tag> 编程范型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Io语言特性（上）</title>
      <link href="/tech/language/other/io-language-1/"/>
      <url>/tech/language/other/io-language-1/</url>
      
        <content type="html"><![CDATA[<p>Io同Javascript、Lua一样，是一种原型语言，这意味着每个对象都是另一个对象的复制品。如今的大多数Io社区，都致力于把这门语言作为带有微型虚拟机和丰富并发特性的可嵌入语言来推广。它的简单语法和原型编程模型都值得我们重点关注，在了解Io之后，也可以让你对Javascript的运行机制的理解变得更透彻。</p><a id="more"></a><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><h2 id="1-1-创建对象"><a href="#1-1-创建对象" class="headerlink" title="1.1 创建对象"></a>1.1 创建对象</h2><p>面向对象语言中，通常都是通过对某个类调用new创建一个新对象，但在原型语言Io中，不区分类和对象，而是通过复制现有对象创建新对象，现有对象就是原型。</p><pre><code>Io&gt; &quot;Hello, io&quot; print    // 输出Hello, ioIo&gt; Vehicle := Object clone==&gt; Vehicle_0x1003b61f8:  type = &quot;Vehicle&quot;Io&gt; Vehicle description := &quot;Something to take you places&quot;==&gt; &quot;Something to take you places&quot;// Vehicle nonexistingSlot = &quot;This won&apos;t work&quot; 对不存在的槽使用=号赋值会报错Io&gt; Vehicle description==&gt; Something to take you placesIo&gt; Vehicle slotNames==&gt; list(&quot;type&quot;, &quot;description&quot;)</code></pre><ol><li>把print消息发送给字符串就可以输出那个字符串，Io中所有的操作都是发送消息，接收者在左边，消息在右边。</li><li>Object是根对象，我们发送clone消息过去，它会返回一个新对象，并将其赋值给Vehicle。注意这里的Vehicle不是类，也不是创建对象的模板，而是实实在在的对象。</li><li>对象还带有槽（slot），可以把一组槽想象成散列表，通过键可以引用到任何一个槽；可以用<code>:=</code>或<code>=</code>给槽赋值，当槽不存在时，前者可以创建出一个槽，后者则会抛出一个异常。</li><li>通过向对象发送槽的名字，可以获取槽中的值。<code>slotNames</code>槽是内置的，可以获取一个槽名列表。</li></ol><h2 id="1-2-原型和继承"><a href="#1-2-原型和继承" class="headerlink" title="1.2 原型和继承"></a>1.2 原型和继承</h2><p>继续上面的代码：</p><pre><code>Io&gt; Car := Vehicle cloneIo&gt; Car slotNames==&gt; list(&quot;type&quot;)Io&gt; Car description==&gt; &quot;Something to take you places&quot;  // Car没有description槽，所以Io把description消息转发给Car的原型Vehicle，并在Vehicle中找到这个槽Io&gt; ferrari := Car cloneIo&gt; ferrari slotNames==&gt; list()  // 这下连type槽都没了，因为依照Io的惯例，其类型应以大写字母开头Io&gt; ferrari type==&gt; Car  // 去父对象调用type槽，得到原型的类型</code></pre><p>以大写字母开头的对象时类型，具有type槽，而类型的复制品则以小写字母开头。注意：<strong>类型仅仅是帮助Io程序员更好地组织代码的工具，不管是大写开头还是小写开头，它们统统都是对象，Io中没有类。</strong></p><pre><code>Io&gt; method(&quot;I&apos;m method.&quot; println)  // 创建一个方法==&gt; method(...)Io&gt; method() type  // 方法也是对象，因此可以获取其类型==&gt; BlockIo&gt; Car drive := method(&quot;Vroom&quot; println)  // 方法可以赋值给一个槽==&gt; method(...)Io&gt; ferrari drive  // 调用槽就会调用对应方法Vroom==&gt; VroomIo&gt; ferrari getSlot(&quot;drive&quot;)  // getSlot可以获取槽的内容Io&gt; ferrari proto  // proto槽输出该对象的原型信息==&gt; Vehicle_0x1003b61f8: ...Io&gt; Lobby  // Lobby是主命名空间，包含所有已命名对象==&gt; Object_0x1002184e0: ...</code></pre><h2 id="1-3-集合"><a href="#1-3-集合" class="headerlink" title="1.3 集合"></a>1.3 集合</h2><p>Io有几种类型的集合：List列表对象是任意类型对象的有序集合，Map对象时键值对的原型，如同Ruby的散列表一样。</p><pre><code>Io&gt; todos := list(1, 2, 3)  // 由Object对象的list方法可以把传入参数包装起来创建列表Io&gt; todos size  // 获取列表大小Io&gt; todos append(4)  // 追加元素Io&gt; elvis := Map clone  // 映射没有语法糖，所以只能从Map clone出来Io&gt; elvis atPut(&quot;home&quot;, &quot;Graceland&quot;)  // 创建一个键值对Io&gt; elvis at(&quot;home&quot;) ==&gt; GracelandIo&gt; elvis asObject  // 将散列表转换为对象，key则相应转换为对象的槽</code></pre><h2 id="1-4-true、false、nil和单例"><a href="#1-4-true、false、nil和单例" class="headerlink" title="1.4 true、false、nil和单例"></a>1.4 true、false、nil和单例</h2><p>Io条件判断和其他语言基本一致，都有<code>true</code>、<code>false</code>、<code>and</code>、<code>or</code>等关键字。注意：和Ruby一样0是true。有趣的地方在于，调用<code>true clone</code>依旧会返回<code>true</code>，<code>false</code>和<code>nil</code>也一样，这三个东西都是单例，对它们进行复制，返回的就是单例对象本身的值。要创建一个单例非常简单：</p><pre><code>Singleton := Object cloneSingleton clone := Singleton</code></pre><p>通过重定义Singleton的clone槽，让其返回自身，而不是像往常那样让请求沿着对象原型链向上传递最终到达Object对象，这样就可以实现单例。Io也是一门灵活性极高的语言，例如<code>Object clone := &quot;broken&quot;</code>可以使得Io再也无法创建对象，这种情况无法修复，只能终止进程。同Ruby一样，高灵活性是一把双刃剑，但如果运用得好，完全可以用几行漂亮的代码就实现一些<em>领域特定语言</em>（domain-specific language, DSL）。</p><h1 id="2-基本控制结构"><a href="#2-基本控制结构" class="headerlink" title="2. 基本控制结构"></a>2. 基本控制结构</h1><h2 id="2-1-循环和条件"><a href="#2-1-循环和条件" class="headerlink" title="2.1 循环和条件"></a>2.1 循环和条件</h2><pre><code>Io&gt; loop(&quot;infinite loop&quot;, println)  // 无限循环输出，可以Ctrl+C中断Io&gt; while(i &lt;= 11, i println; i = i + 1)  // while循环接受2个参数，一个循环条件参数和一个用来求值的消息。分号可以把两个不同的消息连接起来Io&gt; for(i, 1, 11, 2, i println)  // 输出1 3 5 7 9 11// 控制结构以函数形式实现，形式为if(condition, true code, false code)Io&gt; if(true, &quot;true&quot;, &quot;false&quot;)==&gt; trueIo&gt; if(false) then(&quot;true&quot; println) else(&quot;false&quot; println)false==&gt; nil</code></pre><h2 id="2-2-运算符"><a href="#2-2-运算符" class="headerlink" title="2.2 运算符"></a>2.2 运算符</h2><p>在Io中，调用<code>OperatorTable</code>可以看到运算符表，可以看到赋值是另一种类型的运算符。运算符左边的数字代表优先级，参数优先绑定到优先级靠近0的运算符上。下面的代码自定义了一个运算符<code>xor</code>：</p><pre><code>Io&gt; OperatorTable addOperator(&quot;xor&quot;, 11)==&gt; OperatorTable_0x100296098Operators  ...  10 &amp;&amp; and  11 or xor ||  ...// 逻辑运算符相当于true或false的槽，用穷举法实现Io&gt; true xor := method(bool, if(bool, false, true))Io&gt; false xor := method(bool, if(bool, true, false))// 接下来就可以使用新定义的运算符了Io&gt; true xor true==&gt; falseIo&gt; false xor true==&gt; true</code></pre><p>最后对Io语言特性做一点小结：</p><ul><li>所有事物都是<strong>对象</strong></li><li>所有与对象交互的都是<strong>消息</strong></li><li>你要做的不是实例化类，而是复制那些叫<strong>原型</strong>的对象</li><li>对象会记住它的原型</li><li>对象有<strong>槽</strong></li><li>槽包含对象（包括方法)</li><li>消息返回槽中的值，或调用槽中的方法</li><li>若对象无法响应某消息，则把消息转发给自己的原型</li></ul><p>参考资料：《七周七语言》第3章Io</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> 其它语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Io language </tag>
            
            <tag> 编程范型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ruby语言特性（下）</title>
      <link href="/tech/language/other/ruby-language-2/"/>
      <url>/tech/language/other/ruby-language-2/</url>
      
        <content type="html"><![CDATA[<p>本文将接着上一篇<a href="/tech/language/other/ruby-language-1/">《Ruby语言特性（上）》</a>讲述Ruby语言的核心语言特性，包括Mixin、模块、开放类等等，并使用Ruby来定义自己的语法。这些特性都是重点和难点，透过这些特性可以感受到Ruby是一门灵活性极高的语言。</p><a id="more"></a><h1 id="1-模块与混入（Mixin）"><a href="#1-模块与混入（Mixin）" class="headerlink" title="1. 模块与混入（Mixin）"></a>1. 模块与混入（Mixin）</h1><p>面向对象语言利用继承，将行为传播到相似的对象上。若一个对象像继承多种行为，一种做法是用多继承，如C++；Java采用接口解决这一问题，Ruby采用模块Mixin。模块是函数和常量的集合，若在类中包含一个模块，那么该模块的行为和常量也会成为类的一部分。</p><pre><code># 定义模块ToFilemodule ToFile  # 获取文件名  def filename    &quot;object_name.txt&quot;  end  # 创建文件  def to_f    File.open(filename, &apos;w&apos;) {|f| f.write(to_s)}  # 注意这里to_s在其他地方定义！  endend# 定义用户类class Person  include ToFile  attr_accessor :name  def initialize(name)    @name = name  end  def to_s    name  endendPerson.new(&apos;matz&apos;).to_f  # 创建了一个文件object_name.txt，里面包含内容matz</code></pre><p>上面的代码很好理解，只是有一点要注意：<code>to_s</code>在模块中使用，在类中实现，但定义模块的时候，实现它的类甚至还没有定义。这正是鸭子类型的精髓所在。<strong>写入文件的能力，和Person这个类没有一点关系（一个类就应该做属于它自己的事情）</strong>，但实际开发又需要把Person类写入文件这种额外功能，这时候mixin就可以轻松胜任这种要求。</p><p>Ruby有两个重要的mixin：枚举（enumerable）和比较（comparable）。若想让类可枚举，必须实现each方法；若想让类可比较，必须实现<code>&lt;=&gt;</code>（太空船）操作符（比较a,b两操作数，返回1、0或-1）。Ruby的字符串可以这样比较：<code>&#39;begin&#39; &lt;=&gt; &#39;end =&gt; -1</code>。数组有很多好用的方法：</p><pre><code>a = [5, 3, 4, 1]a.sort =&gt; [1, 3, 4, 5]  # 整数已通过Fixnum类实现太空船操作符，因此可比较可排序a.any? {|i| i &gt; 4} =&gt; truea.all? {|i| i &gt; 0} =&gt; truea.collect {|i| i * 2} =&gt; [10, 6, 8, 2]a.select {|i| i % 2 == 0} =&gt; [4]a.member?(2) =&gt; falsea.inject {|product, i| product * i} =&gt; 60  # 第一个参数是代码块上一次执行的结果，若不设初始值，则使用列表第一个值作为初始值</code></pre><h1 id="2-元编程（metaprogramming）"><a href="#2-元编程（metaprogramming）" class="headerlink" title="2. 元编程（metaprogramming）"></a>2. 元编程（metaprogramming）</h1><p>所谓元编程，说白了就是“写能写程序的程序”，这说起来有点拗口，下面会通过实例来讲解。</p><h2 id="2-1-开放类"><a href="#2-1-开放类" class="headerlink" title="2.1 开放类"></a>2.1 开放类</h2><p>可以重定义Ruby中的任何类，并给它们扩充任何你想要的方法，甚至能让Ruby完全瘫痪，比如重定义Class.new方法。对于开发类来说，这种权衡主要考虑了自由，有这种重定义任何类或对象的自由，就能写出即为通俗易懂的代码，但也要明白，自由越大、能力越强，担负的责任也越重。</p><pre><code>class Numeric  def inches    self  end  def feet    self * 12.inches  end  def miles    self * 5280.feet  end  def back    self * -1  end  def forward    self  endend</code></pre><p>上面的代码通过开放Numeric类，就可以像这样采用最简单的语法实现用英寸表示距离：<code>puts 10.miles.back</code>，<code>puts 2.feet.forward</code>。</p><h2 id="2-2-使用method-missing"><a href="#2-2-使用method-missing" class="headerlink" title="2.2 使用method_missing"></a>2.2 使用method_missing</h2><p>Ruby找不到某个方法时，会调用一个特殊的回调方法<code>method_missing</code>显示诊断信息。通过覆盖这个特殊方法，可以实现一些非常有趣且强大的功能。下面这个示例展示了如何用简洁的语法来实现罗马数字。</p><pre><code>class Roman  # 覆盖self.method_missing方法  def self.method_missing name, *args    roman = name.to_s    roman.gsub!(&quot;IV&quot;, &quot;IIII&quot;)    roman.gsub!(&quot;IX&quot;, &quot;VIIII&quot;)    roman.gsub!(&quot;XL&quot;, &quot;XXXX&quot;)    roman.gsub!(&quot;XC&quot;, &quot;LXXXX&quot;)    (roman.count(&quot;I&quot;) +     roman.count(&quot;V&quot;) * 5 +     roman.count(&quot;X&quot;) * 10 +     roman.count(&quot;L&quot;) * 50 +     roman.count(&quot;C&quot;) * 100)  endendputs Roman.III  # =&gt; 3puts Roman.XII  # =&gt; 12</code></pre><p>我们没有给Roman类定义什么实际的方法，但已经可以Roman类来表示任何罗马数字！其原理就是在没有找到定义方法时，把方法名称和参数传给<code>method_missing</code>执行。首先调用<code>to_s</code>把方法名转为字符串，然后将罗马数字“左减”特殊形式转换为“右加”形式（更容易计数），最后统计各个符号的个数和加权。</p><p>当然，如此强有力的工具也有其代价：类调试起来会更加困难，因为Ruby再也不会告诉你找不到某个方法。因此<code>method_missing</code>是一把双刃剑，它确实可以让语法大大简化，但是要以人为地加强程序的健壮性为前提。</p><h2 id="2-3-使用模块"><a href="#2-3-使用模块" class="headerlink" title="2.3 使用模块"></a>2.3 使用模块</h2><p>Ruby最流行的元编程方式，非模块莫属。下面的代码讲述如何用模块的方式扩展一个可以读取csv文件的类。</p><pre><code>module ActsAsCsv  # 只要某个模块被另一模块include，就会调用被include模块的included方法  def self.included(base)    base.extend ClassMethods  end  module ClassMethods    def acts_as_csv      include InstanceMethods    end  end  module InstanceMethods    attr_accessor :headers, :csv_contents    def initialize      read    end    def read      @csv_contents = []      filename = self.class.to_s.downcase + &apos;.txt&apos;      file = File.new(filename)      @headers = file.gets.chomp.split(&apos;, &apos;)  # String的chomp方法去除字符串末尾的回车换行符      file.each do |row|        @csv_contents &lt;&lt; row.chomp.split(&apos;, &apos;)      end    end  endend  # end of module ActsAsCsvclass RubyCsv    # 没有继承，可以自由添加  include ActsAsCsv  acts_as_csvendm = RubyCsv.newputs m.headers.inspectputs m.csv_contents.inspect</code></pre><p>上述代码中RubyCsv包含了ActsAsCsv，所以ActsAsCsv的included方法中，base就指RubyCsv，ActsAsCsv模块给RubyCsv类添加了唯一一个类方法<code>acts_as_csv</code>，这个方法又打开RubyCsv类，并在类中包含了所有实例方法。如此这般，就写了一个会写程序的程序（通过模块来动态添加类方法）。</p><p>一些出色的Ruby框架，如Builder和ActiveRecord，都会为了改善可读性而特别依赖元编程。借助元编程的威力，可以做到尽量缩短正确的Ruby语法与日常用于之间的距离。注意一切都是为了提升代码可读性而服务。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>Ruby的纯面向对象可以让你用一致的方式来处理对象。鸭子类型根据对象可提供的方法，而不是对象的继承层次，实现了更切合实际的多态设计。Ruby的模块和开放类，使程序员能把行为紧密结合到语法上，大大超越了类中定义的传统方法和实例变量。</p><p>核心优势：</p><ul><li><strong>优雅的语法和强大的灵活性</strong></li><li>脚本：Ruby是一门梦幻般的脚本语言，可以出色地完成许多任务。Ruby许多语法糖可以大幅提高生产效率，各种各样的库和gem（Ruby包）可以满足绝大多数日常需要。</li><li>Web开发：很多人学Ruby最终就是为了用Ruby on Rails框架来进行Web开发。作为一个极其成功的MVC框架，其有着广泛的社区支持及优雅的语法。Twitter最初就是用Ruby实现的，借助Ruby无比强大的生产力，可以快速地开发出一个可推向市场的合格产品。</li></ul><p>不足之处：</p><ul><li><strong>性能</strong>：这是Ruby的最大弱点。随着时代的发展，Ruby的速度确实是越来越快。当然，Ruby是创建目的为了改善程序员的体验，在对性能要求不高的应用场景下，性能换来生产效率的大幅提升无疑是值得的。</li><li>并发和面向对象编程：面向对象是建立在状态包装一系列行为的基础上，但通常状态是会改变的。程序中存在并发时，这种编程策略就会引发严重问题。</li><li>类型安全：静态类型可提供一整套工具，可以更轻松地构造语法树，也因此能实现各种IDE。对Ruby这种动态类型语言来说，实现IDE就困难得多。</li></ul><p>参考资料：《七周七语言》第2章Ruby</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> 其它语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程范型 </tag>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ruby语言特性（上）</title>
      <link href="/tech/language/other/ruby-language-1/"/>
      <url>/tech/language/other/ruby-language-1/</url>
      
        <content type="html"><![CDATA[<p>Ruby是一种解释型、面向对象、动态类型的语言。Ruby采取的策略是在灵活性和运行时安全之间寻找平衡点。随着Rails框架的出现，Ruby也在2006年前后一鸣惊人，同时也指引人们重新找回编程乐趣。尽管从执行速度上说，Ruby谈不上有多高效，但它却能让程序员的编程效率大幅提高。本文将讲述Ruby语言的基础语言特性，包括基本的语法及代码块和类的定义。</p><a id="more"></a><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><p>在Ruby交互命令行中输入以下命令（<code>&gt;&gt;</code>为命令行提示符，<code>=&gt;</code>为返回值；下文将把<code>=&gt;</code>符号和语句写在一行内表明其返回值）：</p><pre><code>&gt;&gt; puts &apos;hello, world&apos;hello, world=&gt; nil&gt;&gt; language = &apos;Ruby&apos;=&gt; &quot;Ruby&quot;&gt;&gt; puts &quot;hello, #{language}&quot;hello, Ruby=&gt; nil</code></pre><p>以上代码使用<code>puts</code>输出，给变量赋值，并用<code>#{}</code>的语法实现字符串替换。这表明Ruby是解释执行的；变量无需声明即可直接初始化和赋值；每条Ruby代码都会返回某个值；单引号包含的字符串表示它将直接被解释，双引号包含的字符串会引发字符串替换。</p><h2 id="1-1-编程模型"><a href="#1-1-编程模型" class="headerlink" title="1.1 编程模型"></a>1.1 编程模型</h2><p>Ruby是一门纯面向对象语言，在Ruby中一切皆为对象，可以用“.”调用对象具有的方法，可以通过<code>class</code>和<code>methods</code>方法查看对象的类型及支持的方法，如<code>4.class =&gt; Fixnum</code>，<code>7.methods =&gt; [&quot;inspect&quot;, &quot;%&quot;, &quot;&lt;&lt;&quot;, &quot;numerator&quot;, ...]</code>，<code>false.class =&gt; FalseClass</code>（方括号表示数组）。</p><h2 id="1-2-流程控制"><a href="#1-2-流程控制" class="headerlink" title="1.2 流程控制"></a>1.2 流程控制</h2><p>条件判断有正常的块形式，也有简单明了的单行形式；除了常见的if语句外，还有unless语句（等价于if not，但可读性更强）。同理，循环也有正常的块形式和单行形式。注意：<strong>除了nil和false之外，其他值都代表true，包括0！</strong></p><pre><code># 块形式if x == 4  puts &apos;This is 4.&apos;end# 单行形式puts &apos;This is false.&apos; unless truex = x + 1 while x &lt; 10 # x的结果为10x = x - 1 until x == 1 # x的结果为1</code></pre><p>和其他C家族的语言差不多，Ruby的逻辑运算符<code>and</code>（<code>&amp;&amp;</code>）、<code>or</code>（<code>||</code>）都自带短路功能，若想执行整个表达式，可以用<code>&amp;</code>或<code>|</code></p><h2 id="1-3-鸭子类型"><a href="#1-3-鸭子类型" class="headerlink" title="1.3 鸭子类型"></a>1.3 鸭子类型</h2><p>执行<code>4 + &#39;four&#39;</code>会出现TypeError的错误，说明Ruby是强类型语言，在发生类型冲突时，将得到一个错误。如果把个语句放在<code>def...end</code>函数定义中，则只有在调用函数时才会报错，说明Ruby在运行时而非编译时进行类型检查，这称为<strong>动态类型</strong>。Ruby的类型系统有自己的潜在优势，即多个类不必继承自相同的父类就能以“多态”的方式使用：</p><pre><code>a = [&apos;100&apos;, 100.0]puts a[0].to_i  # =&gt; 100puts a[1].to_i  # =&gt; 100</code></pre><p>这就是所谓的“鸭子类型”（duck typing）。数组的第一个元素是String类型，第二个元素是Float类型，但转换成整数用的都是<code>to_i</code>。鸭子类型并不在乎其内在类型是什么，只要一个对象像鸭子一样走路，像鸭子一样嘎嘎叫，那它就是只鸭子。在面向对象设计思想中，有一个重要原则：对接口编码，不对实现编码。如果利用鸭子类型，实现这一原则只需极少的额外工作，就能轻松完成。</p><h2 id="1-4-函数"><a href="#1-4-函数" class="headerlink" title="1.4 函数"></a>1.4 函数</h2><pre><code>def tell_the_truth  trueend</code></pre><p>每个函数都会返回结果，如果没有显式指定返回值，函数就将退出函数前最后处理的表达式的值返回。函数也是个对象，可以作为参数传给其他函数。</p><h2 id="1-5-数组"><a href="#1-5-数组" class="headerlink" title="1.5 数组"></a>1.5 数组</h2><p>和Python一样，Ruby的数组也是用中括号来定义，如<code>animals = [&#39;lion&#39;, &#39;tiger&#39;, &#39;bear&#39;]</code>；负数下标可以返回倒数的元素，如<code>animals[-1] =&gt; &quot;bear&quot;</code>；通过指定一个Range对象来获取一个区段的元素，如<code>animals[1..2] =&gt; [&#39;tiger&#39;, &#39;bear&#39;]</code>。此外，数组元素可以互不相同，多为数组也不过是数组的数组。数组拥有极其丰富的API，可用其实现队列、链表、栈、集合等等。</p><h2 id="1-6-散列表"><a href="#1-6-散列表" class="headerlink" title="1.6 散列表"></a>1.6 散列表</h2><pre><code>numbers = {2 =&gt; &apos;two&apos;, 5 =&gt; &apos;five&apos;}stuff = {:array =&gt; [1, 2, 3], :string =&gt; &apos;Hi, mom!&apos;}# stuff[:string] =&gt; &quot;Hi, mom!&quot;</code></pre><p>散列表可以带任何类型的键，上述代码的stuff的键较为特殊——它是一个符号（symbol），前面带有冒号标识符。符号在给事物和概念命名时很好用，例如两个同值字符串在物理上不同，但相同的符号却是同一物理对象，可以通过反复调用<code>&#39;i am string&#39;.object_id</code>和<code>:symbol.object_id</code>来观察。另外，当散列表用作函数最后一个参数时，大括号可有可无，如<code>tell_the_truth :profession =&gt; :lawyer</code>。</p><h1 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2. 面向对象"></a>2. 面向对象</h1><h2 id="2-1-代码块"><a href="#2-1-代码块" class="headerlink" title="2.1 代码块"></a>2.1 代码块</h2><p>代码块是没有名字的函数（匿名函数），可以用作参数传递给函数。代码块只占一行时用大括号包起来，占多行是用do/end包起来，可以带若干个参数。</p><pre><code>3.times {puts &apos;hehe&apos;}  # 输出3行hehe[&apos;lion&apos;, &apos;tiger&apos;, &apos;bear&apos;].each {|animal| puts animal} # 输出列表的内容</code></pre><p>上面的<code>times</code>实际上是Fixnum类型的方法，要自己实现这样一个方法非常容易：</p><pre><code>class Fixnum  def my_times    i = self      while i &gt; 0        i = i - 1        yield    end  endend3.my_times {puts &apos;hehe&apos;}  # 输出3行hehe</code></pre><p>这段代码打开一个现有的类，向其中添加一个自定义的<code>my_times</code>方法，并用<code>yield</code>调用代码块。在Ruby中，代码块不仅可用于循环，还可用于延迟执行，即代码块中的行为只有等到调用相关的yield时才会执行。代码块充斥于Ruby的各种库，小到文件的每一行，大到在集合上进行各种复杂操作，都是由代码块来完成的。</p><h2 id="2-2-类"><a href="#2-2-类" class="headerlink" title="2.2 类"></a>2.2 类</h2><p>调用一个对象的<code>class</code>方法可以查看其类型，调用<code>superclass</code>可以查看这个类型的父类。下图展示了数字的继承链，其中横向箭头表示右边是左边实例化的对象，纵向箭头表示下边继承于上边。Ruby的一切事物都有一个共同的祖先Object。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/Script/Ruby数字的继承链.png" alt="Ruby数字的继承链"></p><p>最后通过一个完整的实例——定义一棵树，来看下Ruby的类如何定义和使用，该注意的点都写在注释里面了。</p><pre><code>class Tree  # 定义实例变量，使用attr或attr_accessor关键字，前者定义变量和访问变量的同名getter方法（即只读），后者定义的变量多了同名setter方法（注意这里使用了符号）  attr_accessor :children, :node_name  # 构造方法（构造方法必须命名为initialize）  def initialize(name, children=[])    @node_name = name    @children = children  end  # 遍历所有节点并执行代码块block，注意参数前加一个&amp;表示将代码块作为闭包传递给函数  def visit_all(&amp;block)    visit &amp;block    children.each {|c| c.visit_all &amp;block}  end  # 访问一个节点并执行代码块block  def visit(&amp;block)    block.call self  endendruby_tree = Tree.new(&quot;Ruby&quot;,   [Tree.new(&quot;Reia&quot;),   Tree.new(&quot;MacRuby&quot;)])# 访问一个节点ruby_tree.visit {|node| puts node.node_name}# 访问整棵树ruby_tree.visit_all {|node| puts &quot;Node: #{node.node_name}&quot;}</code></pre><p>最后再提一下Ruby的命名规范：</p><ul><li>类采用CamelCase命名法</li><li>实例变量（一个对象有一个值）前必须加上@，类变量（一个类有一个值）前必须加上@@</li><li>变量和方法名全小写用下划线命名法，如underscore_style</li><li>常量采用全大写下划线命名法，如ALL_CAPS_STYLE</li><li>用于逻辑测试的函数和方法一般要加上问号，如if test?</li></ul><p>参考资料：《七周七语言》第2章Ruby</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> 其它语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程范型 </tag>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5高性能基础</title>
      <link href="/tech/web/html5/pro-html5-performance-base/"/>
      <url>/tech/web/html5/pro-html5-performance-base/</url>
      
        <content type="html"><![CDATA[<p>当谈到Web的“高性能”时，很多人想到的是<em>页面加载时间</em>，但其实性能不仅仅是指加载时间，还包括<em>浏览器性能</em>、<em>网络性能</em>、<em>开发效率</em>。在Web前端开发中，性能是一个非常重要的需要考虑的点。本文将介绍一些开发原则和性能准则，这些都是提高Web前端性能的基础。</p><a id="more"></a><h1 id="1-开发原则"><a href="#1-开发原则" class="headerlink" title="1. 开发原则"></a>1. 开发原则</h1><h2 id="1-1-编写符合当代浏览器性能的代码"><a href="#1-1-编写符合当代浏览器性能的代码" class="headerlink" title="1.1 编写符合当代浏览器性能的代码"></a>1.1 编写符合当代浏览器性能的代码</h2><p>如果想提高前端性能，就必须理解浏览器的工作原理，哪怕是个大概，这样才能知道性能瓶颈在哪里以及如何优化。下图展示了Webkit浏览器从代码（HTML+CSS）到用户最终看到页面的处理过程。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTML5/Webkit浏览器解析代码和渲染的过程.png" alt="Webkit浏览器解析代码和渲染的过程"></p><p>为什么浏览器要在第一时间下载页面的HTML内容？首先HTML被解析成一棵<em>DOM树</em>，其次HTML包含了展示页面的其他所有资源文件（样式、脚本、图片）。然后DOM树和CSS样式表（包括自定义的和浏览器默认的）合起来构成<em>渲染树</em>，浏览器开始根据这棵渲染树“画”到屏幕上。</p><p>要改进浏览器性能，可以从<strong>减少HTML中元素的数量</strong>及<strong>减少重绘</strong>两方面入手。前者很好理解，不要滥用HTML标签，应该用最少量但是必需的HTML去语义化地布局。后者对提高性能的作用更加明显。<strong>在元素完成绘制后，动态更改DOM结构或CSS样式都会引发浏览器重绘。重绘的性能耗损直接取决于动态改动的范围。</strong>例如改动一个元素的位置或新增一个元素，都会引起大量的重绘，因为它影响了所有的兄弟元素；又例如动态添加一个列表时，不要一个一个把<code>li</code>加进去，因为每添加一次都会导致一次重绘，而是把所有的项拼在一起再添加。此外，减少重绘的一些准则还有<em>规定img元素的宽高</em>，<em>不要用表格来布局</em>，<em>在<code>head</code>标签内定义字符集</em>等等。</p><p>通常来说，改动的元素在DOM树中的深度越深，对其他节点影响就越小；如果要对DOM进行多次操作，尽量合并到一次做完，例如要修改一个DOM元素的多种样式时，不要反复给<code>element.style</code>下的各种属性赋值，而是将要变化的多种样式写在一个CSS类中，再赋予该DOM元素这个类。</p><h2 id="1-2-用CSS来布局并处理边界"><a href="#1-2-用CSS来布局并处理边界" class="headerlink" title="1.2 用CSS来布局并处理边界"></a>1.2 用CSS来布局并处理边界</h2><p>浏览器渲染页面其实是在渲染一系列“盒子”，而且这些“盒子”都可以嵌套。在用CSS做布局的时候，应该注重语义化，把一组元素都包在一个盒子里，而不是把部分元素丢到盒子外面。如下图所示，要用CSS来实现这种简单的两列布局，较好的做法是给右栏设置一个<code>padding-left</code>，并把左栏图标绝对定位到<code>left:0</code>，这样就有了一个所有内容都包含在内部的盒子。错误的做法是给右栏设置<code>margin-left</code>，并把左栏图标绝对定位到<code>left: -50px</code>，这种做法把图标放到了盒子外，而且还定义了一个负坐标，这不仅不符合语义（把应该包含的元素放到了盒子外），出现负数这种不协调的代码感，而且这种布局还有可能在旧浏览器上出问题。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTML5/CSS布局示例.jpg" alt="CSS布局示例"></p><p>使用CSS写样式时，还应该多考虑模块化和可复用性。如果你写的代码是独立于内容的，它就是可复用的。另外从CSS类的命名上也经常可以看出问题，我的经验是尽量以元素的样式，而不是元素的功能去命名，例如给一个发送邮件按钮添加样式CSS类时，<code>.btn-confirm</code>就比<code>.btn-send-mail</code>好一些，前者可以复用到任何确认操作的按钮上（当然<code>.btn-send-mail</code>这个类也可以用于做js事件绑定用，只要它不绑定任何样式）。</p><h2 id="1-3-渐进式增强"><a href="#1-3-渐进式增强" class="headerlink" title="1.3 渐进式增强"></a>1.3 渐进式增强</h2><p>渐进式增强指的是首先有一个基本的设计是可以兼容所有浏览器的，然后再为较新式的浏览器做加强的样式或功能（渐进式）。例如设置渐变背景颜色时，可以先定义一条<code>background-color</code>属性（退化样式），再设置其他<code>linear-gradient</code>属性，这样可以确保在浏览器不支持CSS3的时候，也可以正常显示一个背景颜色。</p><p>强烈建议不要用判断浏览器类型或版本号的方式来判断是否支持某个功能，而是用<strong>特征检测</strong>来判断。关于特征检测，推荐用第三方库<a href="http://modernizr.com/" target="_blank" rel="noopener">Modernizr</a>。</p><h1 id="2-性能准则"><a href="#2-性能准则" class="headerlink" title="2. 性能准则"></a>2. 性能准则</h1><p>前端开发人员不仅要给用户提供最好的界面体验，还要关心页面的加载时间。2010年4月，谷歌把页面加载的快慢列入了搜索排名的考虑因素，有很多研究数据表明用户流量和加载速度呈正相关关系，可见页面加载速度的优化是何等重要。以下是一些性能准则，根据对页面加载时间的影响强弱排序。</p><ol><li>减少HTTP请求：HTTP请求数量是影响前端性能最明显的一个方面。现代很多浏览器支持4个并行连接，理解浏览器的并行连接机制，把资源文件分发到不同的域名下利用浏览器并发，可以提高加载效率。加载少量的大文件优于加载大量的小文件，因此线上的网站应尽可能合并CSS和JS文件。另外，使用图片精灵（CSS Sprite，俗称雪碧图）把许多图标之类的小图片合并到一个大图片，可以减少大量的图片HTTP请求。</li><li>使用CDN加速：如果有能力的话，把静态资源文件如图片、字体、JS库等放到CDN可以大幅提高访问速度。使用CDN应该给每个文件引用加一个时间戳，这样就不用担心缓存在CDN服务器上过期对用户产生影响。</li><li>避免空的src和href属性值：空src的img元素会被JS动态赋值，导致浏览器会发起一个无用的HTTP请求。同样，点击空href的a标签也会导致浏览器发起HTTP请求，通常是重新加载当前页面，这也是许多初学者难以发掘出的bug的原因所在。</li><li>增加过期头：应该给静态资源文件都加上过期头，过期的日期要定得很遥远，基本上可以认为永不过期，这样浏览器就会缓存静态文件。但为了避免用户更新不到最新的文件，最好在文件名上加上版本控制。</li><li>启用gzip压缩：服务器开启gzip压缩可以将文本文件传输流量平均减少70%左右。</li><li>把CSS放在<code>&lt;head&gt;</code>内，把Javascript放在<code>&lt;body&gt;</code>尾部：浏览器会同时解析HTML和渲染元素，把CSS放到前面可以保证先渲染的一部分元素样式是正确的，而把CSS放到后面会引起大量的浏览器重绘。要把<code>script</code>标签放到尾部，因为浏览器会预处理js文件，把js文件放到头部会延迟页面元素的渲染，让用户觉得页面打开变慢了。</li><li>避免使用CSS表达式：CSS表达式只在IE5、IE6、IE7被支持，使用CSS表达式不仅比正常的写法要长得多，还会严重影响页面渲染效率——只要页面一滚动，甚至移动鼠标时，表达式就会进行计算，这是完全没有必要的。</li><li>移除不使用的CSS语句：实际项目中可能会有一个<code>common.css</code>来让每个页面都引用，表示那些公共样式，应该尽量让这种公共文件的利用率达到最大。</li><li>对Javascript和CSS进行代码压缩：压缩代码可以显著节省带宽并提高加载速度。最好在部署到线上的时候利用工具对代码进行压缩。</li></ol><p>参考资料：《高性能HTML5》第2、3章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js学习笔记：进程与集群</title>
      <link href="/tech/web/nodejs/node-process-and-cluster/"/>
      <url>/tech/web/nodejs/node-process-and-cluster/</url>
      
        <content type="html"><![CDATA[<p>Node中的Javascript运行在单进程单线程上带来了很多好处：程序状态单一，没有多线程的锁、线程同步问题，操作系统调度因为较少的上下文切换开销，可以很好地提高CPU的使用率。但是这种模型并非是完美的，尤其是如今CPU基本都是多核的，一个Node进程只能利用一个核。此外，一旦单线程上抛出的异常没有被捕获，将会引起整个进程的崩溃。</p><p>本文将叙述Node如何应对“如何充分利用多核CPU服务器”及“如何保证进程的健壮性和稳定性”这两个问题。</p><a id="more"></a><h1 id="1-服务器模型的变迁"><a href="#1-服务器模型的变迁" class="headerlink" title="1. 服务器模型的变迁"></a>1. 服务器模型的变迁</h1><p>Web服务器的架构至今已经历了几次变迁：</p><ol><li>同步：最早的服务器的执行模型是同步的，其一次只为一个请求服务，其余请求都处于耽误的状态。这类架构如今已基本淘汰，只在一些无并发要求的应用中存在。</li><li>复制进程：每有一个连接，就复制一个进程来提供服务。这个模型不具备伸缩性，一旦并发请求过高，内存会随着进程数的增长耗尽。</li><li>多线程：类似多进程模式，对每一个连接都创建一个线程去服务。线程相对进程开销要小很多，而且线程间可以共享数据。但是多线程还是会随着并发数的增多而耗尽内存，缺乏强大的伸缩性。</li><li>事件驱动：单线程的事件驱动避免了不必要的内存开销和上下文切换开销，不受资源上限的影响，伸缩性远比前两者高。</li></ol><h1 id="2-多进程架构"><a href="#2-多进程架构" class="headerlink" title="2. 多进程架构"></a>2. 多进程架构</h1><h2 id="2-1-创建子进程"><a href="#2-1-创建子进程" class="headerlink" title="2.1 创建子进程"></a>2.1 创建子进程</h2><p>面对单进程单线程对多核利用不足的问题，前人的经验是启动多个进程即可，理想状态下每个进程各自利用一个CPU。Node提供的child_process模块的<code>fork()</code>、<code>spawn()</code>、<code>exec()</code>、<code>execFile()</code>函数可以实现子进程的创建。以下代码会根据当前机器上的CPU数复制（fork）出对应的Node进程。</p><pre><code>/* master.js */var fork = require(&apos;child_process&apos;).fork;var cpus = require(&apos;os&apos;).cpus();for (var i = 0; i &lt; cpus.length; i++) {    fork(&apos;./worker.js&apos;);    // worker.js为启动HTTP服务器的代码}</code></pre><p>这就是著名的Master-Worker（主从）模式，是典型的分布式架构中用于处理业务的模式，具备较好的可伸缩性和稳定性。主进程只负责调度或管理工作进程，工作进程只负责具体的业务处理。</p><h2 id="2-2-进程间通信"><a href="#2-2-进程间通信" class="headerlink" title="2.2 进程间通信"></a>2.2 进程间通信</h2><p>主从进程通过<code>send()</code>和<code>message</code>事件实现进程间通信，如下面的代码所示：</p><pre><code>/* master.js */var subProc = require(&apos;child_process&apos;).fork(&apos;./worker.js&apos;);subProc.send({hehe: &apos;123&apos;});subProc.on(&apos;message&apos;, function(msg) {    console.log(&apos;MASTER got message:&apos;, msg);});/* worker.js */process.on(&apos;message&apos;, function(msg) {    console.log(&apos;WORKER got message:&apos;, msg);});process.send({foo: &apos;bar&apos;});</code></pre><p>主从进程之间的通信实际上通过IPC（Inter-Process Communication）通道来传递信息的。Node中实现IPC通道的具体细节由libuv提供，在Windows下由命名管道实现，*nix系统采用Unix Domain Socket实现。<strong>父进程在创建子进程之前，会创建IPC通道并监听它，然后才真正创建子进程，并通过环境变量NODE_CHANNEL_FD告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个IPC通道，从而完成父子进程之间的链接。</strong></p><h2 id="2-3-句柄传递"><a href="#2-3-句柄传递" class="headerlink" title="2.3 句柄传递"></a>2.3 句柄传递</h2><p>通常如果让多个进程监听同一个端口，会抛出EADDRINUE异常。要解决多进程监听同个端口，其中一种做法是主进程监听主端口（如80），对外接收所有网络请求，再分别代理到不同端口的进程上。这样既能监听同个端口，甚至可以在代理进程上做适当的负载均衡，缺点是会浪费掉一倍数量的文件描述符。</p><p>为了解决上述问题，Node在版本v0.5.9引入了进程间发送句柄的功能，<code>send()</code>方法的第一个参数是要发送的数据，第二个可选参数就是句柄。目前可以发送的句柄包括：net.Socket、net.Server、net.Native、dgram.Socket、dgram.Native。</p><pre><code>/* master.js */var cp = require(&apos;child_process&apos;);var child1 = cp.fork(&apos;./worker.js&apos;);var child2 = cp.fork(&apos;./worker.js&apos;);var server = require(&apos;net&apos;).createServer();server.listen(1337, function() {    child1.send(&apos;server&apos;, server);    child2.send(&apos;server&apos;, server);    // 关掉服务器是关键    server.close();});/* worker.js */var server = require(&apos;http&apos;).createServer(function(req, res) {    res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});    res.end(&apos;Handled by child, pid = &apos; + process.pid + &apos;\n&apos;);});process.on(&apos;message&apos;, function(msg, tcp) {    if (msg === &apos;server&apos;) {        tcp.on(&apos;connection&apos;, function(socket) {            server.emit(&apos;connection&apos;, socket);        });    }});</code></pre><p>启动master.js，每次请求<code>http://localhost:1337</code>时，得到的都是可能不一样的pid进程的响应，所有请求都由子进程来处理了。要特别注意的是，上述代码看似把<code>server</code>对象发送到了子进程，实际上传递的只是文件描述符和消息，子进程根据message.type创建对应的服务器对象， 然后监听到文件描述符上。</p><h1 id="3-构建稳定的集群"><a href="#3-构建稳定的集群" class="headerlink" title="3. 构建稳定的集群"></a>3. 构建稳定的集群</h1><p>前面搭建集群的方法充分利用了多核CPU资源，但每个工作进程依旧是在单线程上执行的，它的稳定性还不能得到完全的保障，需要建立一个健全的机制来保障Node应用的健壮性和稳定性。</p><h2 id="3-1-进程事件"><a href="#3-1-进程事件" class="headerlink" title="3.1 进程事件"></a>3.1 进程事件</h2><p>子进程对象除了message事件外，还有一些表示异常或错误的事件：</p><ul><li>error：子进程无法被复制创建、无法被杀死、无法发送消息时触发</li><li>exit：子进程退出时触发</li><li>close：在子进程的标准输入输出流中止时触发</li><li>disconnect：调用<code>disconnect()</code>方法时触发，调用该方法会关闭IPC通道</li></ul><p>除了上一章中提到的<code>send()</code>方法外，还能通过<code>kill()</code>方法给子进程发送消息，该方法并不是真正将子进程杀死，而是给子进程发送一个系统信号SIGTERM，子进程收到后才做出约定的行为，如退出进程。</p><h2 id="3-2-自动重启"><a href="#3-2-自动重启" class="headerlink" title="3.2 自动重启"></a>3.2 自动重启</h2><p>可以通过监听子进程的exit事件来获知其退出的信息。当因为有bug导致工作进程退出，需要仔细处理这种异常，最好是工作进程在得知自己要退出时，向主进程发送一个“自杀信号”，然后才停止接收新的连接，当所有连接断开后才退出。</p><pre><code>process.on(&apos;uncaughtException&apos;, function(err) {    logger.error(err);    // 记录日志，因为出现未能捕获的异常是不合格的    process.send({act: &apos;suicide&apos;});    // 停止接收新的连接    woker.close(function() {        // 所有已有连接断开后，才退出进程        process.exit(1);    });    // 设置超时时间，专门应对长连接这种情况    setTimeout(function() {        process.exit(1);    }, 5000);});</code></pre><p>此时主进程要监听message事件，一旦接收到自杀信号，就要重新启动一个新的工作进程来顶替出异常即将退出的进程，这样就能使应用平滑地应对用户的请求。工作进程也不能无限地被重启，因为如果在启动的过程或启动后收到连接就发生了错误，会导致工作进程被频繁重启，所以应该有一种机制来限制单位时间内重启的次数，超过限制就触发giveup事件告知主进程放弃重启。通常来说，giveup是比uncaughtException更严重的异常，必须严格监控并避免。</p><h2 id="3-3-状态共享"><a href="#3-3-状态共享" class="headerlink" title="3.3 状态共享"></a>3.3 状态共享</h2><p>Node进程不宜存放太多数据，因为这会加重垃圾回收的负担，同时Node也不允许多个进程间共享数据。在实际业务中，解决数据共享最直接简单的方案就是使用第三方存储，如数据库、磁盘文件、缓存服务（Redis等）。如果采用这种方式，需要一种机制在数据发生改变时通知到各个子进程。一种方式是子进程去向第三方定时轮询；另一种方式是额外增加一个通知进程来轮询第三方，当有数据变化时主动通知所有子进程。主动通知机制如果按进程间信号传递，在跨多台服务器时会失效，所以可以考虑采用TCP或UDP的方案。</p><h2 id="3-4-Cluster模块"><a href="#3-4-Cluster模块" class="headerlink" title="3.4 Cluster模块"></a>3.4 Cluster模块</h2><p>前文从原理层面介绍了child_process模块的一些细节，事实上Node在v0.8版本新增的cluster模块提供了更简洁强大的API来解决上述问题，详情可以参见<a href="http://nodejs.org/api/cluster.html" target="_blank" rel="noopener">Node cluster API文档</a>，此处不再赘述。</p><p>参考资料：《深入浅出NodeJS》第九章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js学习笔记：内存控制</title>
      <link href="/tech/web/nodejs/node-memory-control/"/>
      <url>/tech/web/nodejs/node-memory-control/</url>
      
        <content type="html"><![CDATA[<p>在过去很长一段时间内，Javascript开发者很少会在开发过程中遇到需要对内存精确控制的场景，也缺乏控制的手段。那些短时间执行的场景，如网页应用、命令行工具等，运行时间短内存很快地释放，即使内存使用过多或内存泄漏也只会影响到终端用户。但随着Node在服务器端的广泛应用，内存控制问题就暴露出来了。</p><p>基于无阻塞、事件驱动的Node服务，具有内存消耗低，适合处理海量网络请求的优点。服务器端的资源向来是寸土寸金，要为海量用户服务，就得使一切资源都要高效利用。本文将介绍Node如何合理高效地使用内存。</p><a id="more"></a><h1 id="1-V8的垃圾回收机制与内存限制"><a href="#1-V8的垃圾回收机制与内存限制" class="headerlink" title="1. V8的垃圾回收机制与内存限制"></a>1. V8的垃圾回收机制与内存限制</h1><p>Javascript与Java一样，由垃圾回收机制在来进行自动内存管理，开发者不需要像C/C++程序员那样时刻关注内存的分配和释放问题。在Node中，内存管理的好坏，垃圾回收状况是否优良，都与Node的Javascript执行引擎V8息息相关。</p><h2 id="1-1-V8的对象分配"><a href="#1-1-V8的对象分配" class="headerlink" title="1.1 V8的对象分配"></a>1.1 V8的对象分配</h2><p>在V8中，所有JS对象都是通过堆来分配。在Node命令行下执行<code>process.memoryUsage()</code>可以查看内存信息，返回的结果中<code>heapTotal</code>是已申请到的堆内存，<code>heapUsed</code>是当前使用的量。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，知道超过V8的限制为止。</p><p>V8对单个进程的Node有内存限制（64位系统约1.4GB，32位系统约0.7GB）。表层原因是V8最初为浏览器设计，不太可能遇到大量内存的场景，深层原因是V8垃圾回收需要一定的开销，内存限制放得过大会使性能和响应能力下降。当然，这个限制是可以打开的，Node在启动时可以传递两个参数来调整内存限制的大小（注意参数只在初始化时生效，之后无法动态改变）：</p><pre><code>node --max-old-space-size=1700 test.js // 单位为MBnode --max-new-space-size=1024 test.js // 单位为KB</code></pre><h2 id="1-2-V8的垃圾回收机制"><a href="#1-2-V8的垃圾回收机制" class="headerlink" title="1.2 V8的垃圾回收机制"></a>1.2 V8的垃圾回收机制</h2><h3 id="1-2-1-内存分代"><a href="#1-2-1-内存分代" class="headerlink" title="1.2.1 内存分代"></a>1.2.1 内存分代</h3><p>V8的垃圾回收策略主要基于分代式，主要将内存分为<em>新生代</em>和<em>老生代</em>，前者存放存活时间较短的对象，后者存放存活时间较长或常驻内存的对象。V8堆的整体大小就是两代内存空间之和，上面提到的两个参数中带有“old”和“new”，就是用于放宽新老生代的内存限制。</p><h3 id="1-2-2-新生代的Scavenge算法"><a href="#1-2-2-新生代的Scavenge算法" class="headerlink" title="1.2.2 新生代的Scavenge算法"></a>1.2.2 新生代的Scavenge算法</h3><p>Scavenge算法将堆内存对半分为两个semispace空间，只有一个处于使用中，称为From空间，另一个处于闲置状态，称为To空间。分配对象时先从From空间分配，当开始垃圾回收时，会将From空间中的存活对象复制到To空间中，非存活对象占用的空间会被释放。完成复制后，From和To空间对换，开始下一轮的垃圾回收。</p><p>该算法的缺点是只能使用堆内存的一半，是典型的牺牲空间换取时间的算法，所以无法大规模地应用到所有的垃圾回收中，但这个算法很适合应用在新生代中，因为新生代的对象生命周期都较短。</p><p>当一个对象经过多次复制依然存活时，它就会被认为是生命周期较长的对象，其随后会被移动到老生代中采用新的算法管理，这个过程称为晋升。晋升的条件主要有两个，一个是对象是否经过Scavenge回收，一个是To空间的内存占用比超过25%的限制。设置25%的限制是因为当此次Scavenge回收完成后，这个To空间会变成From空间，如果占比过高会影响后续的内存分配。</p><h3 id="1-2-3-老生代的Mark-Sweep和Mark-Compact算法"><a href="#1-2-3-老生代的Mark-Sweep和Mark-Compact算法" class="headerlink" title="1.2.3 老生代的Mark-Sweep和Mark-Compact算法"></a>1.2.3 老生代的Mark-Sweep和Mark-Compact算法</h3><p>Mark-Sweep是标记清除的意思，该算法在<em>标记阶段</em>遍历堆中所有对象，并标记活着的对象，接下来在<em>清除阶段</em>只清除没有被标记的对象。可以看出，活对象在新生代只占小部分，Scavenge只复制活对象；死对象在老生代只占小部分，Mark-Sweep只清理死对象，这就是两种回收方式能高效运作的原因。</p><p>Mark-Sweep最大的问题是进行一次标记清除后，内存空间会出现不连续的状态，这很可能会造成无法分配一个大对象的问题。而Mark-Compact则是一种改进，它在清除阶段将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。但由于Mark-Compact需要移动对象，执行速度不可能很快，所以再取舍上，V8主要使用Mark-Sweep，在空间不足以分配时才使用Mark-Compact。</p><h3 id="1-2-4-增量标记"><a href="#1-2-4-增量标记" class="headerlink" title="1.2.4 增量标记"></a>1.2.4 增量标记</h3><p>为了避免出现JS应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，这种暂停成为“全停顿”。V8老生代通常配置得很大，且存活对象较多，全堆垃圾回收的各种动作造成的停顿会比较可怕，需要设法改善。V8先从标记阶段入手，将原本一口气停顿完成的动作改为增量标记，也就是拆分为许多小“步进”，没做完一步就让JS应用逻辑执行一小会儿。这种垃圾回收与应用逻辑交替执行直到标记完成，可以让最大停顿时间减少5倍左右。</p><h2 id="1-3-查看垃圾回收日志"><a href="#1-3-查看垃圾回收日志" class="headerlink" title="1.3 查看垃圾回收日志"></a>1.3 查看垃圾回收日志</h2><p>用命令行启动node时，加入<code>--trace_gc</code>可以输出垃圾回收的日志信息，<code>--prof</code>可以得到V8执行时的性能分析数据。通过分析日志，可以找出垃圾回收的哪些阶段比较耗时，触发的原因是什么。不过，通过<code>--prof</code>得到的log不具备可读性，可以使用Node自带的<code>windows-tick-processor.bat</code>工具来分析。</p><h1 id="2-高效使用内存"><a href="#2-高效使用内存" class="headerlink" title="2. 高效使用内存"></a>2. 高效使用内存</h1><h2 id="2-1-内存泄漏"><a href="#2-1-内存泄漏" class="headerlink" title="2.1 内存泄漏"></a>2.1 内存泄漏</h2><p>Node对内存泄漏十分敏感，一旦线上应用有成千上万的流量，哪怕是一个字节的内存泄漏也会造成堆积。在V8的垃圾回收机制机制下，在通常的代码编写中，很少会出现内存泄漏，但内存泄漏通常产生于无意间，较难排查。一旦发生，其实质只有一个：当回收的对象出现意外没有被回收变成了常驻在老生代的对象。造成内存泄漏的原因有这么几个：缓存，队列消费不及时，作用域未释放。</p><p>JS开发者通常喜欢使用对象的键值对来当缓存，但严格意义上的缓存有着完善的过期策略，而普通对象的键值对并没有。所以在Node中，试图拿内存当缓存的行为应该受到限制，小心而为之。除了用对象来当缓存的案例之外，还有一种案例是模块机制。Node的模块都会通过编译执行并缓存起来常驻于老生代，由于通过<code>exports</code>导出的函数可以访问文件模块的私有变量，所以每个文件模块中被导出函数引用的变量不会被释放。在设计模块时，一定要十分小心内存泄漏的出现。下面的代码每次调用leak()方法时，都导致局部变量leakArray不停增加内存占用，不被释放：</p><pre><code>var leakArray = [];exports.leak = function() {    leakArray.push(&apos;leak&apos; + Math.random());};</code></pre><p>如果要大量使用缓存，目前比较好的做法是采用进程外缓存，如Redis和Memcached。这样Node进程自身不存储状态减少内存泄漏的可能性，进程之间也可以共享缓存。</p><h2 id="2-2-内存泄漏排查"><a href="#2-2-内存泄漏排查" class="headerlink" title="2.2 内存泄漏排查"></a>2.2 内存泄漏排查</h2><p>可以使用以下一些常见的工具来定位Node应用的内存泄漏：</p><ul><li>node-heapdump：来自Node核心贡献者之一的模块，允许对V8堆内存抓取快照，用于事后分析</li><li>node-memwatch：用法和node-heapdump类似，来自于Mozilla成员贡献的模块</li><li>node-mtrace：使用了GCC的mtrace工具来分析堆的使用</li></ul><h2 id="2-3-大内存应用"><a href="#2-3-大内存应用" class="headerlink" title="2.3 大内存应用"></a>2.3 大内存应用</h2><p>由于Node的内存限制，操作大文件时要小心，好在Node提供了原生stream模块用于处理大文件。不能通过<code>fs.readFile()</code>和<code>fs.writeFile()</code>来直接进行大文件操作，应该使用<code>fs.createReadStream()</code>和<code>fs.createWriteStream()</code>通过流的方式来读写大文件。若不需要进行字符串层面的操作，可以尝试使用<code>Buffer</code>来操作，这不会受到V8堆内存的限制，但依然会受到物理内存限制。</p><p>参考资料：《深入浅出NodeJS》第五章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js学习笔记：异步I/O</title>
      <link href="/tech/web/nodejs/node-asynchronous-io/"/>
      <url>/tech/web/nodejs/node-asynchronous-io/</url>
      
        <content type="html"><![CDATA[<p>“异步”这个名词的大规模流行是在Web 2.0浪潮中，它伴随着Javascript和AJAX席卷了Web。但在绝大多数高级编程语言中，异步并不多见。PHP最能体现这个特点：它不仅屏蔽了异步，甚至连多线程也不提供，PHP都是以同步阻塞的方式来执行。这样的优点利于程序猿顺序编写业务逻辑，但在复杂的网络应用中，阻塞导致它无法更好地并发。</p><p>在服务器端，I/O非常昂贵，分布式I/O更加昂贵，只有后端能快速响应资源，前端的体验才能变得更好。Node.js是首个将异步作为主要编程方式和设计理念的平台，伴随着异步I/O的还有事件驱动和单线程，它们构成Node的基调。本文将介绍Node是如何实现异步I/O的。</p><a id="more"></a><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><p>“异步”与“非阻塞”听起来似乎是一回事，从实际效果而言，这两者都达到了并行的目的。但是从计算机内核I/O而言，只有两种方式：阻塞与非阻塞。因此异步/同步和阻塞/非阻塞实际上是两回事。</p><h2 id="1-1-阻塞IO与非阻塞IO"><a href="#1-1-阻塞IO与非阻塞IO" class="headerlink" title="1.1 阻塞IO与非阻塞IO"></a>1.1 阻塞IO与非阻塞IO</h2><p>阻塞I/O的一个特点是<strong>调用之后一定要等到系统内核层面完成所有操作后，调用才结束</strong>。以读取磁盘上的一个文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中后，这个调用才结束。</p><p>阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。非阻塞I/O的特点就是<strong>调用之后会立即返回，返回后CPU的时间片可以用来处理其他事务</strong>。由于完整的I/O并没有完成，立即返回的并不是业务层期待的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成（即轮询）。轮询技术要以下几种：</p><ul><li>read：通过重复调用来检查I/O状态，是最原始性能最低的一种方式</li><li>select：对read的改进，通过对文件描述符上的事件状态来进行判断。缺点是文件描述符最大的数量有限制</li><li>poll：对select的改进，采用链表的方式避免最大数量限制，但描述符较多时，性能还是十分低下</li><li>epoll：进入轮询时若没有检查到I/O事件，将会进行休眠，直到事件发生将其唤醒。这是当前Linux下效率最高的I/O事件通知机制</li></ul><p>轮询满足了非阻塞I/O确保获取完整数据的需求，但对于应用程序而言，它仍然只能算作一种同步，因为依然需要等待I/O完全返回。等待期间，CPU要么用于遍历文件描述符的状态，要么用于休眠等待事件发生。</p><h2 id="1-2-理想与现实中的异步IO"><a href="#1-2-理想与现实中的异步IO" class="headerlink" title="1.2 理想与现实中的异步IO"></a>1.2 理想与现实中的异步IO</h2><p>完美的异步I/O应该是应用程序发起非阻塞调用，无需通过轮询就可以直接处理下一个任务，只需在I/O完成后通过信号或回调将数据传递给应用程序即可。</p><p>现实中的异步I/O在不同操作系统下有不同的实现，如*nix平台采用自定义的线程池，Windows平台采用IOCP模型。Node提供了libuv作为抽象封装层来封装平台兼容性判断，并保证上层Node与下层各平台异步I/O的实现各自独立。另外需要强调的是我们经常提到Node是单线程的，这仅仅是指Javascript的执行在单线程中，实际在Node内部完成I/O任务的都另有线程池。</p><h1 id="2-Node的异步IO"><a href="#2-Node的异步IO" class="headerlink" title="2. Node的异步IO"></a>2. Node的异步IO</h1><h2 id="2-1-事件循环"><a href="#2-1-事件循环" class="headerlink" title="2.1 事件循环"></a>2.1 事件循环</h2><p>Node的执行模型实际上是<strong>事件循环</strong>。在进程启动时，Node会创建一个无限循环，每一次执行循环体的过程成为一次Tick。每个Tick过程就是查看是否有事件等待处理，如果有则取出事件及其相关的回调函数，若存在关联的回调函数则执行它们，然后进入下一个循环。如果不再有事件处理，就退出进程。</p><h2 id="2-2-观察者"><a href="#2-2-观察者" class="headerlink" title="2.2 观察者"></a>2.2 观察者</h2><p>每个事件循环中有若干个<strong>观察者</strong>，通过向这些观察者询问来判断是否有事件要处理。事件循环是一个典型的<em>生产者/消费者模型</em>。在Node中，事件主要来源于网络请求、文件I/O等，这些事件都有对应的网络I/O观察者、文件I/O观察者等，事件循环则从观察者那里取出事件并处理。</p><h2 id="2-3-请求对象"><a href="#2-3-请求对象" class="headerlink" title="2.3 请求对象"></a>2.3 请求对象</h2><p>从Javascript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，叫做<strong>请求对象</strong>。以最简单的Windows下<code>fs.open()</code>方法（根据指定路径和参数去打开一个文件并得到一个文件描述符）为例，从JS调用到内建模块通过libuv进行系统调用，实际上是调用了<code>uv_fs_open()</code>方法。在调用过程中，创建了一个<code>FSReqWrap</code>请求对象，从JS层传入的参数和方法都封装在这个请求对象中，其中我们最为关注的回调函数被设置在这个对象的<code>oncompete_sym</code>属性上。对象包装完毕后，将<code>FSReqWrap</code>对象推入线程池中等待执行。</p><p>至此，JS调用立即返回，JS线程可以继续执行后续操作。当前的I/O操作在线程池中等待执行，这就完成了异步调用的第一阶段。</p><h2 id="2-4-执行回调"><a href="#2-4-执行回调" class="headerlink" title="2.4 执行回调"></a>2.4 执行回调</h2><p>回调通知是异步I/O的第二阶段。线程池中的I/O操作调用完毕后，会将获取的结果储存起来，然后通知IOCP当前对象操作已完成，并将线程归还线程池。在每次Tick的执行中，事件循环的I/O观察者会调用相关的方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fnodejs%2FNode%E5%BC%82%E6%AD%A5IO%E6%B5%81%E7%A8%8B.jpg" alt="Node异步I/O流程"></p><h1 id="3-非IO的异步API"><a href="#3-非IO的异步API" class="headerlink" title="3. 非IO的异步API"></a>3. 非IO的异步API</h1><p>Node中还存在一些与I/O无关的异步API，例如定时器<code>setTimeout()</code>、<code>setInterval()</code>，立即异步执行任务的<code>process.nextTick()</code>和<code>setImmdiate()</code>等，这里略微介绍一下。</p><h2 id="3-1-定时器API"><a href="#3-1-定时器API" class="headerlink" title="3.1 定时器API"></a>3.1 定时器API</h2><p><code>setTimeout()</code>和<code>setInterval()</code>浏览器端的API是一致的，它们的实现原理与异步I/O类似，只是不需要I/O线程池的参与。调用定时器API创建的定时器会被插入到定时器观察者内部的一棵红黑树中，每次事件循环的Tick都会从红黑树中迭代取出定时器对象，检查是否超过定时时间，若超过就形成一个事件，回调函数立即被执行。定时器的主要问题在于它的定时时间并非特别精确（毫秒级，在容忍范围内）。</p><h2 id="3-2-立即异步执行任务API"><a href="#3-2-立即异步执行任务API" class="headerlink" title="3.2 立即异步执行任务API"></a>3.2 立即异步执行任务API</h2><p>在Node出现之前，很多人也许为了立即异步执行一个任务，会这样调用：</p><pre><code>setTimeout(function() {    // TODO}, 0);</code></pre><p>由于事件循环的特点，定时器的精确度不够，而且采用定时器需要使用红黑树，各种操作时间复杂度为$O(\log (n))$。而<code>process.nextTick()</code>方法只会将回调函数放入队列中，在下一轮Tick时取出执行，复杂度为$O(1)$更为高效。</p><p>此外还有一个<code>setImmediate()</code>方法和上述方法类似，都是将回调函数延迟执行。不过前者的优先级要比后者高，这是因为事件循环对观察者的检查是有先后顺序的。另外，前者的回调函数保存在一个数组中，每轮Tick会将数组中的所有回调函数全部执行完；后者结果保存在链表中，每轮Tick只会执行一个回调函数。</p><h1 id="4-事件驱动与高性能服务器"><a href="#4-事件驱动与高性能服务器" class="headerlink" title="4. 事件驱动与高性能服务器"></a>4. 事件驱动与高性能服务器</h1><p>前面以<code>fs.open()</code>为例阐述了Node如何实现异步I/O。事实上对网络套接字的处理，Node也应用了异步I/O，这也是Node构建Web服务器的基础。经典的服务器模型有：</p><ul><li>同步式：一次只能处理一个请求，其余请求都处于等待状态</li><li>每进程/每请求：为每个请求启动一个进程，但系统资源有限，不具备扩展性</li><li>每线程/每请求：为每个请求启动一个线程。线程比进程要轻量，但每个线程都占用一定内存，当大并发请求到来时，内存很快就会用光</li></ul><p>著名的Apache采用的就是每线程/每请求的形式，这也是它难以应对高并发的原因。Node通过事件驱动方式处理请求，可以省掉创建和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价也很低。即使在大量连接的情况下，Node也能有条不紊地处理请求。</p><p>知名服务器Nginx也摒弃了多线程的方式，采用和Node一样的事件驱动方式。如今Nginx大有取代Apache之势。Nginx采用纯C编写，性能较高，但是它仅适合做Web服务器，用于反向代理或负载均衡等。Node可以构建与Nginx相同的功能，也可以处理各种具体业务，自身性能也不错。在实际项目中，我们可以结合它们各自有点，以达到应用的最佳性能。</p><p>参考资料：《深入浅出NodeJS》第三章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 异步I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js学习笔记：模块机制</title>
      <link href="/tech/web/nodejs/node-module/"/>
      <url>/tech/web/nodejs/node-module/</url>
      
        <content type="html"><![CDATA[<p>Javascript自诞生以来，曾经没有人拿它当做一门编程语言。在Web 1.0时代，这种脚本语言主要被用来做表单验证和网页特效。直到Web 2.0时代，前端工程师利用它大大提升了网页上的用户体验，JS才被广泛重视起来。在JS逐渐流行的过程中，它大致经历了工具类库、组件库、前端框架、前端应用的变迁。Javascript先天就缺乏一项功能：模块，而CommonJS规范的出现则弥补了这一缺陷。本文将介绍CommonJS规范及Node的模块机制。</p><a id="more"></a><p>在其他高级语言中，Java有类文件，Python有import机制，PHP有include和require。而JS通过&lt;script&gt;标签引入代码的方式显得杂乱无章。过去人们不得不用命名空间等方式来人为地约束代码，直到<a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank" rel="noopener">CommonJS</a>规范的出现，前后端的Javascript才得以实现大一统。Node借鉴了CommonJS的Modules规范实现了一套非常易用的模块系统。</p><h1 id="1-CommonJS模块规范"><a href="#1-CommonJS模块规范" class="headerlink" title="1. CommonJS模块规范"></a>1. CommonJS模块规范</h1><p>CommonJS的模块规范分为3个部分：</p><ol><li>模块引用：通过<code>require()</code>方法并传入一个<strong>模块标识</strong>来引入一个模块的API到当前上下文中，如<code>var math = require(&#39;math&#39;);</code></li><li>模块定义：通过<code>exports</code>对象来导出当前模块的方法或变量。模块中还存在一个<code>module</code>对象，exports实际上是module的属性。在Node中，一个文件就是一个模块，模块内的“全局变量”对外都不可见，只有挂载在exports上的属性才是公开的，如<code>exports.add = function() {}; exports.PI = 3.1415926;</code></li><li>模块标识：实际上就是传递给<code>require()</code>的参数，如上述的<code>&#39;math&#39;</code>，它必须是符合camel命名法的字符串，或者是以“.”“..”开头的相对路径或绝对路径，它可以没有文件名后缀“.js”</li></ol><h1 id="2-Node模块实现过程"><a href="#2-Node模块实现过程" class="headerlink" title="2. Node模块实现过程"></a>2. Node模块实现过程</h1><p>在Node中，模块分为两类：一类是Node本身提供的核心模块，另一类是用户自己编写的文件模块。核心模块有一部分在Node源代码的编译过程中，编译成了二进制文件，在Node启动时核心模块就被直接加载进内存中，所以它的加载速度是最快的。文件模块则是在运行时动态加载，需要经历三个步骤：路径分析，文件定位，编译执行。<strong>注意，Node对引入过的模块都会进行缓存，以减少二次引入时的开销，并对相同模块的二次加载都采用最优先从缓存加载的策略。</strong></p><h2 id="2-1-路径分析"><a href="#2-1-路径分析" class="headerlink" title="2.1 路径分析"></a>2.1 路径分析</h2><p>路径分析主要分析上述提到的模块标识符，主要分为以下几类：</p><ul><li>核心模块，如http、fs、path等</li><li>.或..开始的相对路径文件模块</li><li>以/开始的绝对路径文件模块</li><li>自定义文件模块，可能是一个文件或包的形式。Node会根据<em>模块路径</em>数组<code>module.paths</code>来逐个尝试查找目标文件，通常是沿着当前目录逐级向上直到根目录查找名为<code>node_modules</code>的目录，所以这是查找最费时的一种方式。</li></ul><h2 id="2-2-文件定位"><a href="#2-2-文件定位" class="headerlink" title="2.2 文件定位"></a>2.2 文件定位</h2><p>在路径分析的基础上，文件定位需要注意如下细节：</p><ul><li>文件扩展名分析：由于CommonJS规范允许模块标识不填写扩展名，Node会按.js、.json、.node的次序不足扩展名，依次尝试</li><li>目录分析和包：若通过上述文件扩展名分析后没有查找到对应文件，却得到一个目录，Node会把目录当做一个包来处理</li></ul><h2 id="2-3-编译执行"><a href="#2-3-编译执行" class="headerlink" title="2.3 编译执行"></a>2.3 编译执行</h2><p>定位到具体文件后，Node会新建一个模块对象，根据路径载入并编译。对于不同的扩展名，载入方法有所不同：</p><ul><li>.js文件：通过fs模块同步读取文件并编译执行</li><li>.node文件：这是用C/C++编写的扩展文件，通过<code>dlopen()</code>方法加载</li><li>.json文件：通过fs模块同步读取文件，用<code>JSON.parse()</code>解析返回结果</li><li>其余扩展名文件：都被当做.js文件载入</li></ul><p>我们知道每个模块文件中默认都存在着require、exports、module这3个变量，甚至在Node的API文档中，我们知道每个模块还有<strong>filename、</strong>dirname这2个变量的存在，它们是从何而来的呢？Node的模块又是怎么做到声明的“全局变量”实际上是不会污染到其他模块的？事实上，<strong>Node在编译JS模块过程中会对文件内容进行头尾包装</strong>。下面是一个JS文件经过头尾包装的例子：</p><pre><code>(function(exports, require, module, __filename, __dirname) {    /* 中间是JS文件的实际内容 */    var math = require(&apos;math&apos;);    exports.area = function(radius) {        return Math.PI * radius * radius;    };    /* JS文件的实际内容结束 */});</code></pre><p>这样每个模块文件之间都进行了作用域隔离，同时require、exports、module等变量也被注入到了模块的上下文当中。这就是Node对CommonJS模块规范的实现。关于C/C++模块及Node核心模块的编译过程较为复杂，不再赘述。</p><h1 id="3-模块调用栈"><a href="#3-模块调用栈" class="headerlink" title="3. 模块调用栈"></a>3. 模块调用栈</h1><p>有必要明确一下Node中各种模块的调用关系，如下图所示：</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fnodejs%2FNode%E6%A8%A1%E5%9D%97%E9%97%B4%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB.jpg" alt="Node模块间调用关系"></p><p>C/C++内建模块是最底层的模块，属于核心模块，主要提供API给Javascript核心模块和第三方Javascript文件模块调用，实际中几乎不会接触到此类模块。Javascript核心模块主要职责有两种：一种是作为C/C++内建模块的封装层和桥接层供文件模块调用，另一种是纯粹的功能模块，不需要跟底层打交道。文件模块通常由第三方编写，包括普通Javascript模块和C/C++扩展模块。</p><h1 id="4-包与NPM"><a href="#4-包与NPM" class="headerlink" title="4. 包与NPM"></a>4. 包与NPM</h1><h2 id="4-1-包结构"><a href="#4-1-包结构" class="headerlink" title="4.1 包结构"></a>4.1 包结构</h2><p>包本质上是一个存档文件（一般为.zip或.tar.gz），安装后解压还原为目录。CommonJS的包规范由包结构和包描述文件两部分组成。一个完全符合CommonJS规范的包结构应包含以下文件：</p><ul><li>package.json：包描述文件</li><li>bin：存放可执行二进制文件的目录</li><li>lib：存放Javascript代码的目录</li><li>doc：存放文档的目录</li><li>test：存放单元测试用例的目录</li></ul><h2 id="4-2-包描述文件"><a href="#4-2-包描述文件" class="headerlink" title="4.2 包描述文件"></a>4.2 包描述文件</h2><p>包描述文件是一个JSON文件——package.json，位于包的根目录下，是包的重要组成部分，用于描述包的概况信息。后面要提到的NPM的所有行为都与这个文件的字段息息相关。下面将以知名Web框架express项目的<a href="https://github.com/strongloop/express/blob/master/package.json" target="_blank" rel="noopener">package.json</a>文件为例说明一些常用字段的含义。</p><ul><li>name：包名</li><li>description：包简介</li><li>version：版本号，需遵照“语义化的版本控制”，参照<a href="http://semver.org/" target="_blank" rel="noopener">http://semver.org/</a></li><li>dependencies：使用当前包所需要依赖的包列表。这个属性十分重要，NPM会通过这个属性自动加载依赖的包</li><li>repositories：托管源代码的位置列表</li></ul><p>其余字段的用法可以参照<a href="https://www.npmjs.org/doc/files/package.json.html" target="_blank" rel="noopener">NPM package.json说明</a></p><h2 id="4-3-NPM常用功能"><a href="#4-3-NPM常用功能" class="headerlink" title="4.3 NPM常用功能"></a>4.3 NPM常用功能</h2><p>NPM（node package manager），通常称为node包管理器。它的主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。</p><h3 id="4-3-1-NPM包安装"><a href="#4-3-1-NPM包安装" class="headerlink" title="4.3.1 NPM包安装"></a>4.3.1 NPM包安装</h3><p>Node包的安装分两种：本地安装、全局安装。两者的区别如下：</p><ul><li>本地安装<code>npm install &lt;package-name&gt;</code>：package会被下载到当前所在目录，也只能在当前目录下使用。</li><li>全局安装<code>npm install -g &lt;package-name&gt;</code>：package会被下载到到特定的系统目录下，安装的package能够在所有目录下使用。</li></ul><h3 id="4-3-2-NPM包管理"><a href="#4-3-2-NPM包管理" class="headerlink" title="4.3.2 NPM包管理"></a>4.3.2 NPM包管理</h3><p>下面以grunt-cli（grunt命令行工具）为例，列出常用的包管理命令：</p><ul><li><code>npm install</code>：安装package.json文件的dependencies和devDependencies字段声明的所有包</li><li><code>npm install grunt-cli@0.1.9</code>：安装特定版本的grunt-cli</li><li><code>npm install grunt-contrib-copy --save</code>：安装grunt-contrib-copy，同时保存该依赖到package.json文件</li><li><code>npm uninstall grunt-cli</code>：卸载包</li><li><code>npm list</code>：查看安装了哪些包</li><li><code>npm publish &lt;folder&gt;</code>：发布包</li></ul><p>参考资料：《深入浅出NodeJS》第二章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js学习笔记：简介</title>
      <link href="/tech/web/nodejs/node-introduction/"/>
      <url>/tech/web/nodejs/node-introduction/</url>
      
        <content type="html"><![CDATA[<p>Node.js应该是当今最火热的技术之一。本文主要介绍Node.js的特点及应用场景。</p><a id="more"></a><p>Node.js是一个基于Chrome JavaScript运行时建立的一个平台，用来方便地搭建快速的 易于扩展的网络应用。Node.js借助事件驱动，非阻塞I/O模型变得轻量和高效，非常适合 运行在分布式设备的数据密集型实时应用。</p><h1 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h1><h2 id="1-1-异步I-O"><a href="#1-1-异步I-O" class="headerlink" title="1.1 异步I/O"></a>1.1 异步I/O</h2><p>所谓的异步I/O，是相对同步I/O而言的。程序执行过程中必然要进行很多I/O操作，如读写文件、输入输出、请求响应等等。通常来说，I/O操作是非常费时的。例如在传统的编程模式中，你要读一个几G的文件，整个线程都暂停下来，等待文件读完后继续执行。换言之，I/O操作阻塞了代码的执行，极大地降低了程序的效率。</p><p>关于异步I/O，其实对于前端工程师来说并不陌生，因为发起Ajax请求就是最常见的一种“异步”调用。在Node中，以读取文件（读文件是一种耗时的I/O操作）为例，它与发起Ajax请求的写法很像：</p><pre><code>var fs = require(&apos;fs&apos;);fs.readFile(&apos;/path&apos;, function(err, file) {    console.log(&apos;读取文件完成&apos;);});console.log(&apos;开始读取文件&apos;);</code></pre><p>上述代码在调用<code>fs.readFile</code>后，后续代码是被立即执行的，“读取文件完成”的时刻是无法预知的。当线程遇到I/O操作时不会以阻塞的方式等待I/O操作结束，而只是将I/O请求发送给操作系统，继续执行后续语句。当操作系统完成I/O操作时以事件的形式通知执行I/O操作的线程，线程会在特定时间处理这个事件。</p><h2 id="1-2-事件循环与回调函数"><a href="#1-2-事件循环与回调函数" class="headerlink" title="1.2 事件循环与回调函数"></a>1.2 事件循环与回调函数</h2><p>所谓事件循环是指Node会把所有的异步操作使用事件机制解决，有个线程在不断地循环检测事件队列。事件循环会检查事件队列中有没有未处理的事件，直到程序结束。事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下，事件与事件之间各自独立，如何协作是一个问题。在Javascript中，回调函数无处不在，回调函数是最好的接受异步调用返回数据的方式。</p><h2 id="1-3-单线程"><a href="#1-3-单线程" class="headerlink" title="1.3 单线程"></a>1.3 单线程</h2><p>Node保持了JS在浏览器中单线程的特点。单线程的最大好处是不用像多线程编程那样出处在意状态的同步问题，没有死锁的存在，也没有线程上下文切换的开销。单线程也有其弱点，主要表现在三方面：无法利用多核CPU；错误会引起整个应用退出，应用的健壮性值得考研；大量计算会占用CPU导致无法继续调用异步I/O。</p><p>为了解决上述问题，Node采用了与HTML5 Web Workers相同的思路，使用<code>child_process</code>来解决但单线程中大计算量的问题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果。</p><h2 id="1-4-跨平台"><a href="#1-4-跨平台" class="headerlink" title="1.4 跨平台"></a>1.4 跨平台</h2><p>Node是跨平台的，即同样的一套JS代码都可以部署运行在Windows、Linux、OSX等平台。这主要得益于Node在操作系统与Node上层模块系统之间构建了一层平台层架构libuv。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image%2Fnodejs%2FNode%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Node实现跨平台的架构示意图"></p><h1 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h1><ul><li>实时应用：如在线聊天，实时通知推送等等（如<a href="http://socket.io/" target="_blank" rel="noopener">socket.io</a>）</li><li>分布式应用：通过高效的并行I/O使用已有的数据</li><li>工具类应用：海量的工具，小到前端压缩部署（如<a href="gruntjs.com">grunt</a>），大到桌面图形界面应用程序</li><li>游戏类应用：游戏领域对实时和并发有很高的要求（如网易的<a href="pomelo.netease.com">pomelo</a>框架）</li><li>利用稳定接口提升Web渲染能力</li><li>前后端编程语言环境统一：前端开发人员可以非常快速地切入到服务器端的开发（如著名的纯Javascript全栈式<a href="http://mean.io" target="_blank" rel="noopener">MEAN</a>架构）</li></ul><p>参考资料：《深入浅出NodeJS》第一章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS学习笔记：可视化格式模型</title>
      <link href="/tech/web/css/css-visualization-model/"/>
      <url>/tech/web/css/css-visualization-model/</url>
      
        <content type="html"><![CDATA[<p>浮动、定位和盒模型是CSS三个最重要的基础概念，也是非常容易混淆和难掌握的概念。这些概念用于控制在页面上摆放和显示元素的方式，形成CSS基本布局。本文将介绍盒模型概念，外边距叠加，绝对定位和相对定位的差异，以及浮动和清理如何工作等。</p><a id="more"></a><h1 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1. 盒模型"></a>1. 盒模型</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>CSS盒模型指定元素如何显示以及在某种程度上如何相互交互。页面上的每个元素都被看做是一个矩形框，这个框由元素的内容、内边距、边框和外边距组成，如下图所示。如果使用Chrome的DevTools审查元素功能，鼠标指向页面随意一个元素，可以看到蓝色部分是内容，绿色部分是内边距，橙色部分是外边距。CSS中，width和height指的是内容区域的宽度和高度，增加padding、border、margin都不会影响内容区域的尺寸，但是<strong>会增加元素框的总尺寸</strong>。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/css/CSS%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B.jpg" alt="CSS标准盒模型"></p><ul><li>内边距padding：如果在元素上添加背景（<code>background</code>属性），背景会应用于内容和内边距组成的区域。</li><li>边框border：在内边距的区域外边加一条线，可以有实线、虚线、点线等。</li><li>外边距：透明，一般用于控制元素之间的间隔。</li></ul><h2 id="1-2-IE的盒模型"><a href="#1-2-IE的盒模型" class="headerlink" title="1.2 IE的盒模型"></a>1.2 IE的盒模型</h2><p>IE的早期版本（包括IE6）在混杂模式中使用自己<strong>不符合标准</strong>的盒模型，即这些浏览器的width属性不是内容的宽度，而是内容、内边距和边框的宽度总和。这种不标准的设定会引起很多麻烦，也是早期前端开发人员极其厌恶IE的原因。尽管它是不标准的，但是了解IE的盒模型对于建立兼容老式浏览器的网站还是很有帮助的。（CSS3的box-sizing属性可以定义要使用哪种盒模型）</p><h2 id="1-3-外边距叠加"><a href="#1-3-外边距叠加" class="headerlink" title="1.3 外边距叠加"></a>1.3 外边距叠加</h2><p>当两个或更多<strong>垂直</strong>外边距相遇时，它们的实际效果只形成<strong>一个</strong>外边距，其高度等于多个发生叠加外边距的最大者。例如，当两个元素垂直排列，上面元素的margin-bottom会合下面元素的margin-top发生叠加。外边距叠加实际还有很多种情形，包括空元素的外边距叠加等等，详情及外边距合并的意义参见<a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="noopener">W3School CSS外边距叠加</a>。注意：只有普通文档流中块框的垂直外边距才会发生外边距合并，行内框、浮动框或绝对定位之间的外边距不会合并。</p><h1 id="2-CSS定位机制"><a href="#2-CSS定位机制" class="headerlink" title="2. CSS定位机制"></a>2. CSS定位机制</h1><p>CSS有三种基本的定位机制：普通流、绝对定位和浮动。默认为普通流，即元素框的位置由元素在HTML中的位置决定。</p><h2 id="2-1-块和行内元素"><a href="#2-1-块和行内元素" class="headerlink" title="2.1 块和行内元素"></a>2.1 块和行内元素</h2><p>p、h1、div等元素常常称为块级元素（块框），它们显示为一块内容；i、span等元素称为行内元素（行内框），它们的内容显示在一行中。可以使用CSS的display属性改变生成框的类型，例如给span设置<code>display:block</code>可以让其行为变得和块框一样。块框从上到下垂直排列，行内框在一行中水平排列，默认垂直内外边距和边框不影响行内框的高度，不过如果使用<code>display:inline-block</code>可以让元素既像行内元素一样水平排列，又符合块级框的行为。</p><p>如果将一些文本添加到一个块级元素（如div）的开头时，这些文字会被当做块级元素处理，这个块框称为匿名块框，而且无法直接应用样式。如下面代码中的“some text”就是这种文字。</p><pre><code>&lt;div&gt;    some text    &lt;p&gt;more&lt;/p&gt;&lt;/div&gt;</code></pre><h2 id="2-2-相对定位和绝对定位"><a href="#2-2-相对定位和绝对定位" class="headerlink" title="2.2 相对定位和绝对定位"></a>2.2 相对定位和绝对定位</h2><p>相对定位概念参见<a href="http://www.w3school.com.cn/css/css_positioning_relative.asp" target="_blank" rel="noopener">W3School CSS相对定位</a>，绝对定位概念参见<a href="http://www.w3school.com.cn/css/css_positioning_absolute.asp" target="_blank" rel="noopener">W3School CSS绝对定位</a>。基本概念此处不再赘述。</p><p>要注意相对定位的元素被看做普通流的一部分，但<strong>绝对定位会使元素脱离文档流，不占据空间</strong>。并且绝对定位元素的位置是相对于最近的已定位的祖先元素的，通常使用<code>position:absolute</code>的元素会被包含在<code>position:relative</code>的父元素之中。</p><h2 id="2-3-浮动"><a href="#2-3-浮动" class="headerlink" title="2.3 浮动"></a>2.3 浮动</h2><p>浮动概念参见<a href="http://www.w3school.com.cn/css/css_positioning_floating.asp" target="_blank" rel="noopener">W3School CSS浮动</a>。</p><p>浮动的元素会脱离文档流（不占据空间），为了使父元素在视觉上包围浮动元素，W3School中给出的示例介绍了一种使用一个空元素来清理浮动的方法：<code>&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;</code>，<code>.clearfix {clear:both;}</code>。这个方法的缺点是会添加一个无意义的标签。</p><p>现在更常用的方法是在父容器上应用<code>.clearfix</code>类，HTML结构如下：</p><pre><code>&lt;div class=&quot;news clearfix&quot;&gt;    &lt;img src=&quot;/img/news.jpg&quot; class=&quot;pull-left&quot;&gt;    &lt;p class=&quot;pull-right&quot;&gt;Some text&lt;/p&gt;&lt;/div&gt;</code></pre><p>对应的clearfix类CSS代码：</p><pre><code>.clear:after {    content: &quot;.&quot;;    height: 0;    visibility: hidden;    display: block;    clear: both;}</code></pre><p>这个方法结合使用<code>:after</code>伪类在父容器末尾添加一个不引人注意的字符“.”（其他字符也可以，因为height为0且visibility为hidden是看不到的），然后通过将display设为block使被清理的元素在它们的margin-top添加了空间。这样设置之后就可以对生成的内容进行清理，又避免了添加空元素。这个方法除了IE6意外，在多数现代浏览器中是有效的。</p><p>参考资料：精通CSS:高级Web标准解决方案（第2版）第三章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 盒模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS学习笔记：选择器</title>
      <link href="/tech/web/css/css-selector/"/>
      <url>/tech/web/css/css-selector/</url>
      
        <content type="html"><![CDATA[<p>要将CSS样式应用于特定的HTML元素，需要想办法找到这个元素。在CSS中，执行这一任务的样式规则成为样式选择器（selector）。本文将介绍CSS常用选择器、高级选择器，层叠与特殊性计算，以及如何组织和维护样式表等内容。</p><a id="more"></a><h1 id="1-CSS选择器"><a href="#1-CSS选择器" class="headerlink" title="1. CSS选择器"></a>1. CSS选择器</h1><h2 id="1-1-常用选择器"><a href="#1-1-常用选择器" class="headerlink" title="1.1 常用选择器"></a>1.1 常用选择器</h2><ul><li>类型（元素）选择器：寻找特定类型的元素，如段落或标题元素。例如：<code>p {color: black;}</code></li><li>ID和类选择器：寻找具有指定ID或类名的元素，前者以井号<code>#</code>为前缀，后者以点号<code>.</code>为前缀。例如：<code>#intro {front-weight: bold;}</code>，<code>.date-posted {color: #ccc;}</code></li><li>后代选择器：寻找特定元素的后代，由两个选择器之间的空格表示。结合使用类、后代、类型选择器可以减少对ID或类选择器的过度依赖。例如：<code>#main-content h2 {font-size: 1.8em;}</code></li><li>通用选择器：匹配所有可用元素，由星号<code>*</code>表示。比较少用，通常用于重置全局样式。例如：<code>* {padding: 0; margin: 0;}</code>（删除浏览器默认的内外边距）</li></ul><h2 id="1-2-伪类选择器"><a href="#1-2-伪类选择器" class="headerlink" title="1.2 伪类选择器"></a>1.2 伪类选择器</h2><ul><li>链接伪类：可以改变超链接默认及访问后的样式，只能应用于a标签。例如：<code>a:link {color: blue;}</code>，<code>a:visited {text-decoration: none;}</code></li><li>动态伪类：<code>:hover</code>、<code>:active</code>、<code>focus</code>分别向鼠标悬停元素、激活的元素和拥有键盘输入焦点的元素提供样式。例如：<code>.btn:hover {color: blue;}</code></li></ul><h2 id="1-3-高级选择器"><a href="#1-3-高级选择器" class="headerlink" title="1.3 高级选择器"></a>1.3 高级选择器</h2><ul><li>子选择器：选择一个元素的所有孩子，由两个选择器之间<code>&gt;</code>分隔。<strong>后代选择器选择的是所有后代，子选择器选择的是直接后代</strong>。例如：<code>#nav&gt;li {padding-left: 20px;}</code></li><li>属性选择器：根据某个属性是否存在或属性的值来寻找元素。例如：<code>input[type=text] {font-size: 1.6em;}</code></li><li>毗邻元素选择器：选择一个紧跟在元素之后的第一个同胞元素，由两个选择器之间<code>+</code>分隔。例如：<code>h2+p {font-weight: bold;}</code></li></ul><p>还有很多其他的选择器在此不赘述，详细可以参考<a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">W3School CSS选择器</a>。</p><h1 id="2-层叠与特殊性计算"><a href="#2-层叠与特殊性计算" class="headerlink" title="2. 层叠与特殊性计算"></a>2. 层叠与特殊性计算</h1><p>CSS的选择器有这么多，要寻找同一元素可能有两个或更多的规则。CSS通过<strong>层叠</strong>（cascade）的过程来处理这种冲突。层叠给每种规则分配一个特殊性值，更特殊的选择器规则将优先被使用。如果两个规则的特殊性相同，则后定义的规则更优先。</p><p>特殊性的计算采用的是比10更高的未指定的基数，这能确保非常特殊的选择器（如ID选择器）不会被大量一般选择器（如类选择器）所超越。但是为了简化，如果选择器数量少于10个，可以以10为基数计算特殊性，这在日常使用中已经够用了。选择器的特殊性分4个成份等级a、b、c、d：</p><ol><li>如果样式是行内样式（即写在HTML代码中，如<code>&lt;div style=&quot;display:none;&quot;&gt;&lt;/div&gt;</code>），则a等于1</li><li>b等于ID选择器的总数</li><li>c等于类、伪类、属性选择器的数量</li><li>d等于元素（如HTML标签）和伪元素选择器的数量</li></ol><p>下表给出了一些特殊性的示例以加深理解。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/css/CSS%E7%89%B9%E6%AE%8A%E6%80%A7%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B.jpg" alt="CSS特殊性计算示例"></p><p>通过熟记以上4条规则，可以很快地计算出复杂CSS的特殊性。例如<code>#content div#main-content h2</code>的特殊性是0,2,0,2=202，<code>body #content div[id=&quot;main-content&quot;] h2</code>的特殊性是0,1,1,3=113。如果遇到了似乎没有起作用的CSS规则，很可能是出现了特殊性冲突，此时你可能需要重构CSS代码。</p><h1 id="3-关于继承"><a href="#3-关于继承" class="headerlink" title="3. 关于继承"></a>3. 关于继承</h1><p>人们常常将CSS中的<strong>继承</strong>和层叠混为一谈，实际上这两个概念很不一样。应用样式的元素后代会继承样式的某些属性，如颜色和字号。比如在body上设置文本颜色为黑色，则所有元素会显示黑色的文本。当然有时可能页面上一些标题没有采用继承字号，实际上是浏览器的默认样式表设置了标题的字号，直接应用于元素的样式总会覆盖继承来的样式，因为<strong>继承而来的样式特殊性为空</strong>。</p><h1 id="4-组织和维护样式表"><a href="#4-组织和维护样式表" class="headerlink" title="4. 组织和维护样式表"></a>4. 组织和维护样式表</h1><p>站点越大、越复杂，CSS就越难管理。正如使用模板引擎可以将HTML拆解成多个文件，使用模块化规范可以将Javascript划分为多个模块一样，CSS也可以从一个样式表中通过<code>@import url(&#39;my_css.css&#39;);</code>这样的语句来导入其他样式表，从而HTML中只需要链接一个主样式表文件。这样虽然也可以让CSS“模块化”，但是使用import语句会使加载更慢，多个文件会导致发起更多的HTTP请求，从而影响页面的加载速度。所以还是推荐在一个页面使用尽量少的CSS文件。</p><p>如果CSS文件非常长，那么寻找特定的样式就会很困难。一种改进方法对单个CSS文件分块进行必要的注释，如使用<code>/* @group typography */</code>这样带有<code>@group</code>标记的注释，并以<code>/* @group end */</code>作为结束。此外为了便于维护，最好把样式表划分为几大块，通常是把最一般的规则放在最前面，接着可能是全局重置央视，然后是链接、标题和其他元素。最后是一些特殊性样式，最后整个样式表可能像以下的结构：</p><ul><li>一般性样式<ul><li>主体样式</li><li>reset样式</li><li>链接、标题、其他元素</li></ul></li><li>辅助样式<ul><li>表单</li><li>通知和错误</li><li>按钮、其他</li></ul></li><li>页面结构<ul><li>标题、页脚、导航</li><li>布局</li><li>其他页面结构元素</li></ul></li><li>页面组件</li><li>覆盖</li></ul><p>当站点变得特别复杂时，往往一个页面一个CSS的方式会导致这个CSS文件特别庞大（几千行甚至上万行），当有多个开发人员同时编辑这个CSS文件时，经常会产生各种冲突而降低生产力。所幸现在有一种技术方案——CSS预处理器，可以完美解决以上各种问题。其中<a href="http://www.lesscss.net/" target="_blank" rel="noopener">LESS</a>和<a href="http://sass-lang.com/" target="_blank" rel="noopener">Sass</a>是用得最多的两款。具体什么是CSS预处理器以及如何使用请自行搜索。CSS预处理器的出现无疑大大提高了前端开发人员的生产效率，它可以让开发人员编辑多个文件，最后合并成一个CSS文件发布，既实现“模块化”，提高可维护性，又满足性能要求。同时CSS预处理器还提供许多极其方便的语法，大大简化样式文件的编写。</p><p>参考资料：精通CSS:高级Web标准解决方案（第2版）第二章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 选择器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS学习笔记：基本原则</title>
      <link href="/tech/web/css/css-basic-principles/"/>
      <url>/tech/web/css/css-basic-principles/</url>
      
        <content type="html"><![CDATA[<p>本文记录一些CSS的基本的但常常被误解的概念，并讨论如何让HTML和CSS保持清晰且结构良好，内容包括设计代码的结构、有意义文档的重要性、命名约定、何时使用ID和类名、文档类型和浏览器模式等。</p><a id="more"></a><h1 id="1-基本原则"><a href="#1-基本原则" class="headerlink" title="1. 基本原则"></a>1. 基本原则</h1><h2 id="1-1-使用有意义的HTML标记"><a href="#1-1-使用有意义的HTML标记" class="headerlink" title="1.1 使用有意义的HTML标记"></a>1.1 使用有意义的HTML标记</h2><p>早期的Web仅仅使用HTML来表现页面，经常使用字体和粗体标签来创建所需的视觉效果，而不只是用标题元素突出标题；表格成了一种布局工具而不是显示数据的方式；使用块引用（blockquote）来添加空白而不是表示引用……早期的Frontpage和Dreamweaver等编辑器能够通过简单的拖拽操作构建复杂的表格布局，但是<em>嵌套的表格</em>和<em>分隔线GIF</em>把代码弄得非常混乱，而且这些布局极其脆弱，很容易被破坏。HTML没有被当做简单的标记语言，许多人害怕直接编写网页代码，宁可依赖可视化编辑器。</p><p>在Web一团糟的背景下，CSS的出现使得Web开发者可以控制页面的外观，并将文档的表现部分与内容分隔开。只需要在一个地方进行修改，就能贯彻到整个站点，而且可以使用CSS而不是表格来控制布局。HTML标记返璞归真，又变得有实际意义了。与<em>表现性</em>的页面相比，<em>有意义</em>的页面更容易处理。HTML包含了丰富的有意义的元素，如：<code>h1</code>、<code>h2</code>、<code>ul</code>、<code>blockquote</code>、<code>abbr</code>、<code>strong</code>、<code>code</code>、<code>label</code>、<code>tbody</code>等等。如果元素有恰当的含义，就应该使用。</p><h2 id="1-2-ID和类名"><a href="#1-2-ID和类名" class="headerlink" title="1.2 ID和类名"></a>1.2 ID和类名</h2><p>有意义的标记可以提供良好的基础，但是可以用的元素还不够全面。HTML4是作为简单的文档标记语言创建的，而HTML5提供了更丰富的元素，如<code>header</code>、<code>nav</code>、<code>article</code>、<code>section</code>、<code>footer</code>等结构性元素。<br>次优的解决方案是使用现有的元素，如<code>div</code>、<code>ul</code>等等，然后通过添加ID或类名类赋予额外的意义，如<code>&lt;ul id=&quot;nav&quot;&gt;&lt;/ul&gt;</code>。当然是用ID是有一定局限性的，实际上CSS的最佳实践并不推荐使用ID，甚至有的CSS检查器默认会对使用ID提出警告。如果使用大量ID，很快就会难以找到唯一的名称，最终不得不创建很长很复杂的命名约定。只有在绝对确定这个元素只会出现一次的情况下才使用ID，如果不确定的话，应该首选CSS类，毕竟类是比较灵活和可复用性较强的。</p><h2 id="1-3-CSS类的命名和使用"><a href="#1-3-CSS类的命名和使用" class="headerlink" title="1.3 CSS类的命名和使用"></a>1.3 CSS类的命名和使用</h2><p>在分配ID和类名时，一定要尽可能保持名称与表现方式无关，应该根据<strong>它们是什么</strong>来为元素命名，而不是根据<strong>它们的外观如何</strong>来命名。例如要让一个表单通知消息显示红色，不应该分配类名<code>.red</code>，而是<code>.notification</code>之类有意义的名字，这样可以在整个网站中重用它们，修改起样式来也非常方便。关于CSS类（ID）的命名，推荐采用完全小写及多个单词之间用连字符分隔，如<code>.btn-primary</code>。</p><p>由于CSS类功能强大，所以它们可能被滥用。CSS新手常常在几乎所有东西上添加类，试图更精细地控制样式，这种现象被称为“多类症”。HTML代码应该保持干净整洁，尽量避免无意义的标记和属性。看看下面一段表示新闻的代码，其中就有点患了“多类症”：</p><pre><code>&lt;div class=&quot;news&quot;&gt;    &lt;h2 class=&quot;news-head&quot;&gt;...&lt;/h2&gt;    &lt;p class=&quot;news-text&quot;&gt;...&lt;/p&gt;    &lt;p class=&quot;news-text&quot;&gt;        &lt;a href=&quot;news.php&quot; class=&quot;news-link&quot;&gt;More&lt;/a&gt;    &lt;/p&gt;&lt;/div&gt;</code></pre><p>上述示例用了太多的CSS类名来区分每个元素，实际可以使用层叠（cascade来识别新闻标题和文本：</p><pre><code>&lt;div class=&quot;news&quot;&gt;    &lt;h2&gt;...&lt;/h2&gt;    &lt;p&gt;...&lt;/p&gt;    &lt;p&gt;&lt;a href=&quot;news.php&quot;&gt;More&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</code></pre><p>只要你发现类名中出现了重复的单词，就应该考虑是否可以把这些元素分解成它们的组成部分。以这种方式删除不必要的类有助于简化代码。如果你发现非得添加许多类才能解决问题，这很可能意味着你的HTML文档结构有问题。</p><h2 id="1-4-div和span"><a href="#1-4-div和span" class="headerlink" title="1.4 div和span"></a>1.4 div和span</h2><p>现代的Web开发都流行使用div标签来排版和布局，但是许多人误以为div元素没有语义。实际上div代表部分（division），它可以将文档分割成几个有意义的区域。为了将不必要的标记减到最少，应该只在没有现有元素能实现区域分割的情况下才使用div。</p><p>过度使用div被称为“多div症”，这是代码结构不合理而且过分复杂的一个信号。例如前端新手可能会这样写一个主导航列表：<code>&lt;div class=&quot;nav&quot;&gt;&lt;ul&gt;...&lt;/ul&gt;&lt;/div&gt;</code>，但这个div实际是完全没必要的，直接在ul上使用nav类。使用div应该根据条目的意义或功能，而不是根据表现方式或布局来进行分组。</p><p>div可以用来对块级元素分组，而span可以用来对行内元素分组。尽管目标是让代码尽可能简介或有意义，但是有时为了以自己希望的方式显示页面，无法完全避免添加额外的无语义的div或span，这样也不必过分为此担心。关键是要知道在什么时候进行折中。</p><h1 id="2-文档类型和浏览器模式"><a href="#2-文档类型和浏览器模式" class="headerlink" title="2. 文档类型和浏览器模式"></a>2. 文档类型和浏览器模式</h1><h2 id="2-1-文档类型"><a href="#2-1-文档类型" class="headerlink" title="2.1 文档类型"></a>2.1 文档类型</h2><p>DTD（文档类型定义）是一组机器可读的规则，它们定义XML或HTML的特定版本中允许和不允许有什么。浏览器解析网页时，将使用这些规则检查页面的有效性并采取相应的措施。DOCTYPE声明是指HTML文档开头处一两行描述使用哪个DTD的代码，浏览器通过DOCTYPE声明知道要使用HTML哪个版本。DOCTYPE有严格（strict）和过渡（transitional）两种风格，过渡DOCTYPE的目的是帮助开发人员从老版本迁移到新版本。</p><h2 id="2-2-浏览器模式"><a href="#2-2-浏览器模式" class="headerlink" title="2.2 浏览器模式"></a>2.2 浏览器模式</h2><p>浏览器厂商为了创建与标准兼容的浏览器并确保向后兼容，他们实现了标准模式和混杂模式（quirks mode）两种呈现模式。在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示，比如IE6的混杂模式使用了老式的专有盒模型。</p><p>浏览器会根据DOCTYPE是否存在及使用哪种DTD来选择呈现模式。书写包含正确的DTD的DOCTYPE才能让页面以标准模式呈现，否则将以混杂模<br>式呈现。一些常用的DOCTYPE声明可以参照<a href="http://www.w3schools.com/tags/tag_doctype.asp" target="_blank" rel="noopener">HTML DOCTYPE Declaration</a>。</p><p>参考资料：精通CSS:高级Web标准解决方案（第2版）第一章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记：顺序统计量</title>
      <link href="/tech/algorithm/order-statistics/"/>
      <url>/tech/algorithm/order-statistics/</url>
      
        <content type="html"><![CDATA[<p>在一个由n个元素组成的集合中，第i个<em>顺序统计量（order statistics）</em>是该集合中第i小的元素，例如第1个顺序统计量是最小值，第n/2个顺序统计量是中位数（当n是偶数时，中位数一般指i=n/2的那个数）。顺序统计量问题就是给定包含n个（互异的）数的集合和整数i，找出第i小的数。</p><p>解决这个问题最直接的办法就是先排序，再直接找出第i个元素即可，排序最快的时间复杂度是$O(n \log n)$。但其实还可以更快地找到第i个顺序统计量，本文将主要介绍一个实用的随机算法和确定性算法，它们都可以在$O(n)$的时间内解决这个问题。</p><a id="more"></a><h1 id="1-最小值和最大值"><a href="#1-最小值和最大值" class="headerlink" title="1. 最小值和最大值"></a>1. 最小值和最大值</h1><p>在一个有n个元素的集合中，需要做$n-1$次比较才能确定其最小（大）元素，这确实是最好的结果。但如果要同时找出最小值和最大值，通常的做法是对每一个输入的元素都与已知的min和max作比较，这样相当于独立完成两趟查找进行$2(n-1)$次比较。</p><p>事实上，只要记录已知的min和max，每次取2个元素进行比较，然后较小的和min进行比较，较大的和max进行比较，这样就实现了对每两个元素进行3次比较，总共只需要$3\left\lfloor {n/2} \right\rfloor $次比较。至于初始化min和max，如果n是奇数，可以初始化min和max都为集合的第一个数；如果n是偶数，则取前两个数进行比较，小的为min，大的为max。这种算法虽然也是渐近为$O(n)$的算法，但从比较次数来看要比暴力求解快上约25%。</p><h1 id="2-随机化选择算法"><a href="#2-随机化选择算法" class="headerlink" title="2. 随机化选择算法"></a>2. 随机化选择算法</h1><p>下面要介绍的选择第i小的算法，是基于<a href="/Tech/algorithm/quick-sort/">快速排序</a>的。在进行主元划分之后，快速排序会递归处理划分的两边，而随机化选择算法只处理划分的其中一边。该算法的可以以$O(n)$的时间找到第i小的元素。</p><p>快速排序的划分主元方法<code>partition</code>会选取一个主元pivot，并围绕着该主元实现了对子数组data[left…right]的重排。假设最终pivot会处于<strong>下标<code>pivotLastIndex</code>处（绝对位置，相对下标0而言）</strong>，以及<strong>下标<code>pivotRelativeIndex</code>处（相对位置，相对下标left而言）</strong>，则重排之后data[left…pivotLastIndex-1]的元素都会比pivot小，data[pivotLastIndex+1…right]的元素都会比pivot大。而我们要找第i小的元素，最理想的情况就是i等于pivotRelativeIndex刚好是要找的元素；要么i落在左部分，则递归地查找左部分第i小的元素；要么i落在右部分，则递归地查找右部分第i-pivotRelativeIndex小的元素。下面的代码展示了具体的随机化选择算法，因为数组下标都是从0开始的，所以要特别注意<strong>我们口头所说的第i小元素，在程序里面实际是第i-1小的元素，以及其他一些关于下标计算的细节</strong>。</p><pre><code>def randomizedSelect(data, left, right, i):    # 递归中止条件：数组只有1个元素    if right == left:        return data[left]    # pivotLastIndex是主元在data中的索引    pivotLastIndex = partition(data, left, right)    # pivotRelativeIndex是主元在data中相对于当前left的索引    pivotRelativeIndex = pivotLastIndex - left    if i == pivotRelativeIndex:        # 主元的绝对位置刚好是要查找的第i小元素        return data[pivotLastIndex]    elif i &lt; pivotRelativeIndex:        # 第i小的元素位于左半部分，递归查找左半部分的第i小的元素        return _randomizedSelect(data, left, pivotLastIndex - 1, i)    else:        # 第i小的元素位于右半部分，递归查找右半部分的第i-pivotRelatvieIndex小的元素        return _randomizedSelect(data, pivotLastIndex + 1, right, i - pivotRelativeIndex - 1)</code></pre><p>运行时间分析：最好的情况就是每次选到的pivot都是数组的中位数。$T(n) \le T({n \over 2}) + O(n)$，根据主方法第2种情况，运行时间为$O(n)$。随机化选取基准，和随机化快排一样，平均运行时间也是$O(n)$。最坏情况下，每次划分都极不走运地总是按余下元素中最大的来进行划分，这样就会和快速排序一样退化到$O(n^2)$。</p><h1 id="3-确定性选择算法"><a href="#3-确定性选择算法" class="headerlink" title="3. 确定性选择算法"></a>3. 确定性选择算法</h1><p>从上面的分析可以看出<code>randomizedSelect</code>算法可能出现最坏情况的原因是<code>partition</code>有可能划分得不够理想。而确定性选择算法<code>deterministicSelect</code>则对<code>partition</code>算法进行修改，使用<em>中位数的中位数</em>作为pivot，使得每次划分都尽量让pivot把数组划分成1:1的状态。</p><p>在快速排序中，定义了<code>partition</code>方法大致如下：</p><pre><code>def partition(data, left, right):    # 选取主元    pivotIndex = chooseRandomPivotIndex(left, right)    # 后面省略...</code></pre><p>确定性选择算法是把<code>chooseRandomPivotIndex</code>换成可以选择中位数的中位数的<code>chooseMedianPivotIndex</code>，算法流程如下：</p><ol><li>将n个元素划分为m=n/5组，每组5个元素（最多有一组由剩下的n mod 5个元素组成）</li><li>对m组元素都进行插入排序（每组只有5个数所以很快），再找出各组的中位数，共m个</li><li>m个中位数组成临时数组C，递归调用deterministicSelect找出C的中位数</li><li>中位数的索引作为chooseMedianPivotIndex的返回结果</li></ol><p>确定性选择算法最坏情况也可以达到$O(n)$，<strong>但实际并没有随机算法快，因为它忽略的常数项更大，而且要多耗费存储空间。</strong></p><p>参考文献：机械工业出版社《算法导论（第3版）》第9章  </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 顺序统计量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记：堆排序</title>
      <link href="/tech/algorithm/heap-sort/"/>
      <url>/tech/algorithm/heap-sort/</url>
      
        <content type="html"><![CDATA[<p>相比归并排序和快速排序，本文将介绍另一种平均时间复杂度是$O(n \log n)$的排序方法——堆排序（Heap Sort）。堆排序使用了一种被称为“堆”的数据结构，这也是它相比其他两种排序方法的特殊之处。堆这种数据结构不仅可以用于排序，也可以用来维护优先级队列。本文最后还简要对比了快速排序和堆排序的优缺点。</p><a id="more"></a><h1 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h1><h2 id="1-1-堆的性质"><a href="#1-1-堆的性质" class="headerlink" title="1.1 堆的性质"></a>1.1 堆的性质</h2><p>堆是一棵<strong>完全二叉树</strong>，实际中可以通过一个数组来实现，它最重要的一个性质是：<strong>任意节点都小于（大于）等于其子节点</strong>。将根节点最小的堆称为最小堆，根节点最大的堆称为最大堆。下图给出了一个最大堆的示例及其数组表示，可以直观地看出每个节点都比它的孩子们都要大。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/algorithm/%E6%9C%80%E5%A4%A7%E5%A0%86%E7%A4%BA%E4%BE%8B%E5%8F%8A%E5%85%B6%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA.jpg" alt="最大堆示例及其数组表示"></p><p>在上图中可以看到，完全二叉树的节点可以从根节点编号为1开始按顺序排列，对应数组A中的索引（注意此处下标是从1开始的）。给定一个节点<code>i</code>，我们很容易可以得到它的左孩子是<code>2i</code>，右孩子是<code>2i+1</code>，父节点是<code>i/2</code></p><h2 id="1-2-堆的基本操作"><a href="#1-2-堆的基本操作" class="headerlink" title="1.2 堆的基本操作"></a>1.2 堆的基本操作</h2><p>堆有两种基本操作（下面以最小堆为例）：</p><ul><li>插入元素k：直接将k添加到数组最后，然后向上冒泡（bubble-up）调整堆。<strong>向上冒泡操作：将要调整的元素与其父节点比较，如果大于其父节点则交换，直到恢复堆的性质</strong></li><li>提取最值：最值即根元素。然后将其删除，令根元素=最后的叶子结点元素，然后从根元素开始向下冒泡（bubble-down）调整堆。<strong>向下冒泡操作：每次应该从要调整节点，其左右孩子一共三个节点中选择最小的子节点来交换（如果最小就是其本身就不用交换），直到恢复堆的性质</strong></li></ul><p>实际中经常需要将一个包含n个元素无序数组建立成堆，下面的Heap类中的构造方法将展示如何通过<code>_bubbleDown</code>向下冒泡调整来建堆。堆实质上是一棵完全二叉树，树高总为$\log n$，每种基本操作的耗时操作都在于冒泡调整以满足堆的性质，因此它们的时间复杂度都是$O(n \log n)$。</p><pre><code>class Heap():    def __init__(self, heap=[]):        self._heap = heap        # 从堆的一半开始逐个节点向前调整        # （因为完全二叉树的后一半节点都是叶子节点，不需要调整）        for i in reversed(xrange(len(self._heap) / 2)):            self._bubbleDown(i)    def insert(self, data):        &quot;&quot;&quot;在堆中插入一个元素&quot;&quot;&quot;        self._heap.append(data)        self._bubbleUp(len(self._heap) - 1)    def extract(self):        &quot;&quot;&quot;提取堆的最值&quot;&quot;&quot;        # 根元素总是堆的最值        result = self._heap[0]        if self.size() &gt; 1:            # 交换根元素和最后一个元素，并删除掉最后一个元素            self._heap[0] = self._heap.pop()            # 交换之后可能会破坏堆的性质，需要向下调整根元素            self._bubbleDown(0)        return result    def _bubbleUp(self, i):        &quot;&quot;&quot;对指定下标的元素向上进行调整，以维护堆的性质&quot;&quot;&quot;        parent = (i - 1) / 2        # 冒泡终止条件：到达根节点或者已满足堆的性质        while parent &gt;= 0:            if self._heap[i] &lt; self._heap[parent]:                self._heap[i], self._heap[parent] = self._heap[parent], self._heap[i]                i = parent                parent = (i - 1) / 2            else:                break    def _bubbleDown(self, i):        &quot;&quot;&quot;对指定下标的元素向下进行调整，以维护堆的性质&quot;&quot;&quot;        smallest = i        # 注意此处左右孩子的算法和教科书不太一样，因为实际数组下标是从0开始        left, right = 2 * i + 1, 2 * i + 2        # 找出i，left，right三个元素最小的一个        if left &lt; self.size() and self._heap[left] &lt; self._heap[smallest]:            smallest = left        if right &lt; self.size() and self._heap[right] &lt; self._heap[smallest]:            smallest = right        if smallest != i:            # 交换位置，并递归地继续向下冒泡调整            self._heap[i], self._heap[smallest] = self._heap[smallest], self._heap[i]            self._bubbleDown(smallest)</code></pre><h2 id="1-3-堆排序"><a href="#1-3-堆排序" class="headerlink" title="1.3 堆排序"></a>1.3 堆排序</h2><p>有了上面定义的Heap类之后，堆排序将变得非常简单。堆的性质决定了其根元素总是最小值，而Heap类的<code>extract</code>方法总是完成提取最小值并调整堆的操作，因此使用堆来排序只需要先建堆，再执行n次<code>extract</code>操作即可，堆排序的时间复杂度是$O(n \log n)$。</p><pre><code>def heapSort(data):    heap = Heap(data)    return [heap.extract() for i in xrange(len(data))]</code></pre><p>实际上，堆排序的原理非常像$O(n^2)$的选择排序——两者每一轮都选择最小的一个数，只不过堆排序选择这个数（并调整堆）只要花费$O(\log n)$，而选择排序选择这个数要遍历所有的数花费$O(n)$。</p><h1 id="2-堆的应用：优先队列"><a href="#2-堆的应用：优先队列" class="headerlink" title="2. 堆的应用：优先队列"></a>2. 堆的应用：优先队列</h1><p>优先队列（priority queue）实际上也是由堆来实现，所以有最大优先队列和最小优先队列两种。优先队列的其中一个应用就是在共享计算机系统的作业调度。最大优先队列记录将要指定的各个作业及它们之间的相对优先级。当一个作业完成或者被中断后，调度器调用<code>extract</code>从所有的等待作业中，选出具有最高优先级的作业来执行。在任何时候，调度器可以调用<code>insert</code>把一个新作业加入到队列中来。</p><p>最小优先队列可以诶用于基于事件驱动的模拟器，队列中保存要模拟的事件，每个事件都有一个发生时间作为其<em>关键字</em>。事件必须按照发生的时间顺序模拟，而某一事件的模拟结果可能会触发其他事件。模拟程序调用<code>extract</code>来选择下一个要模拟的事件，当一个新事件产生时，模拟程序调用<code>insert</code>将其插入最小优先队列中。</p><p>从上面的应用可以看出，<strong>堆最好用的地方在于其提取最值的速度非常快。因此当算法中需要不断重复计算获取最小（大）值时，就可以考虑使用堆这种数据结构。</strong></p><h1 id="3-堆排序和快速排序的比较"><a href="#3-堆排序和快速排序的比较" class="headerlink" title="3. 堆排序和快速排序的比较"></a>3. 堆排序和快速排序的比较</h1><p>尽管堆排序和快速排序都是$O(n \log n)$的排序算法，但这只是算法渐近的趋势，实际上它们的性能（主要表现在常数因子上）还是有一些区别的。下表给出了快速排序、堆排序和插入排序比较次数和交换次数的对比：（数据来自<a href="https://www.cs.auckland.ac.nz/~jmor159/PLDS210/qsort3.html" target="_blank" rel="noopener">Comparing Quick and Heap Sorts</a>）</p><table class="table table-bordered responsive" border="1"><br>  <tbody><tr><th rowspan="2"><i>数据规模</i></th><br>   <th colspan="2">快速排序</th><br>   <th colspan="2">堆排序</th><br>   <th colspan="2">插入排序</th></tr><br>   <tr><th>比较次数</th><th>交换次数</th><br>    <th>比较次数</th><th>交换次数</th><br>    <th>比较次数</th><th>交换次数</th></tr><br>    <tr><td>100</td><td>712</td><td>148</td><td>2,842</td><td>581</td><td>2,595</td><td>899</td></tr><br>    <tr><td>200</td><td>1,682</td><td>328</td><td>9,736</td><td>1,366</td><td>10,307</td><td>3,503</td></tr><br>    <tr><td>500</td><td>5,102</td><td>919</td><td>53,113</td><td>4,042</td><td>62,746</td><td>21,083</td></tr><br></tbody></table><p>可见快速排序的比较次数和交换次数都要比堆排序少，性能更优，这也是为什么多数商业应用选择快速排序作为排序算法的原因。然而，当实际应用中<strong>需要保证一定的响应时间</strong>时，就不应该使用快速排序，因为它最坏情况下是一个$O(n^2)$的算法（要记住在某些应用中最坏情况是会经常出现的，这时候你就不能依赖快速排序的平均性能）。如果数据规模n比较少，插入排序是更好的选择，因为它的代码非常简单，而且常数因子也更小。如果n很大，毫无疑问应该选择堆排序，它保证了$O(n \log n)$的时间复杂度。在一些像医疗监控、航天航空、工业生产等有关键任务的行业系统中，必须总是考虑最坏情况的出现，而不是平均情况。</p><p>参考文献：机械工业出版社《算法导论（第3版）》第6章  </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记：快速排序</title>
      <link href="/tech/algorithm/quick-sort/"/>
      <url>/tech/algorithm/quick-sort/</url>
      
        <content type="html"><![CDATA[<p>通常算法初学者都会接触到形形色色的排序算法，例如插入排序、选择排序、冒泡排序等等，这些排序算法都非常容易理解和上手，但是它们的时间复杂度是$O(n^2)$的。本文将介绍快速排序，同归并排序一样，它的时间复杂度是$O(n \log n)$。</p><p>对于包含n个数的输入数组来说，快速排序是一种最坏情况运行时间为$O(n^2)$的算法，但<strong>它通常是实际应用中最常用的排序算法</strong>，因为它的平均性能是$O(n \log n)$的，而且隐含的常数因子非常小，并能够进行原址排序。</p><a id="more"></a><h1 id="1-快速排序思想"><a href="#1-快速排序思想" class="headerlink" title="1. 快速排序思想"></a>1. 快速排序思想</h1><p>与归并排序一样，快速排序也使用了分治法的思想，依然遵循分治法三部曲：</p><ul><li>分解：选定数组A中一个元素A[m]，A[l…r]被划分为两个（可能为空）子数组，其中数组A[l…m-1]所有元素都小于等于A[m]，数组A[m+1…r]所有元素都大于等于A[m]。计算下标m也是分解过程的一部分。</li><li>解决：对两个子数组递归A[l…m-1]和A[m+1…r]调用快速排序</li><li>合并：子数组都是原址排序，不需要合并操作，A[l…r]本身已有序</li></ul><p>算法的关键在于选取主元（pivot element），即上面提到的划分数组的元素。例如对[3,8,2,5,1,4,7,6]进行第一趟快速排序，<br>选择第一个元素3作为主元，左边都是小于3的元素，右边都是大于3的元素，即[2,1,3,6,7,4,5,8]，接着再对左右两部分（[2,1]和[6,7,4,5,8]）递归调用快速排序。快速排序核心算法如下：</p><pre><code>def quickSort(data, left, right):    # 递归中止条件：数组只有1个元素    if left &lt; right:        pivotLastIndex = partition(data, left, right)        quickSort(data, left, pivotLastIndex - 1)        quickSort(data, pivotLastIndex + 1, right)</code></pre><h1 id="2-选取主元和重排"><a href="#2-选取主元和重排" class="headerlink" title="2. 选取主元和重排"></a>2. 选取主元和重排</h1><p>其中算法的关键部分是partition方法，该方法选取一个主元，并围绕着该主元实现了对子数组data[left…right]的重排。partition方法如下：</p><pre><code>def partition(data, left, right):    # 选取主元    pivotIndex = chooseFirstPivotIndex(left, right)    pivot = data[pivotIndex]    # 预处理：将主元放到数组第一个位置    data[left], data[pivotIndex] = data[pivotIndex], data[left]    # 从左到右将未调整部分的元素放到已调整的部分中去    i, j = left + 1, left + 1    while j &lt;= right:        # 发现比主元小的元素，则将其交换到前面的位置        if data[j] &lt; pivot:            data[i], data[j] = data[j], data[i]            i += 1        j += 1    # 记住主元数一直都位于左边界，最后要把它放到合适的中间位置    pivotLastIndex = i - 1    data[left], data[pivotLastIndex] = data[pivotLastIndex], data[left]    return pivotLastIndexdef chooseFirstPivotIndex(left, right):    return left</code></pre><p>为了方便起见，上述partition方法中，一直都选取第一个元素作为主元（<code>chooseFirstPivotIndex</code>方法），后面会看到总是选取第一个元素作为主元并不是最优的选择。<strong>如果不是选择第一个元素作为主元，我们都将主元换到第一个位置方便处理。</strong>partition方法运用了一种巧妙的方式（使用i,j两个指针）确保只要用$O(n)$的时间就能重排data[left…right]，使得data呈现[小于pivot元素，pivot，大于pivot元素]的排列方式。</p><p>将数组看做<code>[p, ...&lt;p..., ...&gt;p..., ...rest...]</code>，p为主元，<code>&lt;p</code>和<code>&gt;p</code>部分为已调整元素，<code>rest</code>部分为未调整元素。整个重排过程就是从左到右将未调整部分的元素放到已调整的部分中去。令i和j都为1：<br>当A[j]&gt;p时：j++<br>当A[j]&lt;p时：交换A[j]和A[i]，i++，j++  </p><p>通过下面的图例可以比较清晰地看到partition具体的重排过程。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/algorithm/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%80%E8%B6%9F%E9%87%8D%E6%8E%92%E7%A4%BA%E4%BE%8B.jpg" alt="快速排序一趟重排示例"></p><h1 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3. 性能分析"></a>3. 性能分析</h1><p>当数组接近逆序时，选取第一个元素作为主元的方案会使快排的时间上升到$O(n^2)$，因为逆序的数组第一个元素会重排剩余的所有元素，而剩余的元素又全都是逆序的。为了解决这个问题，可以每次都随机选取数组内的一个元素作为主元。在上面的代码中，只需要将<code>chooseFirstPivotIndex</code>方法换成下面的<code>chooseRandomPivotIndex</code>方法即可：</p><pre><code>def chooseRandomPivotIndex(left, right):    import random    return random.choice(range(left, right + 1))</code></pre><p>证明：随机化快速排序算法的运行时间为$O(n \log n)$。</p><p>1、 令$C(\sigma )$=选取的主元为$\sigma $时快排的比较次数，${z_i}$=数组中第i小的元素，$X_{ij}(\sigma )$=选取的主元为$\sigma $时，${z_i}$和${z_j}$比较的次数。<strong>注意：数组中任意两个元素之间比较最多只有1次（因为当其中1个元素被选为主元时，必定会比较一次，如果2个元素都不是主元，它们不会被比较到）</strong>，则有：</p><p>$$\forall \sigma ,C(\sigma ) = \sum\limits_{i = 1}^{n - 1} {\sum\limits_{j = i + 1}^n { {X_{ij}}(\sigma )} } $$</p><p>$$E[C] = \sum\limits_{i = 1}^{n - 1} {\sum\limits_{j = i + 1}^n {E[{X_{ij}}] = } } \sum\limits_{i = 1}^{n - 1} {\sum\limits_{j = i + 1}^n { {P_r}[{X_{ij}} = 1]} } $$</p><p>2、只要计算第i小和第j小元素之间比较1次的概率。<br>关键：$\forall i &lt; j,{P_r}[{X_{ij}} = 1] = {2 \over {j - i + 1}}$<br>原因：考虑${z_i},{z_{i + 1}},…,{z_{j - 1}},{z_j}$（一共j-i+1个元素），<br>当选中的主元是${z_i}$或${z_j}$，那么${z_i}$和${z_j}$必定会比较到；当选中的主元是其它，那么${z_i}$和${z_j}$不会比较到，所以概率为${2 \over {j - i + 1}}$，所以</p><p>$$E[C] = 2\sum\limits_{i = 1}^{n - 1} {\sum\limits_{j = i + 1}^n { {1 \over {j - i + 1}}} } $$</p><p>3、对于每个固定的i，有$\sum\limits_{j = i + 1}^n { {1 \over {j - i + 1}}}  = {1 \over 2} + {1 \over 3} + … + {1 \over n} = \sum\limits_{k = 2}^n { {1 \over k}}  \le \ln n$</p><p>（关于$\sum\limits_{k = 2}^n { {1 \over k}}  \le \ln n$见下图解释）</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/algorithm/%E5%88%86%E6%95%B0%E6%B1%82%E5%92%8C%E4%B8%8D%E7%AD%89%E5%BC%8F%E5%9B%BE%E8%A7%A3.jpg" alt="分数求和不等式图解"></p><p>$$\sum\limits_{k = 2}^n { {1 \over k}}  \le \int_1^n { {1 \over x}dx = \ln x|_1^n = \ln n} $$</p><p>综上所述，$E[C] \le 2 \cdot n \cdot \ln n = O(n\log n)$</p><p>QED</p><p>参考文献：机械工业出版社《算法导论（第3版）》第7章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记：主方法</title>
      <link href="/tech/algorithm/master-method/"/>
      <url>/tech/algorithm/master-method/</url>
      
        <content type="html"><![CDATA[<p>上一篇<a href="/Tech/algorithm/divide-and-conquer/">算法学习笔记：分治法</a>中，介绍了分治法及一些常见的分治法案例。其中递归式与分治方法是紧密相关的，因为使用递归式可以很自然地刻画分治算法的运行时间。一般来说，求解递归式有“代入法”，“递归树法”和“主方法”。其中主方法用于方便地求解形如$T(n)=aT(n/b)+f(n)$的递归式。</p><p>本文将介绍主方法的一个“简化版本”，虽然是简化的，但它依然可以满足日常大多数的算法分析，并且更好理解其含义，最后再给出一个主方法的简要证明过程。</p><a id="more"></a><h1 id="1-主方法"><a href="#1-主方法" class="headerlink" title="1. 主方法"></a>1. 主方法</h1><h2 id="1-1-定理描述"><a href="#1-1-定理描述" class="headerlink" title="1.1 定理描述"></a>1.1 定理描述</h2><p>若算法的运行时间$T(n) \le aT({n \over b}) + O({n^d})$，其中$a \ge 1$是子问题个数，$b \ge 1$是输入规模减小的倍数，$d \ge 0$是递归过程之外的步骤的时间复杂度指数，则：</p><p>$$T(n) = \begin{cases} O(n^d \log n) &amp; a = {b^d} \cr O(n^d) &amp; a &lt; {b^d} \cr O({n^{ { {\log }_b }a } }) &amp; a &gt; {b^d} \end{cases}$$</p><p>可见主定理有三种情况。例如：</p><ol><li>归并排序：$T(n) = 2T({n \over 2}) + O(n), a=2, b=2, d=1$，则$T(n)=O(nlogn)$</li><li>$T(n) = 2T({n \over 2}) + O({n^2}), a=2, b=2, d=2$，则$T(n)=O({n^2})$</li><li>Strassen矩阵乘法：$T(n) = 7T({n \over 2}) + O({n^2}), a=7, b=2, d=2$，则$T(n)=O({n^{ { {\log }_2 }7 } })$</li></ol><h2 id="1-2-定理证明"><a href="#1-2-定理证明" class="headerlink" title="1.2 定理证明"></a>1.2 定理证明</h2><p>考虑下图中的递归树。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/algorithm/%E4%B8%BB%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E%E9%80%92%E5%BD%92%E6%A0%91.jpg" alt="主定理证明递归树"></p><ol><li>递归树的第j层（$j = 0,1, \cdots ,{ {\log }_b}n$），一共有${a^j}$个子问题，</li><li>每个子问题的规模是$n/{b^j}$。</li><li>对于第j层的1个子问题，递归之外所做的工作不会超过$c \cdot {({n \over { {b^j}}})^d}$</li><li>第j层工作量上界为${a^j} \cdot c \cdot {({n \over { {b^j}}})^d} = c{n^d} \cdot {({a \over { {b^d}}})^j}$  <strong>①</strong></li><li>所有层总的工作量上界为$c{n^d} \cdot \sum\limits_{j = 0}^{ { {\log }_b}n} { { {({a \over { {b^d}}})}^j}} $  <strong>②</strong></li></ol><p>【补充知识：等比数列求和<br>对于$S = \sum\limits_{i = 0}^k { {r^i}}  = { { {r^{k + 1}} - 1} \over {r - 1}}$<br>当$0 \le r &lt; 1$时，$S \le {1 \over {1 - r}}$，这是一个常量<br>当$r=1$时，$S=k+1$<br>当$r&gt;1$时，$S \le {r^k} \cdot (1 + {1 \over {r - 1}})$ 】</p><p>对①式的解释：$a$为子问题的增长率（rate of subproblem proliferation, RSP），$b^d$为每个子问题工作量的缩减率（rate of work shrinkage, RWS）  </p><ol><li>主定理第一种情况：当RSP=RWS时，每一层的工作量不变。此时②=$c{n^d} \cdot ({ { {\log }_b}n} + 1) = O({n^d}\log n)$  </li><li>主定理第二种情况：当RSP&lt;RWS时，每一层工作量逐渐减少（最大工作量在第0层），总工作量取决于第0层的工作量。注意到②式的求和部分上界为常量，所以②=$O({n^d})$  </li><li>主定理第三种情况：当RSP&gt;RWS时，每一层工作量逐渐增加（最大工作量在叶子结点）。注意到②式的求和部分上界为$S \le {r^k} \cdot (1 + {1 \over {r - 1}})$，是与k有关的常量，显然最大的常量为$k = {\log _b}n$的时候。  </li></ol><p>$$ \eqalign{<br>  &amp;  ② = O({n^d} \cdot {({a \over { {b^d}}})^{ { {\log }_b}n}})<br>  &amp;  = O({n^d} \cdot {a^{ { {\log}_b}n}} \cdot {b^{ {-d} { { {\log }_b}n}}} )  \cr<br>  &amp;  = O({n^d} \cdot {a^{ { {\log }_b}n}} \cdot {n^{ - d}})  \cr<br>  &amp;  = O({a^{ { {\log}_b}n}}) = O({n^{ { {\log}_b}a}}) \cr} $$</p><p>显然${a^{ { {\log}_b}n}}$代表叶子结点数。最后两个等号的转换只要两边同时取对数b即可。QED</p><p>总结：通过以上对主定理的简单证明，我们可以更加深入地理解分治法的本质。对于$T(n)=aT(n/b)+O({n^d})$，$a$为子问题的增长率，$b^d$为每个子问题工作量的缩减率，这两者之间的大小将决定算法时间复杂度由哪一部分起更大的主导作用。由于渐近记号会忽略各种低阶项，所以随着递归树层数的深入，当每一层工作量逐渐减少时，顶层原问题占主导地位；当每一层工作量逐渐增加时，底层子问题占主导地位；当每一层工作量都不变时，则要将每层的工作量都加起来。</p><p>参考文献：机械工业出版社《算法导论（第3版）》4.5节，4.6节</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 主方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记：分治法</title>
      <link href="/tech/algorithm/divide-and-conquer/"/>
      <url>/tech/algorithm/divide-and-conquer/</url>
      
        <content type="html"><![CDATA[<p>在计算机科学中，分治法是一种很重要的算法。分治法字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到最后子问题可以简单地直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如归并排序、快速傅立叶变换等。</p><p>本文将简要介绍分治法的基本步骤，再以归并排序为例，介绍分治法的具体应用以及如何分析其时间复杂度。最后再介绍几个用分治法解决的算法案例。</p><a id="more"></a><h1 id="1-分治法思想"><a href="#1-分治法思想" class="headerlink" title="1. 分治法思想"></a>1. 分治法思想</h1><p>分治法所能解决的问题一般具有以下几个特征：</p><ul><li>问题的规模缩小到一定的程度就可以容易地解决</li><li>问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质</li><li>利用该问题分解出的子问题的解可以合并为该问题的解</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题</li></ul><p>分治法的三个步骤是：</p><ol><li>分解（Divide）：将原问题分解为若干子问题，这些子问题都是原问题规模较小的实例。</li><li>解决（Conquer）：<strong>递归</strong>地求解各子问题。如果子问题规模足够小，则直接求解。</li><li>合并（Combine）：将所有子问题的解合并为原问题的解</li></ol><h1 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2. 归并排序"></a>2. 归并排序</h1><h2 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h2><p>归并排序（Merge Sort）完全遵循上述分治法三个步骤：</p><ol><li>分解：将要排序的n个元素的序列分解成两个具有n/2个元素的子序列</li><li>解决：使用归并排序分别递归地排序两个子序列</li><li>合并：合并两个已排序的子序列，产生原问题的解</li></ol><p>归并排序的算法思想，看看下面的图解示例就明白了。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/algorithm/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.png" alt="归并排序图解"></p><p>算法的主要过程代码如下所示：</p><pre><code>def mergeSort(data):# 分别归并排序左半部分和右半部分，再合并if len(data) &gt; 1:    leftList = mergeSort(data[:len(data) / 2])    rightList = mergeSort(data[len(data) / 2:])    return merge(leftList, rightList)# 递归中止条件：数组只有1个元素else:    return data# 使用方法result = mergeSort([2, 4, 7, 5, 8, 1, 3, 6])</code></pre><p>注意上述代码只是归并排序的主要过程，其中最核心的是<code>merge</code>函数，它把两个<strong>已经有序</strong>的数组合并成一个有序数组。例如<code>print merge([1, 3, 5], [2, 4, 6])</code>将输出<code>[1, 2, 3, 4, 5, 6]</code>。合并过程非常简单，就是用两个指针分别指向两个子数组第一个元素，然后总是把小的数字填入结果中并将对应指针往右移一位；如果其中一个指针到头了，则直接把另外一个指针没到头的数组的剩余元素填入结果。</p><pre><code>def merge(leftList, rightList):result, i, j = [], 0, 0# 合并完的数组的长度肯定是两个子数组的长度之和for k in range(len(leftList) + len(rightList)):    # 两个下标均在两个数组范围之内，则取小的填入结果数组    if i &lt; len(leftList) and j &lt; len(rightList):        if leftList[i] &lt;= rightList[j]:            result.append(leftList[i])            i += 1        else:            result.append(rightList[j])            j += 1    # 最后可能其中一个数组还有剩余的部分，将其剩余部分依次填入结果数组    else:        result.append(leftList[i] if i &lt; len(leftList) else rightList[j])        i += 1        j += 1return result</code></pre><h2 id="2-2-算法分析"><a href="#2-2-算法分析" class="headerlink" title="2.2 算法分析"></a>2.2 算法分析</h2><p>归并排序在元素的数量不是偶数的情况下也能正常工作，不过为了分析方便，我们假定原问题规模n是2的幂。下面我们分析归并排序n个数在最坏情况下的运行时间$T(n)$。按照分治法三部曲：分解仅计算子数组的中间位置，花费常量时间$\Theta (1)$；递归解决两个规模为n/2的子问题，总共花费$2T(n/2)$；合并两个长度为n/2的数组过程，注意到如果采用上述双指针的方法，每个元素最多只要访问一次就能合并完，因此花费$\Theta (n)$。另外，如果n=1时直接返回，花费常量时间$\Theta (1)$。所以归并排序最坏情况运行时间的递归式为：</p><p>$$T(n) = \cases{ {\Theta (1)} &amp; n=1 \cr {2T(n/2) + \Theta (n)} &amp; n&gt;1 }$$</p><p>由上述归并排序图解可见，分解问题的过程实际上形成了一棵递归树。对于归并排序算法的递归树，假设树根（原问题）的规模为n（Level 0），则下一层有2个规模为n/2的子问题，再下一层有4个规模为n/4的子问题……</p><p>递归树一共有$\log n + 1$层，递归树的第$j$层（$j = 0,1, \cdots ,\log n$），一共有$2^j$个子问题，每个子问题的规模是$n/2^j$，解决该子问题所花费的时间为$\Theta (n/2^j)$。所以每一层所花时间为$2^j * \Theta (n/2^j) = \Theta (n)$，一共有$\log n$层，所以总的时间复杂度是$\Theta (nlogn)$。</p><p>当然，对于上面这种递归式，可以用一种通用的方法<strong>主方法（Master Method）</strong>来求解。关于主方法的说明会另外开一篇博文介绍。</p><h1 id="3-分治法案例"><a href="#3-分治法案例" class="headerlink" title="3. 分治法案例"></a>3. 分治法案例</h1><h2 id="3-1-最大子数组问题"><a href="#3-1-最大子数组问题" class="headerlink" title="3.1 最大子数组问题"></a>3.1 最大子数组问题</h2><p><em>问题：一个包含n个整数（有正有负）的数组A，找出<strong>和最大</strong>的<strong>非空连续子数组</strong>。</em>（例如：[0, -2, 3, 5, -1, 2]应返回9，[-9, -2, -3, -5, -3]应返回-2。）</p><p>基本解法：暴力求解找出所有子数组（$\Theta (n^2)$），对每个子数组求和（$\Theta (n)$），总复杂度是$\Theta (n^3)$。在遍历过程中，这些子数组的和是有重复计算的。下标i与j的区间和<code>sum[i][j] = sum[i][j - 1] + A[j]</code>，所以子数组求和变为$\Theta (1)$，时间复杂度降为$\Theta (n^2)$。</p><p>分治解法：要寻找A[left…right]的最大子数组，可以在中点mid处将A一分为二成A[left…mid]和A[mid+1…right]。A[left…right]的最大子数组必定是以下三者之一：</p><ol><li>完全位于A[left…mid]</li><li>完全位于A[mid+1…right]</li><li>跨越了中点，即最大子数组的左边界落在left和mid之间，右边界落在mid和right之间</li></ol><p>1和2两种情况可以通过递归调用来查找最大子数组，所以关键是3这个“合并”的步骤。因为跨越中点的子数组都由两个子数组A[i…mid]和A[mid…j]组成，所以我们可以从mid这个位置开始，分别向前和向后查找两个以mid为界的最大子数组，最后把这两个子数组合并成A[i…j]这个跨越中点的最大子数组即可。最后，问题的解就是上述三种情况里面和最大的那个子数组，总的时间复杂度是$\Theta (nlogn)$。</p><p>其实最大子数组问题还有DP解法和$\Theta (n)$的解法，详见<a href="http://www.cnblogs.com/zghaobac/p/3315719.html" target="_blank" rel="noopener">这篇博文</a></p><p>$T(n) = O(f(n))$</p><h2 id="3-2-逆序对问题"><a href="#3-2-逆序对问题" class="headerlink" title="3.2 逆序对问题"></a>3.2 逆序对问题</h2><p><em>问题：给定一个长度为n的整数数组A，找出“逆序对”的个数。对下标i,j，当i&lt;j时A[i]&gt;A[j]，则(A[i], A[j])称为“逆序对”。</em>（例如：[1, 3, 5, 2, 4, 6]的逆序对为(3,2), (5,2), (5,4)一共3个）</p><p>使用分治法找逆序对个数的思想其实和最大子数组问题几乎一样：把数组对半切分，递归统计左半部分的个数，右半部分的个数，以及跨越中点的个数（即i&lt;mid&lt;j），所以关键点还是在于如何实现子问题的合并。合并的时候像归并排序一样排序，例如在上例中，将[1,3,5]和[2,4,6]合并的同时，当j指向2时，i已指向3，此时剩余的3和5都可以组成反转数对；当j指向4时，i已指向5，此时5可以组成反转数对。依次类推，在合并过程中不断统计i及其右边剩余的个数。</p><h2 id="3-3-Strassen矩阵乘法"><a href="#3-3-Strassen矩阵乘法" class="headerlink" title="3.3 Strassen矩阵乘法"></a>3.3 Strassen矩阵乘法</h2><p>问题：两个n*n的矩阵A和B相乘。</p><p>矩阵乘法公式：${z_{ij}} = \sum_{k=1}^n { {x_{ik} }{ y_{kj} } } $，时间复杂度为$\Theta (n^3)$。一种分治法将矩阵分成四块，如下所示：</p><p>$$X = \left[ {\matrix{<br>   A &amp; B  \cr<br>   C &amp; D  \cr<br> } } \right],Y = \left[ {\matrix{<br>   E &amp; F  \cr<br>   G &amp; H  \cr<br> } } \right],XY = \left[ {\matrix{<br>   {AE + BG} &amp; {AF + BH}  \cr<br>   {CE + DG} &amp; {CF + DH}  \cr<br> } } \right]$$</p><p>采用上述分块矩阵的做法，要递归调用8次，时间复杂度仍然为$\Theta (n^3)$。Strassen矩阵乘法是利用下述公式计算矩阵相乘：</p><p>$$ {P_1} = A(F - H),{P_2} = (A + B)H,{P_3} = (C + D)E,{P_4} = D(G - E) $$</p><p>$$ {P_5} = (A + D)(E + H),{P_6} = (B - D)(G + H),{P_7} = (A - C)(E + F) $$</p><p>$$XY = \left[ {\matrix{<br>   {AE + BG} &amp; {AF + BH}  \cr<br>   {CE + DG} &amp; {CF + DH}  \cr<br> } } \right] = \left[ { \matrix{<br>   { {P_5} + {P_4} - {P_2} + {P_7} } &amp; { {P_1} + {P_2} }  \cr<br>   { {P_3} + {P_4} } &amp; { {P_1} + {P_5} - {P_3} - {P_7} }  \cr<br> } } \right]$$</p><p>只需要递归调用7次即可。该算法时间复杂度约为$\Theta (n^{2.81})$，比$\Theta (n^3)$要更加理想。</p><p>参考文献：机械工业出版社《算法导论（第3版）》2.3节，第4章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记：渐进分析</title>
      <link href="/tech/algorithm/asymptotic-analysis/"/>
      <url>/tech/algorithm/asymptotic-analysis/</url>
      
        <content type="html"><![CDATA[<p>当算法问题的规模很小的时候，基本上在任何一台机器上都会以很快的速度计算出来，只有在问题规模较大的时候分析算法的效率才显得有意义。因此我们要研究算法的<strong>渐进</strong>效率，也就是关心问题的输入规模趋向无穷大时，算法的运行时间是如何增长的。</p><p>本文将以插入排序为例，简要分析其运行时间。这种分析将引入一种关注时间如何随着输入规模增加而增加的记号。在此基础上，再给出几种标准方法来简化算法的渐进分析。</p><a id="more"></a><h1 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1. 插入排序"></a>1. 插入排序</h1><h2 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h2><p>插入排序的工作方式就像你排序手中的扑克牌一样（假设从左到右是从小到大），一开始手中没有牌，每次拿到一张新的牌都要从右到左与每张牌比较，并将其插入到合适的位置（比它大的牌也顺势后移）。以下是Python代码：</p><pre><code>def insertionSort(data):    # 初始化结果为第一个数    result = [data[0]]    # 从第二个数开始，从后往前找应该插入的位置    for key in data[1:]:        index = len(result) - 1        while index &gt;= 0 and result[index] &gt; key:            index -= 1        else:            result.insert(index + 1, key)    return result</code></pre><p>注：上述代码使用了Python list的insert方法在特定位置插入一个数（其他数字顺势往后移），如果是用C/C++之类普通的数组可能需要自己手动来后移其他数字。</p><h2 id="1-2-算法分析"><a href="#1-2-算法分析" class="headerlink" title="1.2 算法分析"></a>1.2 算法分析</h2><p>即使对给定规模的输入，一个算法的运行时间也可能依赖于该规模下不同的输入。例如在最佳情况下，输入的数组本身就是有序的，因此不需要里层的while循环来查找插入位置，只要直接插入即可，运行时间为线性函数$an + b$；在最坏情况下，输入的数组是反序的，里层while循环必须将每个元素key与整个已排序的子数组进行比较，运行时间是二次函数$a{n^2} + bn + c$。</p><p>在算法的性能分析中，我们往往关注算法在最坏情况的运行时间，这是因为：</p><ul><li>算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。知道这个界限，就能确保该算法运行肯定不会需要更长的时间。</li><li>对某些算法，最坏情况经常出现。例如检索数据库特定信息时，该信息不存在的情况（即最坏情况）是经常出现的。</li><li>“平均情况”往往与最坏情况大致一样差。例如插入排序寻找插入位置时，平均来说插入的位置大致处于已排序数组的“中间”，即检查一半的元素。这种“平均情况”最终得出的运行时间也是输入规模的二次函数。</li></ul><p>我们真正感兴趣的是算法运行时间的<strong>增长率</strong>。当n很大时，低阶项相对来说不太重要，常量因子也不如增长率重要，所以我们只考虑公式中阶数最大的项，上述公式即是${n^2}$。我们记插入排序最坏运行时间为$T(n) = \Theta ({n^2})$。下一节将讲解这种特殊符号的真正含义。</p><h1 id="2-渐近记号"><a href="#2-渐近记号" class="headerlink" title="2. 渐近记号"></a>2. 渐近记号</h1><p>上面提到插入排序最坏的运行时间为$T(n) = \Theta ({n^2})$，一般我们使用渐近记号来描述算法的运行时间。最常用的渐近记号有$\Theta $记号，大O记号和$\Omega $记号。</p><ul><li>$T(n) = \Theta (f(n))$：当且仅当存在正常数${c_1},{c_2},{n_0}$，使得对所有$n \ge {n_0}$，有$0 \le {c_1}f(n) \le T(n) \le {c_2}f(n)$</li><li>$T(n) = O(f(n))$：当且仅当存在正常数$c,{n_0}$，使得对所有$n \ge {n_0}$，有$0 \le T(n) \le cf(n)$</li><li>$T(n) = \Theta (f(n))$：当且仅当存在正常数$c,{n_0}$，使得对所有$n \ge {n_0}$，有$0 \le cf(n) \le T(n)$</li></ul><p>由上述定义可见，其实三种符号的定义非常相像，其中$\Theta $记号渐近地给出一个函数的上界和下界，而大O记号给出的是上界，$\Omega $记号给出的是下界。因此接下来的讨论均以“较为严格”的$\Theta $记号为例。下图给出这三种记号的一个直观表示。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/algorithm/%E4%B8%89%E7%A7%8D%E6%B8%90%E8%BF%91%E8%AE%B0%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="三种渐近记号的区别"></p><p>注意，由于$\Theta (f(n))$是一个集合，所以$T(n) = \Theta (f(n))$其实等价于$T(n) \in \Theta (f(n))$。$\Theta $记号的一种非形式化的概念，相当于扔掉低阶项并忽略最高阶项前的系数。</p><p><strong>例1：证明${1 \over 2}{n^2} - 3n = \Theta ({n^2})$</strong></p><p>证明：要确定${c_1},{c_2},{n_0}$，使得对所有$n \ge {n_0}$，有${c_1}{n^2} \le {1 \over 2}{n^2} - 3n \le {c_2}{n^2}$成立<br>即${c_1} \le {1 \over 2} - {3 \over n} \le {c_2}$。<br>通过选择${c_2} \ge {1 \over 2}$，可以使右边不等式对任何$n \ge 1$成立<br>通过选择${c_1} \le {1 \over {14}}$，可以使左边不等式对任何$n \ge 7$成立。QED</p><p><strong>例2：证明$6{n^3} \ne \Theta ({n^2})$</strong></p><p>证明：采用反证法。假设存在${c_2},{n_0}$，使得对所有$n \ge {n_0}$，有$6{n^3} \le {c_2}{n^2}$。用${n^2}$除该式，得$n \le {c_2}$，因为${c_2}$是常量，所以对任意大的$n$，该不等式不可能成立。QED</p><p><strong>例3：解释$2{n^2} + 3n + 1 = 2{n^2} + \Theta ({n^2}) = \Theta ({n^2})$</strong></p><p>第一个等式表明存在某个函数$f(n) \in \Theta ({n^2})$，使得对所有的$n$，有$2{n^2} + 3n + 1 = 2{n^2} + f(n)$。第二个等式表明对任意函数$g(n) \in \Theta ({n^2})$，存在某个函数$h(n) \in \Theta ({n^2})$，使得对所有的$n$，有$2{n^2} + g(n) = h(n)$。</p><p>参考文献：机械工业出版社《算法导论（第3版）》2.1节，2.2节，第3章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 渐进分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【演示】前端自动化工作流简介</title>
      <link href="/tech/complex/presentation/fe-workflow-automation-presentation/"/>
      <url>/tech/complex/presentation/fe-workflow-automation-presentation/</url>
      
        <content type="html"><![CDATA[<p>本文附带了2014年5月29日ELWG讲座《前端自动化工作流简介》的PPT。</p><a id="more"></a><p><strong><a href="http://itec-elwg.github.io/LectureSlides/fe-workflow-automation" target="_blank" rel="noopener">原PPT传送门</a></strong></p><p><iframe id="slide-iframe" src="http://itec-elwg.github.io/LectureSlides/fe-workflow-automation" width="100%" height="800px"></iframe></p><script type="text/javascript">    var frame = document.getElementById('slide-iframe');    frame.addEventListener('mousewheel', function(e) {        e.preventDefault();        e.stopPropagation();    });</script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工作流 </tag>
            
            <tag> 自动化 </tag>
            
            <tag> 演示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【演示】Javascript模块化实战</title>
      <link href="/tech/complex/presentation/javascript-module-presentation/"/>
      <url>/tech/complex/presentation/javascript-module-presentation/</url>
      
        <content type="html"><![CDATA[<p>本文附带了2014年5月28日ELWG讲座《Javascript模块化实战》的PPT。</p><a id="more"></a><p><strong><a href="http://itec-elwg.github.io/LectureSlides/javascript-module" target="_blank" rel="noopener">原PPT传送门</a></strong></p><p><iframe id="slide-iframe" src="http://itec-elwg.github.io/LectureSlides/javascript-module" width="100%" height="800px"></iframe></p><script type="text/javascript">    var frame = document.getElementById('slide-iframe');    frame.addEventListener('mousewheel', function(e) {        e.preventDefault();        e.stopPropagation();    });</script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演示 </tag>
            
            <tag> Javascript </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Console2：Windows命令行威力加强版</title>
      <link href="/tech/tool/IDE/console2-better-windows-cmd/"/>
      <url>/tech/tool/IDE/console2-better-windows-cmd/</url>
      
        <content type="html"><![CDATA[<p>作为一个Windows重度用户+程序猿，日常开发中免不了要经常使用命令行工具。但是Windows下默认的cmd提供的功能实在有限。今天无意间发现了一款很不错的命令行工具前端Console2，瞬间就被其深深地吸引，赶紧记下来分享一下。本文将简单介绍Console2及其配置方法，让你可以快速地配置出一个类似Linux终端的装逼利器。</p><a id="more"></a><p>和Linux下有强大的Konsole和gnome terminal不同，Windows里的命令行工具默认是cmd.exe，其简陋程度大家都清楚。当然Windows下还有一个Powershell，但在各方面也是差强人意。Console2这个工具是cmd.exe的前端包装，它有很多突出的优点：</p><ul><li>支持多标签，这样就不会再任务栏里产生过多的窗口</li><li>不仅可以包装cmd.exe，也可以包装其他terminal程序，如cygwin、Powershell等等</li><li>支持透明背景，可配置字体和颜色，可配置热键等等</li><li>完全绿色，解压即用</li></ul><p>官方下载地址：<a href="http://sourceforge.net/projects/console/" target="_blank" rel="noopener">http://sourceforge.net/projects/console/</a></p><p>原版下载下来之后还需要经过一番配置才能成为装逼利器。</p><h1 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1. 基本配置"></a>1. 基本配置</h1><p>菜单栏<code>Edit | Settings</code>进入设置。以下列举我觉得比较重点的设置，其他的就自己摸索吧。</p><ul><li>Console: Shell：要包装的终端工具（默认为cmd.exe），用Powershell可以设置为<code>%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe</code></li><li>Console: Startup dir：默认启动的目录</li><li>Console: Window size：启动时窗口的大小（也可以正常拖拽窗口右下角来调整）</li><li>Console: Buffer size：缓冲区的大小（调大一点可以保留更多的内容）</li><li>Apperance: 设置命令行工具的标题、字体、位置等（我设置为字体Consolas Size 15）</li><li>Apperance|More: Window transparency：设置窗口激活和未激活时的窗口透明度（30, 80为佳）</li><li>Behavior: Copy on select：选中文字时自动复制</li><li>Hotkeys：设置快捷键。有一些非常好用的快捷键，比如<code>New Tab 1</code>设置为CTRL+T可以快速打开新标签，<code>Scroll buffer page up</code>设置为Page Up可以用键盘滚动命令行窗口，<code>Activate Console(global)</code>设置为CTRL+Shift+T可以让你在失去焦点的时候快速呼出命令行窗口，等等，各人按照各自的口味设置吧。<strong>记住设置快捷键时要点Assign才能生效</strong></li><li>Mouse：鼠标快捷键：<code>Select Text</code>设置为Left可以让你像选文本一样选择文字（配合上面的Copy on select可以让你选中文字马上就复制），<code>Paste text</code>设置为Right可以点击鼠标右键就粘贴</li><li>Tabs：配置标签页。这里你可以配置默认命令行窗口的标题、图标、启动程序等等。我点击Add添加了一个Python Shell程序，然后再Hotkeys设置New Tab 2的快捷键，就可以一键启动python了！</li></ul><h1 id="2-中文显示的问题"><a href="#2-中文显示的问题" class="headerlink" title="2. 中文显示的问题"></a>2. 中文显示的问题</h1><p>默认设置下中文字体会错位，让人很不爽。解决办法是菜单栏<code>View | Console window</code>调出原命令行窗口，然后在cmd的标题栏上<code>右键 | 属性 -&gt; 字体 -&gt; 新宋体</code>，然后确定保存。重启Console2，你会发现不会有屏幕文字偏移的问题了。</p><h1 id="3-无法中文输入的问题"><a href="#3-无法中文输入的问题" class="headerlink" title="3. 无法中文输入的问题"></a>3. 无法中文输入的问题</h1><p>网上很多博客都说无法输入中文的问题暂时无解，只能通过菜单栏<code>View | Console window</code>在原生的命令行窗口中输入中文。但经过一番搜索还是有比较完美的解决方案的。Github上有好心人对Console2的源码进行了修改并编译了一份可以支持中文输入的版本，猛戳<a href="https://github.com/raytaylorlin/Console2-Chinese-Input-Capable" target="_blank" rel="noopener">我Fork的版本</a>将<code>Console.exe</code>下载覆盖即可。</p><h1 id="4-通过右键菜单在当前目录打开命令行窗口"><a href="#4-通过右键菜单在当前目录打开命令行窗口" class="headerlink" title="4. 通过右键菜单在当前目录打开命令行窗口"></a>4. 通过右键菜单在当前目录打开命令行窗口</h1><p>在Windows7中，在任意目录下Shift+鼠标右键，在菜单中可以看到“在此处打开命令行窗口”，点击后可以在当前目录打开cmd.exe。如果想在当前目录打开Console2，需要修改注册表。如果你在我的Github上下载了可以输入中文的Console2，应该会发现里面有两个bat批处理文件，一个是替换掉cmd，另一个是还原，只要运行一下bat即可修改右键菜单。<strong>注意这两个文件要放在Console2目录下运行。</strong></p><p>最后放出一张示例图，看看这逼格满满的命令行窗口。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/IDE/Console2%E7%A4%BA%E4%BE%8B%E5%9B%BE.jpg" alt="Console2示例图"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> 控制台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP学习笔记：缓存</title>
      <link href="/tech/web/http/HTTP-cache/"/>
      <url>/tech/web/http/HTTP-cache/</url>
      
        <content type="html"><![CDATA[<p>Web缓存是可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这个文档。使用缓存可以减少冗余的数据传输，环节网络瓶颈的问题，降低对原始服务器的要求以及降低距离时延。</p><p>本文解释了缓存怎样提供性能降低费用，如何去衡量其有效性以及将缓存置于何处可以发挥它的最大作用。此外还会解释HTTP如何保持已缓存副本的新鲜度，缓存如何与其他缓存和服务器通信等问题。</p><a id="more"></a><h1 id="1-使用缓存的意义"><a href="#1-使用缓存的意义" class="headerlink" title="1. 使用缓存的意义"></a>1. 使用缓存的意义</h1><p>很多客户端访问一个流行的原始服务器页面时，服务器会多次传输同一份文档，一些相同的字节会在网络中一遍遍地传输。这些冗余的数据传输会消耗昂贵的网络带宽，降低传输速度。有了缓存，就可以保留第一条服务器响应的副本，后继请求就可以由缓存副本来应对了。缓存还可以缓解网络的瓶颈问题，因为本地网络提供的带宽远比远程服务器的带宽要宽，所以如果本地网络中有缓存，则可以显著提高性能。此外，缓存在应对“瞬间拥塞”即短时间内访问量激增的情况显得非常重要。</p><p>每台网络路由器都会增加因特网流量的时延，即使客户端和服务器之间没有太多的路由器，光速自身也会造成显著的时延。这种时延尤其体现在跨国之间的数据传输，而一份在附近机房的缓存可以将文件传输距离从数千公里缩短为数十米。</p><h1 id="2-缓存命中"><a href="#2-缓存命中" class="headerlink" title="2. 缓存命中"></a>2. 缓存命中</h1><p>缓存不能保存世界上每份文档的副本。当可以用已有的副本为某些到达缓存的请求提供服务，则称为<strong>缓存命中</strong>（cache hit），到达缓存的请求可能因为没有副本可用而被转发到原始服务器，称为<strong>缓存未命中</strong>（cache miss）。原始服务器的内容可能随时发生变化，缓存要不时对其进行检测看保存的副本是否仍是服务器上最新的副本，这种“新鲜度检测”称为<strong>HTTP再验证</strong>（revalidatioin）。</p><p>缓存进行再验证时，最常用的是将If-Modified-Since首部加到GET请求中。服务器收到该请求会发生以下三种情况：</p><ul><li>再验证命中：如果内容未被修改，服务器会以304 Not Modified响应，只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜，并将副本提供给客户端。</li><li>再验证未命中：服务器向客户端发送一条普通的带有完整内容的HTTP 200 OK响应</li><li>对象被删除：如果服务器对象已被删除，服务器会回送404 Not Found，缓存也会将副本删除。</li></ul><p>由缓存提供服务的请求所占的比例称为<strong>缓存命中率</strong>。对现在中等规模的Web缓存来说，40%的命中率是比较合理的。还有一种<strong>字节命中率</strong>表示缓存提供的字节在传输的所有字节所占的比例。文档命中率说明阻止了多少通往外部网络的Web事务，字节命中率说明阻止了多少字节传向因特网，提高字节命中率对节省带宽很有利。</p><p>HTTP没有为用户提供一种手段来区分响应是否来自缓存。可以使用Date首部来间接地判断，如果响应中的日期值比当前时间早，则可以认为这是一条缓存的响应。</p><h1 id="3-缓存的拓扑结构"><a href="#3-缓存的拓扑结构" class="headerlink" title="3. 缓存的拓扑结构"></a>3. 缓存的拓扑结构</h1><p>缓存可以是单个用户专用的私有缓存，也可以是包含某个用户团体常用页面的公有缓存。私有缓存不需要很大的存储空间，可以将其做得很小很便宜，比如很多Web浏览器都有内建的私有缓存。公有缓存是特殊的共享代理服务器，它会接受来自多个用户的访问，可以更好地减少冗余流量。</p><p>在实际应用中，层次化的缓存是很有意义的。在较小的缓存中未命中的请求会被导向较大的父缓存，在靠近客户端的地方使用小型廉价缓存，更高层次中逐步采用更大，功能更强的缓存来装载多用户共享的文档。此外还有更加复杂的网状缓存，它们会根据URL在父缓存或原始服务器之间进行动态选择，也会决定选择何种路由对内容进行访问、管理和传送。</p><h1 id="4-缓存的处理步骤"><a href="#4-缓存的处理步骤" class="headerlink" title="4. 缓存的处理步骤"></a>4. 缓存的处理步骤</h1><p>Web缓存的基本处理步骤包括7个步骤，如下图所示。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTTP/Web%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4.jpg" alt="Web缓存的基本处理步骤"></p><ol><li>接收：缓存检测到一条网络连接上的活动，读取输入数据。高性能的缓存会同时从多条输入连接上读取数据，在整条报文抵达之前开始处理事务。</li><li>解析：将请求报文解析为片段，将首部各个部分放入易于操作的数据结构中。</li><li>查找：查找本地副本（可能位于内存、本地磁盘甚至另一台计算机中）。专业级的缓存会使用快速算法来确定本地缓存中是否有某个对象。</li><li>新鲜度检测：缓存会将服务器文档的副本保留一段时间，在“新鲜度限值”的时间之内都认为文档是“新鲜的”。超过限值的要和服务器进行再验证，以查看文档是否发生变化。新鲜度检测是一个非常复杂的问题，本文剩余部分将讨论这个问题。</li><li>创建响应：缓存会对服务器响应的基础首部进行修改和扩充，例如将低版本的HTTP转换成HTTP/1.1响应。缓存还会向首部插入新鲜度信息（Cache-Control、Age、Expires首部等）。</li><li>发送：高性能缓存会尽力高效发送数据，通常可以避免在本地缓存和网络I/O缓冲区之间进行文档内容的复制。</li><li>日志：保存于缓存使用有关的一些统计数据，如更新缓存命中和未命中数目数据等。</li></ol><h1 id="5-保持副本的新鲜"><a href="#5-保持副本的新鲜" class="headerlink" title="5. 保持副本的新鲜"></a>5. 保持副本的新鲜</h1><p>不是所有的缓存副本都与服务器上的文档一致，因为服务器上的文档可能随时都会变化，缓存数据必须要与服务器保持一致。HTTP有一些简单的机制可以在<em>不要求服务器记住有哪些缓存拥有其文档副本的情况下</em>，保持已缓存数据与服务器之间充分一致。通过特殊的HTTP <code>Cache-Control:max-age</code>（HTTP/1.1首部，定义了文档的最大试用期）和<code>Exipires</code>（HTTP/1.0+首部，指定一个绝对的过期日期）首部，原始服务器向每个文档附加一个“过期日期”，说明了再多长时间内可以将这些内容视为新鲜的。</p><p>过了过期日期之后只是意味着缓存要和服务器进行再验证。若再验证显示内容发生了变化，缓存会获取一份新的副本并存储在旧文档的位置上；若没有发生变化，缓存只需要获取新的过期日期并更新就可以了。</p><p>正如第2节所说的，缓存可以向原始服务器发送一个“条件GET”来进行再验证。最常见的缓存再验证首部是<code>If-Modified-Since:Date</code>（IMS请求）。只有自某个日期之后资源发生了变化，GET才会成功执行回送新的文档。该首部可以与<code>Last-Modified</code>服务器响应首部配合工作。原始服务器会将最后的修改日期附加到所提供的文档上去。当缓存要再验证时，就会发送携带最后修改日期的IMS请求。</p><p>有一些情况仅使用最后修改日期进行再验证是不够的，例如：有的文档可能会被周期性地重写，尽管内容没变，但修改日期会变；有的文档可能被修改了，但所做修改没必要让世界范围内的缓存都重新获取数据；有的服务器无法准确判定其页面的最后修改日期；有的服务器提供的文档会在秒级以内发生变化，以一秒为粒度的修改日期可能不够用。为了解决这些问题，HTTP允许用户对<strong>实体标签ETag</strong>进行比较。当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本，缓存可以用<code>If-None-Match</code>条件首部来GET文档的新副本。</p><p>如果服务器回送一个ETag，客户端就必须使用实体标签验证器；如果服务器只回送一个Last-Modified值，客户端就可以使用If-Modified-Since验证。如果两者都提供，客户端就应该使用两种验证方案。当服务器同时收到两种方案的请求，只有当两个条件都满足时，才能返回304 Not Modified响应。</p><h1 id="6-控制缓存"><a href="#6-控制缓存" class="headerlink" title="6. 控制缓存"></a>6. 控制缓存</h1><h2 id="6-1-响应首部"><a href="#6-1-响应首部" class="headerlink" title="6.1 响应首部"></a>6.1 响应首部</h2><p>服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序，以下给出了这些控制缓存的首部。</p><ul><li>Cache-Control:no-store：禁止缓存对响应进行复制。缓存会向客户端转发一条no-store响应，然后删除对象。</li><li>Cache-Control:no-cache：实际上可以存储在本地缓存区。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。</li><li>Cache-Control:must-revalidate：缓存是可以提供一些过期的对象的（保存在缓存上的副本有多个版本）。原始服务器可以用这个首部告诉缓存，在事先没有再验证的情况下，不能提供这个对象的过期副本。缓存仍然可以随意提供新鲜的副本。</li><li>Cache-Control:max-age：表示从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。若为0，每次访问都不缓存。</li><li>Expires：指定实际（绝对）的过期日期。但由于很多服务器的时钟不同步或不正确，最好还是使用max-age剩余秒数来表示过期时间。</li></ul><p>如果响应中没有说明过期时间的首部，缓存可以通过一些算法来计算出一个试探性最大使用期。比如LM-Factor算法利用文档的最后修改日期来计算过期时间。</p><h2 id="6-2-请求首部"><a href="#6-2-请求首部" class="headerlink" title="6.2 请求首部"></a>6.2 请求首部</h2><p>Web浏览器也可以用Cache-Control请求首部来强化或放松对过期时间的限制，下面列举这些首部。</p><ul><li>Cache-Control:max-stale=s：缓存可以随意提供过期的文件。如果指定了参数s，在这段时间内文档就不能过期。这条指令放松了缓存规则。</li><li>Cache-Control:min-fresh=s：至少在未来s秒内文档要保持新鲜。这条指令使缓存规则更加严格。</li><li>Cache-Control:no-cache：除非资源进行了再验证，否则这个客户端不会接受已缓存的资源。</li><li>Cache-Control:no-store：缓存应该尽快从存储器中删除文档的所有痕迹。</li><li>Cache-Control:only-if-cached：只有当缓存中有副本存在时，客户端才会获取一份副本。</li></ul><h2 id="6-3-控制Apache的HTTP首部"><a href="#6-3-控制Apache的HTTP首部" class="headerlink" title="6.3 控制Apache的HTTP首部"></a>6.3 控制Apache的HTTP首部</h2><p>Apache Web服务器提供了几种设置HTTP缓存控制首部的机制，其中很多机制在默认情况下是没有启动的（需要手动启动或自行安装扩展模块）。</p><ul><li>mod_headers：该模块可以对单独的首部进行配置，还可以将这些配置与Apache的常用表达式及过滤器结合在一起使用</li><li>mod_expires：可以自动生成带有正确过期日期的Expires首部。</li><li>mod_cern_meta：可以将一个包含HTTP首部的文件与特定的对象联系起来。</li></ul><h2 id="6-4-通过HTML的http-equiv控制HTML缓存"><a href="#6-4-通过HTML的http-equiv控制HTML缓存" class="headerlink" title="6.4 通过HTML的http-equiv控制HTML缓存"></a>6.4 通过HTML的http-equiv控制HTML缓存</h2><p>为了让开发者在无需与服务器配置文件进行交互的情况下，能够更容易地为所提供的HTML文档分配HTTP首部信息，可以使用一个meta标签来控制HTML缓存。例如下面的代码将HTML文档标记为非缓存的。</p><pre><code>&lt;head&gt;    &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot;&gt;&lt;/head&gt;</code></pre><p>但是，通过meta标签并不是控制文档缓存特性的好方法，因为这个可选特性会增加服务器的额外负载，很多服务器或代理也不支持此特性。由经过正确配置的服务器发送的HTTP首部来交流对文档的缓存控制请求是唯一可靠的方法。</p><p>注：本文略过了原书“7.11详细算法”缓存使用期和新鲜度计算算法的内容以及“7.12缓存和广告”的内容。</p><p>参考文献：人民邮电出版社《HTTP权威指南》第7章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP学习笔记：代理</title>
      <link href="/tech/web/http/HTTP-proxy/"/>
      <url>/tech/web/http/HTTP-proxy/</url>
      
        <content type="html"><![CDATA[<p>Web代理（proxy）服务器时网络的中间实体。代理位于客户端和服务器之间，扮演“中间人”的角色，在各端点之间来回传送HTTP报文。本文介绍与HTTP代理服务器有关的内容，包括：代理能做什么，代理一般位于何处，与代理请求有关的一些问题以及如何追踪报文等等。</p><a id="more"></a><h1 id="1-Web的中间实体"><a href="#1-Web的中间实体" class="headerlink" title="1. Web的中间实体"></a>1. Web的中间实体</h1><p>Web上的代理服务器是代表客户端完成事务处理的中间人。有了代理，客户端就可以与代理进行对话，然后由代理代表客户端与服务器进行交流，客户端仍然会完成对事务的处理，但它是通过代理服务器提供的优质服务来实现的。注意代理服务器既是Web服务器又是Web客户端，必须正确地处理请求和连接。</p><p>代理服务器可以是某个客户端专用，称为<em>私有代理</em>。私有代理比较少见，一般用于扩展浏览器特性，提高性能，或为免费ISP服务提供主机广告灯。大多数代理都是众多客户端共享的<em>公共代理</em>。某些代理应用，比如高速缓存代理服务器，会利用用户间共同的请求，当汇入同一个代理服务器的用户越多，它就越有用。</p><p>严格来说，代理连接的是多个<strong>使用相同协议</strong>的应用程序，而网关连接的则是多个<strong>使用不同协议</strong>的端点。例如HTTP代理与客户端和服务器之间都使用HTTP协议，而HTTP/E-mail网关则把HTTP前台与POP E-mail的后端连接起来，很多基于Web的E-mail程序都是HTTP/E-mail网关。</p><p>由于代理服务器可以看到并接触到所有流过的HTTP流量，所以代理可以监视流量并对其进行修改，以实现很多有用的Web增值服务。下面是常见的一些代理使用例子：</p><ul><li>儿童过滤器：阻止儿童访问成人内容</li><li>文档访问控制：在大量Web服务器和资源之间实现统一的访问控制策略，创建审核跟踪机制</li><li>安全防火墙：在网络中的单一安全节点上对流量进行详细检查，限制哪些应用层协议的数据可以流入或流出一个组织。</li><li>反向代理：接收客户端发给服务器的真实请求，但与Web服务器不同的是，它们可以发起与其他服务器的通信，以便按需定位所请求的内容。此时代理对外就表现为一个服务器。</li></ul><h1 id="2-代理所处的位置"><a href="#2-代理所处的位置" class="headerlink" title="2. 代理所处的位置"></a>2. 代理所处的位置</h1><p>可以根据目标用途将代理放在任意位置。通常有以下几种部署代理服务器的方式：出口代理（固定在本地网络的出口点）、入口代理（放在ISP访问点上）、反向代理（在真正的Web服务器之前作为替代物）、网络交换代理（位于因特网对等交换点上）。</p><p>可以通过<em>代理层次结构</em>将代理级联起来，报文会从一个代理传给另一个代理，直到最终抵达原始服务器为止。越靠近服务器的代理称为父代理，越靠近客户端的称为子代理。层次结构可以是静态的——即转发路径是固定不变的——也可以是动态的，访问代理会根据不同情况选择往何处转发。</p><p>客户端通常会直接与Web服务器进行通信而不会与代理通信，有4种常见方式可以使客户端流量流向代理：修改客户端（手动或自动配置浏览器的代理选项，也可以通过设置<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">PAC代理自动配置</a>文件来实现）、修改网络（配置交换设备或路由设备对流量进行拦截并导入一个代理）、修改DNS（使所有请求发送给替代物）、修改Web服务器（配置为向客户端发送重定向命令，将客户端重定向到代理上去）。</p><h1 id="3-与代理请求有关的一些问题"><a href="#3-与代理请求有关的一些问题" class="headerlink" title="3. 与代理请求有关的一些问题"></a>3. 与代理请求有关的一些问题</h1><ol><li>代理URI与服务器URI不同：客户端向Web服务器发送请求时，请求行只包含<strong>部分URI</strong>，如<code>/index.html</code>，而向代理发送请求时则包含完整的URI。因为代理需要知道目标服务器的名称才能建立自己与服务器的连接。</li><li>缺少方案/主机/端口问题：与虚拟主机Web服务器面临的问题相同，包含部分URI的请求到达时，代理需要知道目的Web站点的主机名。显式的代理要求请求报文包含<strong>完整URI</strong>，而虚拟主机要求使用Host首部来承载主机和端口信息。</li><li>代理既可以处理代理请求，也可以处理服务器请求：通用的代理服务器应支持报文中的完整URI和部分URI。如果是显式的代理请求，代理就应该使用完整URI；如果是Web服务器请求，就应使用部分URI和虚拟Host首部。</li><li>转发过程中对URI的修改：对URI的微小修改（如用显式的“:80”代替默认HTTP端口），甚至是看起来无害的修改，都可能给下游服务器带来一些互操作性问题。因此修改URI需要特别小心。</li><li>没有代理时URI的自动扩展：没有代理时，浏览器会自动扩展用户输入的URI，如自动加上“www.”和“.com”，甚至将未解析出来的URI传递给第三方站点（如搜索引擎）。</li></ol><h1 id="4-追踪报文"><a href="#4-追踪报文" class="headerlink" title="4. 追踪报文"></a>4. 追踪报文</h1><p>将Web请求从客户端传送到服务器的路径上，经过两个或多个代理是很常见的。因为代理是由不同厂商开发的，有不同的特性和缺陷，随着代理的逐渐流行，我们要能够追踪经过代理的报文流，以检测出各种问题。</p><h2 id="4-1-Via首部"><a href="#4-1-Via首部" class="headerlink" title="4.1 Via首部"></a>4.1 Via首部</h2><p>报文每经过一个节点，都必须将这个中间节点添加到Via列表的末尾。<code>Via = 1.1 cache.joes-hardware.com, 1.1 proxy.irenes-isp.net</code>这个例子表明了报文经过了两个代理（包括协议的版本号及主机名）。注意，每个Via路标最多包含4个组件：协议名（默认HTTP，可选），协议版本，节点名和描述性注释（可选）。</p><p>Via有时会涉及隐私和安全问题，例如代理作为网络防火墙的一部分使用时，是不应该转发防火墙后面那些主机名字和端口号的。若不允许进行Via节点名转发，代理应适当的假名来取代主机名；对那些非常需要隐藏内部网络设计和拓扑结构的组织来说，代理应该将一个接收协议值相同的有序的Via路标条目合并成一个联合条目。</p><h2 id="4-2-TRACE方法"><a href="#4-2-TRACE方法" class="headerlink" title="4.2 TRACE方法"></a>4.2 TRACE方法</h2><p>HTTP/1.1的TRACE方法，对代理流的调试非常有用。当TRACE请求到达目的服务器时，整条请求报文都会被封装在一条HTTP响应的主体中回送给客户端。客户端就可以检查服务器收到的确切报文，以及它所经过的代理列表（在Via首部）。此外，可以使用<code>Max-Forwards</code>（最大转发次数）首部来限制TRACE和OPTIONS请求所经过的代理跳数，若该值为0，那么即使接收者不是原始服务器，也必须马上将TRACE报文回送给客户端，而每转发一次，该值就会减一。</p><h1 id="5-代理的互操作性"><a href="#5-代理的互操作性" class="headerlink" title="5. 代理的互操作性"></a>5. 代理的互操作性</h1><p>代理可能无法理解所有经其传输的首部字段，它必须对不认识的首部字段进行首部，并且维持同名首部字段的相对顺序。在当今的大部分网络中，如果代理不能转发它不支持的方法，可能就无法生存下去。通过HTTP OPTIONS方法，客户端或代理可以发现Web服务器或者其上某个特定资源所支持的功能。这样就可以在于服务器进行交互前确定服务器的能力，以便与具备不同特性的代理和服务器进行互操作。</p><p>如果OPTIONS请求的URI是星号（*），请求的就是整个服务器支持的功能，如果URI是个实际资源地址，则查询那个特定资源的可用特性。HTTP/1.1在响应中唯一指定的首部字段是<code>Allow</code>首部。例如<code>Allow: GET, HEAD, PUT</code>表明了请求URI支持的方法有GET、HEAD、PUT三种。</p><p>参考文献：人民邮电出版社《HTTP权威指南》第6章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP学习笔记：Web服务器</title>
      <link href="/tech/web/http/HTTP-web-server/"/>
      <url>/tech/web/http/HTTP-web-server/</url>
      
        <content type="html"><![CDATA[<p>Web服务器每天会分发出数十亿的Web页面，它是万维网的骨干。Web服务器实现了HTTP和相关的TCP连接处理，管理着Web资源，并负责提供管理功能。本文将一步一步解释Web服务器时如何处理HTTP事务的。</p><a id="more"></a><p>Web服务器有各种不同的形式：安装并运行通用的Web服务器软件（如开源的使用最多的Apache），购买预先打包好的软硬件解决方案即Web服务器设备，嵌入式服务器。</p><p>通常来说，实际的Web服务器会进行7步（如下图所示）：建立连接，接收请求，处理请求，访问资源，构建响应，发送响应，记录事务处理过程。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTTP/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4.jpg" alt="Web服务器请求的基本步骤"></p><h1 id="1-Web服务器基本任务"><a href="#1-Web服务器基本任务" class="headerlink" title="1. Web服务器基本任务"></a>1. Web服务器基本任务</h1><h2 id="1-1-接受客户端连接"><a href="#1-1-接受客户端连接" class="headerlink" title="1.1 接受客户端连接"></a>1.1 接受客户端连接</h2><p>客户端请求一条到Web服务器的TCP连接时，服务器就会建立连接，判断另一端是哪个客户端，将IP地址解析出来。一旦新连接建立起来并被接受，服务器就会将新连接添加到其现存的连接列表中，做好监视连接上数据传输的准备。服务器可以随意拒绝或理解关闭任意一条连接。</p><p>可以用“反向DNS”对大部分服务器进行配置，以便将客户端IP地址转换成主机名。Web服务器可以将主机名用于详细的访问控制和日志记录。但要注意的是，书籍名查找可能会花费很长时间，很多大容量的服务器要么会禁止主机名解析，要么只允许对特定内容进行解析。另外，服务器还可以通过<em>ident协议</em>找到发起HTTP连接的用户名。</p><h2 id="1-2-接收请求报文"><a href="#1-2-接收请求报文" class="headerlink" title="1.2 接收请求报文"></a>1.2 接收请求报文</h2><p>连接上有数据到达时，服务器会从网络连接中按照以下步骤读取数据（有些Web服务器会用特定的数据结构来存储请求报文）：</p><ul><li>解析请求行，查找请求方法、URI和版本号，各项由空格分隔，并以CRLF作为行的结束</li><li>读取以CRLF结尾的报文首部</li><li>如果有的话，检测以CRLF结尾的标识首部结束的空行</li><li>如果有的话，读取请求主体（长度由Content-Length首部指定）</li></ul><p>Web服务器会不停地观察有无新的Web请求。根据输入/输出结构，Web服务器分为以下几类：</p><ul><li>单线程：一次只处理一个请求，直到其完成为止。在处理过程中，所有其他连接都会被忽略，这会造成严重的性能问题，只适用于低负荷的服务器。</li><li>多进程及多线程：可以根据需要为每条连接分配一个线程或进程来处理请求，但当服务器同时要处理成百上千的连接时，可能会消耗太多内存和系统资源，因此应该对线程/进程的最大数量做限制。</li><li>复用I/O：同时监视所有连接上的活动，当连接状态发生变化时（如有数据可用，或出现错误等等），就对那条连接进行少量的处理，处理接受后将连接返回到开放连接列表中，等待下一次状态变化。</li><li>复用的多线程Web服务器：总和以上<em>多线程</em>和<em>复用I/O</em>的优点</li></ul><h2 id="1-3-处理请求"><a href="#1-3-处理请求" class="headerlink" title="1.3 处理请求"></a>1.3 处理请求</h2><p>一旦Web服务器收到了请求，就可以根据方法、资源、首部和可选的主体部分来对请求进行处理。有些方法（如POST）要求请求报文必须带有实体主体部分的数据，有些方法则允许有也允许没有，少数方法（如GET）禁止包含实体的主体数据。</p><h2 id="1-4-对资源的映射及访问"><a href="#1-4-对资源的映射及访问" class="headerlink" title="1.4 对资源的映射及访问"></a>1.4 对资源的映射及访问</h2><h3 id="1-4-1-docroot"><a href="#1-4-1-docroot" class="headerlink" title="1.4.1 docroot"></a>1.4.1 docroot</h3><p>作为资源服务器，Web服务器负责将请求报文中的URI映射为服务器上适当的内容，然后才发送预先创建好的内容。最简单的资源映射方式是以URI作为名字来访问服务器文件系统中的文件。通常Web服务器有一个特殊的文件夹专门存放Web内容，称为文档的根目录（document root）。<strong>Web服务器从请求报文中获取URI，并将其附加在docroot后面。</strong>服务器要注意不能让相对URL退到docroot之外，将文件系统的其余部分暴露出来。</p><p>虚拟托管的Web服务器会在同一台服务器上提供多个站点，每个站点在服务器上都有自己独有的docroot。通过配置Apache的<code>VirtualHost</code>块，即使请求的URI完全相同，但docroot不同就可以区分开不同的内容了。</p><h3 id="1-4-2-目录列表"><a href="#1-4-2-目录列表" class="headerlink" title="1.4.2 目录列表"></a>1.4.2 目录列表</h3><p>服务器可以接收对目录URL的请求，并解析成为一个目录而不是文件。可以对服务器进行配置，使其在客户端请求目录URL时采取不同的动作。默认情况下，服务器会去查找目录中名为index.html的文件来代表此目录，也可以通过配置Apache的<code>DirectoryIndex</code>来设置默认的要使用的文件名。</p><p>如果没有提供默认的index文件，也没有禁止使用目录索引，很多Web服务器都会自动返回一个包含目录列表的HTML文件，可以方便浏览服务器上的文件。可以通过Apache的<code>Options-Indexes</code>禁止自动访问目录列表。</p><h3 id="1-4-3-动态内容资源的映射"><a href="#1-4-3-动态内容资源的映射" class="headerlink" title="1.4.3 动态内容资源的映射"></a>1.4.3 动态内容资源的映射</h3><p>Web服务器还可以将URI映射为动态资源，即复杂的后端应用程序（区别于图片、HTML文件等静态资源，动态资源可能是网络摄像机网关、股票交易网关、电子商务网关等等其他应用程序）。</p><h2 id="1-5-构建响应"><a href="#1-5-构建响应" class="headerlink" title="1.5 构建响应"></a>1.5 构建响应</h2><p>一旦Web服务器识别出了资源，就执行请求方法中描述的动作，并返回响应报文。如果事务处理产生了响应主体，服务器要确定主体的<a href="http://baike.baidu.com/view/160611.htm" target="_blank" rel="noopener">MIME</a>类型，将内容放在响应报文中回送过去。可以用文件的扩展名来说明MIME类型。服务器有时也会返回重定向响应而不是成功的报文。有关重定向的说明，可以参照<a href="http://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">HTTP状态码维基百科</a>中3xx系列状态码说明。</p><h2 id="1-6-发送响应和记录日志"><a href="#1-6-发送响应和记录日志" class="headerlink" title="1.6 发送响应和记录日志"></a>1.6 发送响应和记录日志</h2><p>Web服务器通过连接发送数据时也会面临和接收数据一样的问题，它要记录连接的状态，还要特别注意对持久连接的处理（详情参见<a href="/Tech/web/HTTP/HTTP-connection-management/">HTTP学习笔记：连接管理 第2节</a>）。最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务。更多细节可以参见《HTTP权威指南》第21章。</p><p>参考文献：人民邮电出版社《HTTP权威指南》第5章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Web服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP学习笔记：连接管理</title>
      <link href="/tech/web/http/HTTP-connection-management/"/>
      <url>/tech/web/http/HTTP-connection-management/</url>
      
        <content type="html"><![CDATA[<p>HTTP规范对HTTP报文解释得很清楚，但对HTTP连接介绍并不多，而HTTP连接时HTTP报文传输的关键通道。本文将介绍HTTP是如何使用TCP连接，HTTP的优化以及管理连接时应该注意的问题等。</p><a id="more"></a><h1 id="1-TCP连接"><a href="#1-TCP连接" class="headerlink" title="1. TCP连接"></a>1. TCP连接</h1><p>世界上几乎所有的HTTP通信都是由TCP/IP承载的，TCP/IP是一种常用的分组交换网络分层协议集。客户端应用程序可以打开一条TCP/IP连接，连接到服务器应用程序。一旦连接建立，客户端和服务器计算机之间交换报文就永远不会丢失、受损或失序。</p><p>TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端流入的字节会从另一端以原有的顺序正确地传送出来。TCP的数据是通过名为IP分组的小数据块来发送的。每个TCP段由IP分组承载，IP分组包括：IP分组首部、TCP段首部、TCP数据块。在任意时刻计算机都可以有几条TCP连接处于打开状态。TCP是通过端口号来保持所有连接正常运行的，它由<code>&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt;</code>唯一确定。</p><p>操作系统通常提供了一些用套接字操纵TCP连接的API，允许用户创建TCP的端点数据结构，与远程服务器的TCP端点进行连接，并对数据流进行读写。TCP API隐藏了所有底层网络协议细节。下图展示了客户端和服务器如何通过TCP套接字接口进行通信，至于套接字API编程则不再赘述。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTTP/TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.jpg" alt="TCP套接字接口通信过程"></p><p>注：原书简要介绍了对TCP的性能的考虑，但TCP是个很复杂的话题，属于计算机网络的范畴，因此此处略过TCP性能考虑的详细介绍。最常见的TCP的相关时延包括：TCP连接建立握手、TCP慢启动拥塞控制、数据聚集的Nagle算法、用于捎带确认的TCP延迟确认算法、TIME_WAIT时延和端口耗尽。</p><h1 id="2-HTTP连接的处理"><a href="#2-HTTP连接的处理" class="headerlink" title="2. HTTP连接的处理"></a>2. HTTP连接的处理</h1><h2 id="2-1-常被误解的Connection首部"><a href="#2-1-常被误解的Connection首部" class="headerlink" title="2.1 常被误解的Connection首部"></a>2.1 常被误解的Connection首部</h2><p>Connection首部可以承载3种不同类型的标签：</p><ul><li>HTTP首部字段名，列出了只与此连接有关的首部。在将报文转发出去之前，必须删除列出的所有首部字段。</li><li>任意标签值，用于描述此连接的非标准选项</li><li>值close，说明操作完成之后需关闭这条持久连接</li></ul><h2 id="2-2-串行连接"><a href="#2-2-串行连接" class="headerlink" title="2.2 串行连接"></a>2.2 串行连接</h2><p>如果只对连接进行简单的管理，TCP的性能时延可能会叠加起来。比如，假设有一个包含3个图片的Web页面，浏览器需要发起4个HTTP事务来显示。加载一副图片时，页面上其他地方都没有动静会让人觉得速度很慢，此外，浏览器在对象加载完毕前无法获知对象的尺寸，所以串行事务会让用户面对一个空白的屏幕，对装载进度一无所知。为了提高HTTP的连接性能，有并行连接，持久连接，管道化连接等技术可以改善。</p><h2 id="2-3-并行连接"><a href="#2-3-并行连接" class="headerlink" title="2.3 并行连接"></a>2.3 并行连接</h2><p>HTTP允许客户端打开多条连接，并行地执行多个HTTP事务。并行连接可能会提高页面的加载速度，但有的情况下反而更慢。比如客户端的网络带宽不足时（如通过28.8kbps的Modem上网），一个连接到速度较快的服务器的HTTP事务就会很容易耗尽所有可用带宽。而且打开大量连接会消耗很多内存，这会造成服务器性能严重下降。实际上，浏览器确实使用了并行连接，但并行的总数会限制为一个较小的值（通常是4个）。服务器也可以关闭来自特定客户端的过量连接。</p><h2 id="2-4-持久连接"><a href="#2-4-持久连接" class="headerlink" title="2.4 持久连接"></a>2.4 持久连接</h2><p>HTTP在允许事务处理结束后将TCP连接保持在打开状态，以便未来的HTTP请求重用现存的连接，这被称为TCP的持久连接。相比并行连接，持久连接降低了时延和连接建立的开销，减少了打开连接的潜在数量。但是要小心管理这些连接，不然会累积出大量的空闲连接，耗费机器资源。现在，很多Web应用程序都会打开少量的并行连接，其中每一个都是持久连接。持久连接有两种类型：较老的HTTP/1.0+“keep-alive”连接和现代HTTP/1.1“persistent”连接。</p><h3 id="2-4-1-Keep-Alive持久连接"><a href="#2-4-1-Keep-Alive持久连接" class="headerlink" title="2.4.1 Keep-Alive持久连接"></a>2.4.1 Keep-Alive持久连接</h3><p>Keep-Alive已经不再使用了，但是有一些浏览器和服务器对keep-alive握手的使用仍然相当广泛，因此这里简单叙述一下keep-alive操作。首先客户端可以通过包含<code>Connection: Keep-Alive</code>首部请求将一条连接保持在打开状态，如果服务器同意，就在响应中包含相同的首部。<strong>若响应中没有相应的首部，客户端就会认为服务器不支持keep-alive，接收到响应后关闭连接。</strong>注意，Keep-Alive首部只是请求将连接保持在活跃状态，发出请求后，双端不一定会同意进行keep-alive会话，它们可以在任意时刻关闭或限制空闲的keep-alive连接。下面给出一个用Keep-Alive通用首部指定选项来调节keep-alive行为的例子，该例子说明服务器最多还会为另外5个事务保持连接打开状态，将打开状态保持到连接空闲了2分钟之后：</p><pre><code>Connection: Keep-AliveKeep-Alive: max=5, timeout=120</code></pre><p>使用keep-alive连接有一些限制：<code>Connection: Keep-Alive</code>首部必须随所有希望保持持久连接的报文一起发送；实体的主体部分必须有正确的Content-Length，才能打开持久连接；代理和网管必须在将报文转发出去之前，删除在Connection首部及其中命名的所有首部字段（<strong>Connection首部应该只对离开客户端的TCP链路产生影响</strong>，但很多老的或简单的代理都是盲中继，即只将字节从一个连接转发到另一个连接而不对首部进行处理，<em>代理对keep-alive对话毫不知情，而客户端和服务器都认为它们在进行keep-alive对话</em>，这就会造成错误的通信方式，具体情况如下图所示）。为了避免此类代理通信问题的发生，现代的代理都决不能转发Connection首部和所有名字出现在Connection值中的首部。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTTP/Keep-Alive%E6%97%A0%E6%B3%95%E4%B8%8E%E4%B8%8D%E6%94%AF%E6%8C%81Connection%E9%A6%96%E9%83%A8%E7%9A%84%E4%BB%A3%E7%90%86%E8%BF%9B%E8%A1%8C%E4%BA%92%E6%93%8D%E4%BD%9C.jpg" alt="Keep-Alive无法与不支持Connection首部的代理进行互操作"></p><p>对于<strong>单个盲中继</strong>问题，Netscape的浏览器引入一个名为Proxy-Connection的新首部，即使盲中继代理转发这个首部，Web服务器也会将其狐狸。如果代理是“聪明”的，收到这个首部后就会发送自己的Connection: Keep-Alive来建立keep-alive连接。当然，这种做法只能解决只有一个代理的情况，如果客户端和服务器之间有多个代理，同样会有问题。透明的Web应用程序正确实现持久连接时非常重要的。</p><h3 id="2-4-2-HTTP-1-1持久连接"><a href="#2-4-2-HTTP-1-1持久连接" class="headerlink" title="2.4.2 HTTP 1.1持久连接"></a>2.4.2 HTTP 1.1持久连接</h3><p>HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为persistent connection的改进型设计取代了它。在HTTP/1.1下，持久连接默认情况下是激活的，除非响应报文中包含<code>Connection: close</code>，否则连接就维持在打开状态。当然，客户端和服务器仍然可以随时关闭空闲的连接。</p><p>使用persistent连接同样有一些限制：发送Connection: close请求首部后，客户端就无法在那条连接上发送更多请求了；实体主体部分长度都和相应的Content-Length一致，连接才能持久保持；服务器不应试图在传输报文的过程中关闭连接，而且关闭之前应该至少响应一条请求；客户端收到整条响应之前连接关闭了，客户端都要重新发起请求，除非重复发请求会产生副作用。</p><h3 id="2-4-3-管道化连接"><a href="#2-4-3-管道化连接" class="headerlink" title="2.4.3 管道化连接"></a>2.4.3 管道化连接</h3><p>HTTP/1.1允许在持久连接上可选地使用<strong>请求管道</strong>，在响应到达之前，可以将多条请求放入队列，当第一条请求发出之后，后面的请求也可以开始陆续发送。这样可以在高时延网络条件下降低网络的环回时间，提高性能。管道化连接也有一些限制：如果HTTP客户端无法确认连接时持久的，就不应该使用管道；必须按照与请求相同的顺序回送HTTP响应；客户端必须做好连接会在任意时刻关闭的准备，并准备好重发所有未完成的管道化请求；客户端不应该用管道化的方式发送会产生副作用的请求（如POST）。</p><p>下图是各种连接的时延对比。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTTP/%E4%B8%89%E7%A7%8D%E8%BF%9E%E6%8E%A5%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%97%B6%E5%BB%B6%E5%AF%B9%E6%AF%94.jpg" alt="三种连接形式的时延对比"></p><h2 id="2-5-关闭连接"><a href="#2-5-关闭连接" class="headerlink" title="2.5 关闭连接"></a>2.5 关闭连接</h2><p>无论是错误还是非错误情况，连接都可能在任意时刻关闭。HTTP应用程序要做好正确处理非预期关闭的准备。通常来说当传输连接意外关闭时，客户端会重新打开并重试。注意，有些事务比如GET一个静态页面，反复执行多次也不会有什么变化（幂等请求），但对于POST（非幂等请求），就不能重复执行。</p><p>TCP连接是双向的，连接的每一端都有一个输入队列和一个输出队列。应用程序可以关闭TCP输入和输出信道中的任一个，或者两者都关闭，分别称为“完全关闭”和“半关闭”。其中，关闭连接的输出信道总是安全的，而关闭输入信道则比较危险，除非你知道另一端不打算再发送其他数据。如果另一端向你已关闭的输入信道发送数据，操作系统就会向另一端的机器回送一条TCP“连接被对端重置”的报文。这个重置信息会清空输入缓冲区，尽管其中的大部分都已经成功抵达你的机器。</p><p>总之，实现正常关闭的应用程序首先应该关闭它们的输出信道，然后等待连接另一端关闭它的输出信道。当两端都告诉对方它们不会再发送任何数据之后，连接就会被完全关闭，而不会有重置的危险。</p><p>参考文献：人民邮电出版社《HTTP权威指南》第4章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP学习笔记：HTTPS</title>
      <link href="/tech/web/http/HTTP-HTTPS/"/>
      <url>/tech/web/http/HTTP-HTTPS/</url>
      
        <content type="html"><![CDATA[<p>HTTPS是最常见的HTTP安全版本。HTTPS将HTTP协议与一组强大的对称、非对称和基于证书的加密技术结合在一起，使得HTTPS不仅很安全，而且很灵活，很容易在处于无序状态的、分散的全球互联网上进行管理，因此得到很广泛的应用。</p><p>目前它得到很广泛的应用，所有主要的商业浏览器和服务器都提供HTTPS。目前它已经成为基于Web的电子商务快速成长的主要推动力。本文将介绍HTTPS的相关知识。</p><a id="more"></a><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>HTTPS是在安全的传输层上发送的HTTP，它在将HTTP报文发送给TCP之前，先将其发送给了一个安全层对其进行加密。现在，HTTP安全层是通过SSL及其代替协议TLS来实现的。下图给出了HTTP和HTTPS层次的对比。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTTP/HTTP%E4%B8%8EHTTPS%E5%B1%82%E6%AC%A1%E5%AF%B9%E6%AF%94.jpg" alt="HTTP与HTTPS层次对比"></p><p>众所周知，在安全的HTTPS协议中，URL的方案前缀为https，如<code>https://github.com/</code>。HTTP的默认服务器端口号是80，而HTTPS的端口号是443。在未加密的HTTP中，客户端会打开一条到Web服务器80端口的TCP连接，发送一条请求报文，接收一条响应报文，最后关闭连接。而由于SSL安全层的存在，HTTPS中首先客户端打开一条到Web服务器端口443的连接。一旦建立TCP连接，就会初始化SSL层，对加密参数进行沟通，并交换密钥（这个过程成为SSL握手）。握手完成之后，SSL初始化就完成了，客户端就可以将请求报文进行加密然后发送给安全层。</p><h1 id="2-SSL握手和服务器证书"><a href="#2-SSL握手和服务器证书" class="headerlink" title="2. SSL握手和服务器证书"></a>2. SSL握手和服务器证书</h1><p>在通过网络传输任何已加密的HTTP数据之前，SSL会发送一组握手数据来建立通信连接，主要完成以下工作：（流程图如下所示）</p><ul><li>交换协议版本号</li><li>选择一个两端都了解的密码</li><li>对两端的身份进行认证</li><li>生成临时的会话密钥，以便加密信道</li></ul><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTTP/SSL%E6%8F%A1%E6%89%8B%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89%E6%B5%81%E7%A8%8B.jpg" alt="SSL握手（简化版）流程"></p><p>SSL支持双向认证，即证书可以在客户端和服务器之间互相传送。其中客户端并不经常使用证书，而HTTPS事务则总要求服务器提供证书。服务器证书是一个显示了组织的名称、地址、服务器DNS域名以及其他信息的X.509 v3派生证书（如下图所示）。客户端软件可以检查证书，以确保所有的信息都是可信的。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTTP/HTTPS%E8%AF%81%E4%B9%A6%E7%A4%BA%E4%BE%8B.jpg" alt="HTTPS证书示例"></p><p>大部分现代浏览器都会对证书进行简单的完整性检查，主要包含以下步骤：</p><ul><li>日期检测：检查证书的起始日期和结束日期，以确保证书仍然有效。</li><li>签名颁发者可信度检测：每个证书都是由某些证书颁发机构（CA）签发的，它们负责为服务器担保。任何人都可以生成证书，但有些CA是非常著名的组织，它们通过非常清晰的流程来验证证书申请人的身份及商业行为的合法性。</li><li>签名检测：一旦判定签名授权是可信的，浏览器就要对签名使用签名颁发机构的公开密钥，并将其与校验码进行比较，以查看证书的完整性。</li><li>站点身份检测：为防止服务器复制其他人的证书，或拦截其他人的流量，大部分浏览器都会试着去验证证书中的域名与它们所对话的服务器域名是否匹配。</li></ul><p>SSL是个复杂的二进制协议，幸运的是，借助一些商业或开源的库，编写SSL客户端和服务器并不十分困难。其中，<a href="http://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>是SSL和TLS最常见的开源实现。OpenSSL项目的目标是开发一个强壮的、具有完备功能的商业及工具集，以实现SSL和TLS协议以及一个全功能的通用加密库。</p><p>参考文献：人民邮电出版社《HTTP权威指南》第4章14.7-14.8</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP学习笔记：HTTP报文</title>
      <link href="/tech/web/http/HTTP-message/"/>
      <url>/tech/web/http/HTTP-message/</url>
      
        <content type="html"><![CDATA[<p>如果说HTTP是因特网的信使，那么HTTP报文就是运送的包裹。所有的HTTP程序都是通过互相发送报文来完成工作的。本文将介绍HTTP报文的流动方式，报文的组成部分，请求和响应报文之间的区别等。</p><a id="more"></a><h1 id="1-报文流"><a href="#1-报文流" class="headerlink" title="1. 报文流"></a>1. 报文流</h1><p>HTTP报文是在HTTP应用程序之间发送的数据块，这些数据块以文本形式存在，以描述了报文的内容及含义的元信息开头，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。一般来说，报文流根据流向引用以下三种术语：报文流入（inbound）向服务器，工作完成之后，会流出（outbound）向客户端或用户Agent代理；不管是请求报文还是响应宝安温，所有报文的接收者都在发送者的下游（downstream），报文只会向下游流动。</p><h1 id="2-报文的组成部分"><a href="#2-报文的组成部分" class="headerlink" title="2. 报文的组成部分"></a>2. 报文的组成部分</h1><p>报文由起始行、首部，以及可选的包含数据的主体三个部分组成。所有的HTTP报文分为两类：请求（request）报文和响应（response）报文，如下图示例。前者会向Web服务器请求对资源进行一些操作，后者承载了状态信息和操作产生的所有结果数据，把结果返回给客户端。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTTP/%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%A4%BA%E4%BE%8B.jpg" alt="请求和响应报文示例"></p><h2 id="2-1-起始行"><a href="#2-1-起始行" class="headerlink" title="2.1 起始行"></a>2.1 起始行</h2><p>所有的HTTP报文都以一个起始行作为开始。请求报文的起始行又称为请求行，说明了<strong>要做些什么</strong>，响应报文的起始行又称为响应行，说明了<strong>发生了什么</strong>。以下是两种请求行的基本格式：</p><pre><code>// 请求行格式&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;// 响应行格式&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;</code></pre><p>请求行的<em>方法</em>描述了服务器应该执行的操作，<em>请求URL</em>描述了要对哪个资源执行这个方法，<em>HTTP版本</em>用来告知服务器，客户端使用的是哪个版本的HTTP协议。响应行包含了报文使用的HTTP版本、数字状态吗，以及描述操作状态的文本形式的原因短语。所有这些字段都由空格分隔。</p><h3 id="2-1-1-请求行方法"><a href="#2-1-1-请求行方法" class="headerlink" title="2.1.1 请求行方法"></a>2.1.1 请求行方法</h3><p>HTTP规范中定义了一组常用的请求方法，用来告知服务器要做些什么，如下所示：</p><ul><li>GET：从服务器获取请求URL所指定的资源。</li><li>HEAD：只从服务器获取文档的首部。和GET方法的行为很类似，但服务器只返回首部，不包含主体。此方法可以：在不获取资源的情况下了解资源的情况（比如判断类型）；通过查看响应中的状态吗，看看某个对象是否存在；通过查看首部，测试资源是否被修改了。</li><li>POST：向服务器发送需要处理的数据（包含主体）。通常用它来支持HTML的表单。</li><li>PUT：将请求的主体部分存储在服务器上（包含主体）。有些系统允许用户创建Web页面或上传文档，该方法的语义就是让服务器用<em>请求的主体</em>来创建一个<em>由请求URL命名的新文档</em>，如果URL已存在则让这个主体替代它。</li><li>DELETE：从服务器上删除请求URL所指定的资源。但客户端无法保证删除操作一定被执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。</li><li>TRACE：对可能经过代理、网管、防火墙等服务器的报文进行追踪，主要用于诊断。报文行程最后一站的服务器会弹回一条TRACE响应，在主体中携带它收到的原始请求报文，这样客户端就可以查看报文在一整条请求/响应链上是如何被修改的。</li><li>OPTIONS：查询可以在服务器上执行哪些方法，让客户端不用实际访问那些资源就能判定访问各种资源的最优方式。</li></ul><p>如果一台服务器要与HTPP 1.1兼容，只要为其资源实现GET和HEAD方法即可，这两种方法被认为是安全的，它们产生的请求不会在服务器上产生什么结果（实际上，这是由Web开发者决定的，完全可以使用GET方法来提交一个表单，但<strong>严重不建议这么做</strong>！）。</p><p>HTTP还允许定义HTTP/1.1规范中没有定义的<strong>扩展方法</strong>，这些方法为开发者提供了一种扩展HTTP服务能力的手段。很可能大部分HTTP应用程序都无法理解这些扩展方法，所以服务器最好对扩展方法宽容一些。</p><h3 id="2-1-2-状态码与原因短语"><a href="#2-1-2-状态码与原因短语" class="headerlink" title="2.1.2 状态码与原因短语"></a>2.1.2 状态码与原因短语</h3><p>每条响应报文都会包含一个3位数字和可读的状态，用来告诉客户端，服务器发生了什么事情。数字状态码便于程序处理差错，原因短语更便于人们理解。状态码分为5类（括号中为已定义范围）：100~199为信息提示（100~101）；200~299为成功（200~206）；300~399为重定向（300~305），用于告知客户端使用替代位置来访问资源；400~499为客户端错误（400~415）；500~599为服务器错误（500~505）。限于篇幅下面只介绍常见的状态码，详情参见<a href="http://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">HTTP状态码维基百科</a></p><ul><li>101 Switching Protocols：服务器正在根据客户端的指定，将协议切换成Update首部所示的协议。</li><li>200 OK：服务器已成功处理了请求并提供了请求的网页</li><li>204 No Content：服务器成功处理了请求，但没有返回任何内容</li><li>301 Moved Permanently：请求的网页已永久移动到新位置。响应的Location首部应包含资源现在所处的URL。</li><li>302 Found：与301类似，但这里的移除是临时的。将来的请求仍应使用老的URL。</li><li>304 Not Modified：客户的缓存资源是最新的，要客户端使用缓存。</li><li>400 Bad Request：告知客户端发送了一个错误的请求。</li><li>403 Forbidden：请求被服务器拒绝了。（可能是没有访问服务器的权限）</li><li>404 Not Found：服务器无法找到所请求的URL。</li><li>410 Gone：服务器曾经有这个资源，现在没有了，与404类似。</li><li>500 Internal Server Error：服务器遇到一个错误，使其无法为请求提供服务。</li><li>502 Bad Gateway：作为代理或网关使用的服务器收到了上游的无效响应。</li><li>503 Service Unavailable：服务器现在无法为请求提供服务，但过一段时间就可以恢复服务。</li></ul><h2 id="2-2-首部"><a href="#2-2-首部" class="headerlink" title="2.2 首部"></a>2.2 首部</h2><p>首部和方法配合工作，共同决定了客户端和服务器能做什么事情。可以将首部分为5个主要类型，以下将分类列举一些首部。</p><p>1、<strong>通用首部</strong>：客户端和服务器都可以使用的通用首部，提供了与报文相关的最基本的信息。</p><ul><li>Connection：允许客户端和服务器指定与请求/响应连接相关的选项</li><li>Date：日期和时间标志，说明报文是什么时刻创建的</li><li>MIME-Version：给出了发送端使用的MIME版本</li><li>Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式</li><li>Via：显示了报文经过的中间节点（代理、网关等等）</li><li>Cache-Control：用于随报文传送缓存指示</li><li>Pragma：另一种随报文传送指示的方式，但并不专用于缓存</li></ul><p>2、<strong>请求首部</strong>：只在请求报文中有意义，用于说明是谁或什么在发送请求、请求源自何处，或客户端的喜好及能力等。</p><ul><li>Accept：告诉服务器能够发送哪些媒体类型。该首部可以使连接的两端都受益，客户端会得到它们想要的内容，服务器则不会浪费时间好带宽来发送客户端无法使用的东西</li><li>Accept-Encoding：告诉服务器能够发送哪些编码方式</li><li>Accept-Language：告诉服务器能够发送哪些语言</li><li>Referer：提供了包含当前请求URI的文档的URL</li><li>User-Agent：告诉服务器发起请求的应用程序名称</li></ul><p>有时客户端希望为请求加上某些限制，要求服务器在对请求进行响应之前，确保某个条件为真，则可以添加<em>条件请求首部</em>，如<code>Expect</code>（允许客户端列出某请求所要求的服务器行为）、<code>If-Match</code>（若实体标记相匹配，则获取这份文档）、<code>If-Modified-Since</code>（除非在某个指定日期之后资源被修改过，否则限制该请求）等等。</p><p>HTTP本身就支持一种对请求进行质询/响应的认证机制，这样可以使事务稍微安全一些。因此有<em>安全请求首部</em>，如<code>Authorization</code>（客户端提供给服务器的对其自身进行认证的数据）、<code>Cookie</code>（<strong>这个不是真正的安全首部，但却是隐含了安全功能</strong>）。</p><p>3、<strong>响应首部</strong>：为客户端提供了一些额外信息，比如谁在发送响应、响应者的功能、其它一些特殊指令等</p><ul><li>Age：（从最初创建开始）响应持续时间</li><li>Public：服务器为其资源支持的请求方法列表</li><li>Retry-After：如果资源不可用，在此时间重试</li><li>Accept-Ranges：（协商首部）对此资源来说，服务器可接受的范围类型</li><li>Set-Cookie：（安全首部）类似Cookie，用于设置Cookie</li></ul><p>4、<strong>实体首部</strong>：用来描述HTTP报文的负荷，提供了有关实体及其内容的大量信息，可以告知报文的接收者它在对什么进行处理</p><ul><li>Allow：列出可以对此实体执行的请求方法</li><li>Location：告知客户端实体实际上位于何处，用于重定向资源</li><li>Content-Length：主体的长度</li><li>Content-Type：主体的对象类型</li><li>（还有很多关于主体的首部，如Content-Encoding、Content-Base、Content-MD5等等）</li><li>ETag：与此实体相关的实体标记（用于缓存，下同）</li><li>Expires：实体不再有效，要从源端再次获取此实体的日期和时间</li><li>Last-Modified：这个实体最后一次被修改的日期和时间</li></ul><p>参考文献：人民邮电出版社《HTTP权威指南》第3章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP学习笔记：URL与资源</title>
      <link href="/tech/web/http/HTTP-URL/"/>
      <url>/tech/web/http/HTTP-URL/</url>
      
        <content type="html"><![CDATA[<p>URL（Uniform Resource Locator ，统一资源定位符）是浏览器寻找信息时所需的资源位置。通过URL这种因特网的标准化名称，人类和应用程序才能找到并使用因特网上大量的数据资源。本文将介绍URL的语法，Web客户端支持的URL快捷方式，URL编码和字符规则等等。</p><a id="more"></a><p>服务器资源名被称为URI（统一资源标识符），而我们常说的URL，实际上是URI的一个子集，也是URI最常见的形式。除此之外，URI还包括URN（其通过名字来识别资源，与它们当前所处位置无关，现仍处于试用阶段）。实际上HTTP应用程序处理的只是URL，所以下面讲的基本都是URL。</p><h1 id="1-URL的语法"><a href="#1-URL的语法" class="headerlink" title="1. URL的语法"></a>1. URL的语法</h1><p>大多数URL语法都建立在以下9部分构成的通用格式上，其中最重要的方案（scheme）、主机（host）和路径（path）：</p><pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code></pre><ol><li>方案（scheme）：它会告诉负责解析URL的应用程序应该使用什么协议，其大小写无关。一般有http、https、ftp、mailto、telnet等等。例子：<code>http://www.baidu.com</code></li><li>主机与端口（host、port）：主机标识了因特网上能够访问资源的宿主机器，可用主机名（域名）或IP地址表示；端口标识了服务器正在监听的网络端口，对下层使用TCP协议的HTTP来说，默认端口号为80。例子：<code>http://115.156.216.106:3000</code></li><li>用户名与密码（user、password）：有一些服务器需要用户输入用户名和密码才允许访问数据。若URL是FTP协议而没有指定这两者，浏览器会自动插入“anonymous”和一个默认密码。例子：<code>ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu</code></li><li>路径（path）：说明了资源位于服务器的什么地方，通常像一个分级的文件系统路径。例子：<code>http://localhost:3000/css/common.css</code></li><li>参数（params）：向应用程序提供它们所需的输入参数，以便正确地与服务器进行交互，形式为key-value对列表，由“;”将其与URL其余部分分隔开来。例子：<code>ftp://prep.ai.mit.edu/pub/gnu;graphics=true</code></li><li>查询字符串（query）：可以通过查询字符串来缩小所请求资源的范围，形式同样为key-value对，之间用字符“&amp;”分隔，由“?”将其与URL其余部分分隔开来。例子：<code>http://localhost/test?id=123&amp;show=false</code></li><li>片段（frag）：表示一个资源内部的片段，通常用于在页面中设置“书签”并实现页内跳转。片段出现在URL的最右边，前面有一个字符“#”。<strong>注意客户端不会将片段发送到服务器，浏览器从服务器获得整个资源后，会根据片段在页内跳转到指定的位置。</strong>例子：<code>http://localhost/test#hehe</code></li></ol><h1 id="2-URL快捷方式"><a href="#2-URL快捷方式" class="headerlink" title="2. URL快捷方式"></a>2. URL快捷方式</h1><p>URL有两种方式：绝对的和相对的。像上面列举的都是绝对URL，包含了访问资源所需的全部信息。相对URL是一种简写方式，需要相对一个<strong>基础URL</strong>进行解析。</p><p>相对URL到绝对URL的转换处理，首先是要找到基础URL，一般可以显示提供（比如HTML文档定义一个<base>标签显式指定基础URL），或者在封装资源中提供（比如HTML文档中的a标签链接，其基础URL就是这个HTML文档本身）。接着就是通过以下算法把相对URL转换成绝对URL。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTTP/%E7%9B%B8%E5%AF%B9URL%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%9D%E5%AF%B9URL%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="相对URL转换成绝对URL算法流程图"></p><h1 id="3-URL字符与编码"><a href="#3-URL字符与编码" class="headerlink" title="3. URL字符与编码"></a>3. URL字符与编码</h1><p>通常来说，URL采用的是US-ASCII字符集，但是这有很多局限性，因此用一种“转义”表示法来表示不安全字符，通过这种编码机制来避开各种限制。这种转义表示法包含一个百分号“%”，后面跟着两个表示ASCII字符的十六进制数。例如URL中的“~”编码成“%7E”，空格编码成“%20”，“%”编码成“%25”。此外URL还有一些字符用作保留字符，如<code>%/.#?;:@&amp;=</code>等等，此处不再赘述。</p><p>URL是一种强有力的工具，可以用来命名所有现存对象，也可以很方便地包含一些新格式。但它并不完美，它们表示的是实际的地址而不是准确的名字，这就意味着如果资源被移走了，URL也就失效了（404 not found）。URN就是为了应对这种情况的，无论对象搬移到什么地方，URN都能为对象提供一个稳定的名称。当然，URN背后的思想已经提出一段时间了，但是从URL转换成URN是一项巨大的工程，标准化工作的进程非常缓慢，所以现在因特网资源仍以URL来命名，而且这种趋势仍会保持相当长一段时间。</p><p>参考文献：人民邮电出版社《HTTP权威指南》第2章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> URL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git指南（4）——与远程库交互</title>
      <link href="/tech/tool/git/git-tutorial-4/"/>
      <url>/tech/tool/git/git-tutorial-4/</url>
      
        <content type="html"><![CDATA[<p>前面几篇Git指南中所介绍的都是本地的（即在你自己的机器上）版本控制方法。在实际的应用中，经常会和其他人共同维护一个项目，这时可能有一个中心服务器来托管所有开发者的代码，并在不同人之间同步代码，这就需要了解Git如何在本地和远程repo之间进行交互。</p><p>作为一个基于Git的代码托管平台，<a href="https://github.com" target="_blank" rel="noopener">Github</a>目前拥有140多万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。因此本文将以Github为例来说明如何与远程库交互。</p><a id="more"></a><h1 id="1-克隆远程仓库"><a href="#1-克隆远程仓库" class="headerlink" title="1. 克隆远程仓库"></a>1. 克隆远程仓库</h1><p>Github上有许多开源项目，如果你想把别人的代码下载下来自己学习或者修改，最直接的办法就是克隆一个仓库到你本地。找到你想要的仓库的存放地址（Github仓库右侧“HTTPS clone URL”一栏可以复制），在你想要存放仓库的目录打开命令行窗口，输入以下命令即可克隆一份代码到你本地（以下的仓库地址是我的<a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism" target="_blank" rel="noopener">博客主题</a>项目）：</p><pre><code>git clone https://github.com/raytaylorlin/hexo-theme-raytaylorism.git</code></pre><p>输入<code>git remote</code>可以列出每个远程库的简短名字，在克隆完某个项目后，至少可以看到一个名为origin的远程库，Git默认使用这个名字来标识你所克隆的原始仓库。以下命令可以看到远程库的详细信息：</p><pre><code>git remote show origin# 使用git remote -v 可以显示对应的克隆地址</code></pre><h1 id="2-与远程库同步"><a href="#2-与远程库同步" class="headerlink" title="2. 与远程库同步"></a>2. 与远程库同步</h1><p>本地repo和远程repo是两个相互独立的仓库，当别人在远程repo中做了修改后，你可以通过拉取<code>git pull</code>来获取远程库中的提交，并合并到本地仓库。注意，pull操作等价于下面先获取再合并的两步：</p><pre><code>git fetchgit merge origin/master</code></pre><p>你也可以通过推送<code>git push</code>把你本地的修改提交到远程库，这是git pull的反向操作。</p><p>从上面的操作可以看到，本地repo和远程repo之间是有一定联系的，当你执行push或pull的操作时，本地总能与远程的仓库正确地同步，这是因为在<code>git clone</code>的过程中，git已经帮你在两个repo之间搭起了一座“桥梁”。如果你在Github上面创建了一个新的repo，然后想把你本地已经创建好的repo与Github上面的进行同步，此时两个仓库就像两个孤立的岛屿一样，这时候可以用下面的命令来“搭建桥梁”：</p><pre><code>git remote add origin [远程仓库地址]# 建立起关联后，就可以进行push和pull了</code></pre><p>此外，可以用<code>git remote rename</code>命令修改某个远程仓库在本地的简称；碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行<code>git remote rm</code>命令来移除。</p><h1 id="2-Git的分布式工作流程"><a href="#2-Git的分布式工作流程" class="headerlink" title="2. Git的分布式工作流程"></a>2. Git的分布式工作流程</h1><p>同传统的集中式版本控制系统（CVCS）不同，开发者之间的协作方式随着Git的分布式特性而变得更为灵活多样。下面简要介绍两种常见的工作流。</p><h2 id="2-1-集中式工作流"><a href="#2-1-集中式工作流" class="headerlink" title="2.1 集中式工作流"></a>2.1 集中式工作流</h2><p>通常，集中式工作流程使用的都是单点协作模型（如下图所示）。一个存放代码仓库的中心服务器，可以接受所有开发者提交的代码。所有的开发者都是普通的节点，作为中心集线器的消费者，平时的工作就是和中心仓库同步数据。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/git/Git%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Git集中式工作流示意图"></p><p>如果两个开发者从中心仓库克隆代码下来，同时作了一些修订，那么只有第一个开发者可以顺利地把数据推送到共享服务器。第二个开发者在提交他的修订之前，必须先下载合并服务器上的数据，解决冲突之后才能推送数据到共享服务器上。如果团队不是很大，或者大家都已经习惯了使用集中式工作流程，完全可以采用这种简单的模式。绝大多数人都熟悉和了解这种模式的工作方式，所以使用也非常广泛。</p><h2 id="2-2-集成管理员工作流"><a href="#2-2-集成管理员工作流" class="headerlink" title="2.2 集成管理员工作流"></a>2.2 集成管理员工作流</h2><p>由于Git允许使用多个远程仓库，开发者便可以建立自己的公共仓库，往里面写数据并共享给他人，而同时又可以从别人的仓库中提取他们的更新过来。在GitHub网站上使用得最多的就是这种工作流。具体的流程和示意图如下：</p><ol><li>项目维护者可以推送数据到公共仓库（blessed repository）。</li><li>贡献者<strong>Fork</strong>此仓库，修订或编写新代码。</li><li>贡献者推送数据到自己的公共仓库（developer public）。</li><li>贡献者给维护者发送邮件（在Github上则是发起<strong>Pull Request</strong>），请求拉取自己的最新修订。</li><li>维护者在自己本地的（integration manger）仓库中，将贡献者的仓库加为远程仓库，合并更新并做测试。</li><li>维护者将合并后的更新推送到主仓库（blessed repository）。</li></ol><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/git/Git%E9%9B%86%E6%88%90%E7%AE%A1%E7%90%86%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Git集成管理员工作流示意图"></p><p>详情参照<a href="http://iissnan.com/progit/html/zh/ch5_1.html" target="_blank" rel="noopener">Pro Git分布式工作流程</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git指南（3）——分支与合并</title>
      <link href="/tech/tool/git/git-tutorial-3/"/>
      <url>/tech/tool/git/git-tutorial-3/</url>
      
        <content type="html"><![CDATA[<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。相比同类软件，Git很显著的一个优点，就是版本的分支（branch）和合并（merge）十分方便。有人把Git的分支模型称为“必杀技特性”，因为它的分支可谓是难以置信的轻量级。理解分支的概念并熟练运用后，你才会意识到为什么Git是一个如此强大而独特的工具，并从此真正改变你的开发方式。本文将简单介绍Git的分支与合并的基本知识。</p><a id="more"></a><h1 id="1-Git分支管理策略"><a href="#1-Git分支管理策略" class="headerlink" title="1. Git分支管理策略"></a>1. Git分支管理策略</h1><p>Git的新建分支操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。</p><p>但是太方便了也会产生副作用。如果你不加注意，很可能会留下一个枝节蔓生、四处开放的版本库，到处都是分支，完全看不出主干发展的脉络。所以在学习Git的分支之前，有必要先了解一下常用的分支管理策略。</p><p>（本节参考自<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">阮一峰的《Git分支管理策略》</a>）</p><ol><li>主分支master：代码库应该有且只有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。</li><li>开发分支develop：主分支只用来分布重大版本，日常开发应该在开发分支Develop上完成。如果想正式对外发布，就在Master分支上，对Develop分支进行“合并”。</li><li>功能分支feature：从develop上衍生出来，一般是为了开发某种特定功能，开发完成后，要再合并入develop。分支名字可以采用<code>feature-*</code>的形式命名。</li><li>修补bug分支fixbug：软件正式发布以后，难免会出现bug。这时就需要从master分支上面分出来，进行bug修补，修补结束以后，再合并进master和develop分支。分支名字可以采用<code>fixbug-*</code>的形式命名。</li><li>预发布分支release：发布正式版本之前（即合并到Master分支之前），可能需要从develop分支上分出来一个预发布的版本进行测试，预发布结束以后，必须合并进develop和master分支。分支名字可以采用<code>release-*</code>的形式命名。（此种分支一般比较少用）</li></ol><p>以上的功能分支、修补bug分支和预发布分支都属于临时性分支，一般使用完以后要删除掉这种分支，使得代码库的常设分支只有master和develop。最后以一张图总结一下常用的分支形式图。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/git/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Git分支管理示意图"></p><h1 id="2-分支与管理命令"><a href="#2-分支与管理命令" class="headerlink" title="2. 分支与管理命令"></a>2. 分支与管理命令</h1><p>以下命令用来创建一个新的分支。</p><pre><code>git checkout -b develop# 与git branch develop等价</code></pre><p>创建完后执行<code>git status</code>会告诉你现在处于新的develop的分支，执行<code>git branch</code>可以看到仓库中存在的所有分支。在新的分支下你可以正常地编辑代码和提交，而不会影响到其他分支上的代码。如果你想切换回主分支，直接<code>git checkout master</code>即可。</p><p>上一节介绍了一些临时性分支，往往使用完毕后要删除，命令如下：</p><pre><code>git branch -d fixbug-somebug# -d参数只能删除那些已经被当前分支合并的分支，如果要强制删除未被合并的分支，使用-D参数</code></pre><p>有分支就会有合并，否则分支就失去了它的意义。下面的例子先切换到master，然后把develop分支的改动合并到主分支上：</p><pre><code>git checkout mastergit merge develop</code></pre><p>Git的合并功能非常强大，很多情况下它都会非常智能地帮你自动合并分支的代码，但是有时候也会出现冲突（conflict）而无法自动合并的情况，这时就需要我们手动来解决冲突。现在假设你在合并代码的时候，hello.py这个文件出现了冲突，该文件冲突的地方大概会是下面这个样子：</p><pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADprint &apos;This is the HEAD of master branch&apos;=======print &apos;The conflict code of develop branch&apos;&gt;&gt;&gt;&gt;&gt;&gt;&gt; master</code></pre><p>Git会自动给冲突的代码填上一些看上去和你奇怪的标记表明两个分支上代码的差异，手动解决冲突只要保留你想要的代码（也可以修改它们），然后删除多余的“&lt;&lt;&lt;&lt;”“====”“&gt;&gt;&gt;&gt;”行即可。最后记得要commit一下提交你的修改，如果出现“fixed conflict”字样就表明冲突已解决。</p><p>如果是少量的代码冲突用手动解决还好，当碰上大量的代码冲突时，直接在源文件中看有点力不从心了。如果你安装了Git Tortoise这个软件，就可以使用里面的图形化冲突解决工具，左右两个窗口对比着来解决冲突。当然也可以使用其他的第三方工具来合并。</p><h1 id="3-变基简介"><a href="#3-变基简介" class="headerlink" title="3. 变基简介"></a>3. 变基简介</h1><p>Git还提供了一种合并功能，称为变基（rebase），它和上面提到的合并（merge）非常相似。下面以一个例子来讲解它们的区别：假设现在本地repo处于master分支，远程repo处于origin/master分支，它们的分支路线图如下：</p><pre><code>      D---E master     /A---B---C---F origin/master</code></pre><p>使用merge合并后，路线分支图如下：</p><pre><code>      D--------E       /           \A---B---C-----F---G   master, origin/master</code></pre><p>而使用进行变基合并后，路线分支图如下：</p><pre><code>A---B---C---F---D&apos;---E&apos;   master, origin/master</code></pre><p>也就是说，使用rebase来合并分支可以让你的分支路线图看起来只有一条主线。此外，本地的分支之间也可以使用变基合并，比如把fixbug分支变基到master分支，只需要：</p><pre><code>git checkout mastergit rebase fixbug</code></pre><p>拉取pull预设的行为是将远程的repo与本地的repo合并，如果本地的branch和远端的branch会同步得非常频繁（几乎是完全同步），这时候就会发现pull下来经常会冲突，然后用merge就会造成路线图变得很复杂，难以看到开发的主线，就像下图所示。这时候就会推荐使用<code>git pull --rebase</code>来进行变基拉取。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/git/%E5%A4%8D%E6%9D%82%E7%9A%84%E5%88%86%E6%94%AF%E8%B7%AF%E7%BA%BF%E5%9B%BE.jpg" alt="复杂的分支路线图"></p><p>在rebase的过程中，也许会出现冲突，Git会停止rebase并会让你去解决冲突。解决完冲突后，用<code>git-add</code>命令去更新这些内容的，只要执行以下语句（不需要提交commit）。</p><pre><code>git rebase --continue</code></pre><p>这样git会继续应用余下的补丁。在任何时候，你可以用<code>git rebase --abort</code>来终止rebase的行动，并且分支会回退到rebase开始前的状态。</p><p>虽然rebase可以让路线图看起来非常干净，但使用它还是具有一定风险的！要记住：<strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行rebase操作。</strong>在进行rebase的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用git rebase抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。</p><p>总而言之，<strong>如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅rebase那些尚未公开的提交对象，就没问题。如果rebase那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。</strong>（参考此处<a href="http://git-scm.com/book/zh/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88" target="_blank" rel="noopener">麻烦的例子</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django学习笔记（4）——Django的Admin后台管理</title>
      <link href="/tech/language/python/django-note-4/"/>
      <url>/tech/language/python/django-note-4/</url>
      
        <content type="html"><![CDATA[<p>对于某一类网站，管理界面是基础设施中非常重要的一部分。这是以网页和有限的可信任管理者为基础的界面，它可以让你添加，编辑和删除网站内容。如果你用过Wordpress这款博客管理工具，一定对其管理后台很熟悉——用这个界面发布，管理博客和目录等等。但是管理界面有一问题：创建它太繁琐。当你开发对公众的功能时，网页开发是有趣的，但是创建管理界面通常是千篇一律的——你必须认证用户，显示并管理表格，验证输入的有效性诸如此类，这些都是很繁琐而且很重复的劳动。</p><p>Django在对这些繁琐和重复的工作进行了相当大的改进，它用不能再少的代码为你做了所有的一切。本文将介绍Django的Admin自动管理界面——它读取你模式中的元数据，然后提供给你一个强大而且可以使用的界面，网站管理者可以用它立即工作。</p><a id="more"></a><h1 id="1-想清楚用不用管理界面"><a href="#1-想清楚用不用管理界面" class="headerlink" title="1. 想清楚用不用管理界面"></a>1. 想清楚用不用管理界面</h1><p>在开始使用Django提供的这个强大的工具之前，有必要先认清Django Admin能干什么，应该什么时候用它什么时候不用它。</p><p>Django的管理界面对非技术用户要输入他们的数据时特别有用，在Django最开始开发的新闻报道的行业应用中，有一个典型的在线自来水的水质专题报道应用，它的实现流程是这样的：</p><ol><li>负责这个报道的记者和要处理数据的开发者碰头，提供一些数据给开发者</li><li>开发者围绕这些数据设计模型然后配置一个管理界面给记者</li><li>记者检查管理界面，尽早指出缺少或多余的字段。开发者来回地修改模块</li><li>当模块认可后，记者就开始用管理界面输入数据。同时，程序员可以专注于开发公众访问视图和模板</li></ol><p>也就是说，Django的管理界面为内容输入人员和编程人员都提供了便利的工具。此外，管理界面在下面这些情景中也是很有用的：</p><ul><li>检查模块：当你定义好了若干个模块，在管理页面中把他们调出来然后输入一些虚假的数据，这是相当有用的。有时候，它能显示数据建模的错误或者模块中其它问题。</li><li>管理既得数据：如果你的应用程序依赖外部数据（来自用户输入或网络爬虫），管理界面提供了一个便捷的途径，让你检查和编辑那些数据。你可以把它看作是一个功能不那么强大，但是很方便的数据库命令行工具。</li><li>临时的数据管理程序：你可以用管理工具建立自己的轻量级数据管理程序，比如说开销记录。如果你正在根据自己的，而不是公众的需要开发些什么，那么管理界面可以带给你很大的帮助。从这个意义上讲，你可以把它看作是一个增强的关系型电子表格。</li></ul><h1 id="2-激活管理界面"><a href="#2-激活管理界面" class="headerlink" title="2. 激活管理界面"></a>2. 激活管理界面</h1><p>Django管理站点完全是可选择的，因为仅仅某些特殊类型的站点才需要这些功能。这意味着你需要在你的项目中花费几个步骤去激活它。</p><p>首先将<code>django.contrib.admin</code>加入setting.py的INSTALLED_APPS配置中；保证INSTALLED_APPS中包含<code>django.contrib.auth</code>，<code>django.contrib.contenttypes</code>和<code>django.contrib.sessions</code>；MIDDLEWARE_CLASSES包含<code>django.middleware.common.CommonMiddleware</code> 、<code>django.contrib.sessions.middleware.SessionMiddleware</code> 和<code>django.contrib.auth.middleware.AuthenticationMiddleware</code> 。</p><p>然后，运行<code>python manage.py syncdb</code>，这一步将生成管理界面使用的额外数据库表。 当你把“django.contrib.auth”加进INSTALLED_APPS后，第一次运行syncdb命令时, 系统会请你创建一个超级用户。如果你不这么做，你需要运行<code>python manage.py createsuperuser</code>来另外创建一个admin的用户帐号，否则你将不能登入admin。</p><p>最后，修改urls.py将admin访问配置在URLconf中，如下所示。</p><pre><code>from django.contrib import adminadmin.autodiscover()urlpatterns = patterns(&apos;&apos;,    (r&apos;^admin/&apos;, include(admin.site.urls)),)</code></pre><p>当这一切都配置好后，启动开发服务器(<code>python manage.py runserver</code>)，然后在浏览器中访问<a href="http://localhost:8000/admin/，现在你将发现Django管理工具可以运行了。" target="_blank" rel="noopener">http://localhost:8000/admin/，现在你将发现Django管理工具可以运行了。</a></p><h1 id="3-使用Admin管理你的数据"><a href="#3-使用Admin管理你的数据" class="headerlink" title="3. 使用Admin管理你的数据"></a>3. 使用Admin管理你的数据</h1><p>使用刚刚创建的超级账户登录admin后，你会发现仅有两个默认的管理编辑模块：用户组(Groups)和用户(Users)。因为你是用超级用户登录的，你可以创建，编辑和删除任何对象。然而，不同的环境要求有不同的权限，系统不允许所有人都是超级用户。管理工具有一个用户权限系统，通过设置用户组和用户，你可以根据用户的需要来指定他们的权限，从而达到部分访问系统的目的。</p><p>现在将定义的Models加入到Admin管理中，就可以直接通过这个界面来管理数据库。这里我们引用<a href="/Tech/Script/Python/django-note-2/">学习笔记（2）</a>中定义的模型Publisher、Author和Book。在books这个app的目录下，创建<code>admin.py</code>文件，然后输入以下代码：</p><pre><code>from django.contrib import adminfrom mysite.books.models import Publisher, Author, Bookadmin.site.register(Publisher)admin.site.register(Author)admin.site.register(Book)</code></pre><p>这些代码通知管理工具为这些模块逐一提供界面。完成后打开admin页面，你将可以看到一个Books区域，其中包含Authors、Books和Publishers等管理区，然后你就可以对数据进行增删查改了，所见即所得。同时admin管理界面也很智能地处理了各种外键关系，例如Book模型的publisher字段后面有一个绿色加号，可以打开一个新窗口让你快速添加相关记录，然后再回头编辑；另外，如果你的字段有类型限制（比如EmailField，max_length等），在保存修改的时候会检查管理员的输入是否符合格式，方便吧！</p><p>最后再介绍一下自定义列表，这个功能可以很方便地修改admin界面特定模型的管理方式。例如在Book模型中，有title、author、publisher、publication_date四个字段，默认的admin管理会把所有字段都显示出来。看看以下代码：</p><pre><code>class BookAdmin(admin.ModelAdmin):    # 指定要显示的字段    list_display = (&apos;title&apos;, &apos;publisher&apos;, &apos;publication_date&apos;)    # 指定列表过滤器，右边将会出现一个快捷的日期过滤选项，以方便开发人员快速地定位到想要的数据，同样你也可以指定非日期型类型的字段    list_filter = (&apos;publication_date&apos;,)    # 指定要搜索的字段，将会出现一个搜索框让管理员搜索关键词    search_fields = (&apos;title&apos;,)</code></pre><p>Admin的自定义列表和自定义编辑表单还是挺强大的，详情可以参照<a href="http://djangobook.py3k.cn/2.0/chapter06/" target="_blank" rel="noopener">这里</a>，此处不再赘述。有了Admin这个工具，对于一些产品展示或者内容展示类型的网站，Web开发者再也不用费力气去开发一个庞大的后台管理，而可以把更多的精力投入到业务逻辑和前端开发中。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django学习笔记（3）——Django的模板</title>
      <link href="/tech/language/python/django-note-3/"/>
      <url>/tech/language/python/django-note-3/</url>
      
        <content type="html"><![CDATA[<p>在<a href="/Tech/Script/Python/django-note-1/">学习笔记（1）</a>中，你可能已经注意到我们在例子视图hello_view中返回文本的方式有点特别。也就是说，HTML可以直接硬编码在Python代码之中。但是直接将HTML编码到Python代码中有许多坏处：对页面设计进行的任何改变都必须对Python代码进行相应的修改，站点设计的修改往往比底层Python代码的修改要频繁得多；Python代码编写和HTML设计是两项不同的工作，大多数专业的网站开发环境都将他们分配给不同的人员（甚至不同部门）来完成。</p><p>基于这些原因，将页面的设计和Python的代码分离开会更干净简洁更容易维护。我们可以使用Django的模板系统(Template System)来实现这种模式，这就是本文要具体讨论的问题。</p><a id="more"></a><h1 id="1-Django模板系统"><a href="#1-Django模板系统" class="headerlink" title="1. Django模板系统"></a>1. Django模板系统</h1><h2 id="1-1-模板系统基础"><a href="#1-1-模板系统基础" class="headerlink" title="1.1 模板系统基础"></a>1.1 模板系统基础</h2><p>模板是一个文本，用于分离文档的表现形式和内容。模板定义了占位符以及各种用于规范文档该如何显示的各部分基本逻辑（模板标签）。模板通常用于产生HTML，但是Django的模板也能产生任何基于文本格式的文档。下面这个模板例子描述了一个向某个公司签单人员致谢HTML页面。</p>    <html>    <head><meta name="generator" content="Hexo 3.8.0">        <title>Ordering notice</title>    </head>    <body>        <h1>Ordering notice</h1>        <p>Dear {{ person_name }},</p>        <p>Thanks for placing an order from {{ order.company }}. It's scheduled to        ship on {{ order.ship_date|date:"F j, Y" }}.</p>        <p>Here are the items you've ordered:</p>                <ul>        {% for item in item_list %}            <li>{{ item }}</li>        {% endfor %}        </ul>        {% if ordered_warranty %}            <p>Your warranty information will be included in the packaging.</p>        {% else %}            <p>You didn't order a warranty, so you're on your own when            the products inevitably stop working.</p>        {% endif %}        <p>Sincerely,<br>{{ company }}</p>    </body>    </html><p>可以看出，模板跟HTML很像，事实上它就是保存成一个.html文件，它跟我们以前见到的HTML的区别就在于多了一些由双花括号<code>{{ }}</code>括起来的<strong>变量</strong>以及由<code>{% %} </code>括起来的模板标签，此外变量还可以通过过滤器（<code>|</code>管道符）转换变量输出格式。</p><p>变量在这里起到了占位符的作用，一般它最终会被传入模板的数据替代，最后模板将变成真正的HTML代码展现给用户。模板标签不会输出到最终的HTML中，它们多数起到了逻辑控制的作用，例如上例中，如果传入的ordered_warranty值为True，则显示相应的p标签；标签<code>{% for %}</code>遍历传入的item_list，并依次生成结构相同但内容不同的HTML。</p><p>通常来说，我们会将模板和视图一起使用，但模板本身是一个Python库，你可以在任何地方使用它，而不仅仅是在Django视图中。这里简单介绍一下单独在Python代码中使用Django模板的最基本方式：</p><ol><li>可以用原始的模板代码字符串创建一个Template对象，Django同样支持用指定模板文件路径的方式来创建Template对象</li><li>调用模板对象的render方法，并且传入一套变量context。它将返回一个基于模板的展现字符串，模板中的变量和标签会被context值替换。示例代码如下：</li></ol>    from django import template    t = template.Template('My name is {{ name }}.')    c = template.Context({'name': 'Adrian'})    print t.render(c)<p>但实际的Django开发中我们一般不使用这种方式来渲染模板，后面将会看到更简单直接的方法。</p><h2 id="1-2-模板标签介绍"><a href="#1-2-模板标签介绍" class="headerlink" title="1.2 模板标签介绍"></a>1.2 模板标签介绍</h2><ol><li><code>{% if %} {% endif %}</code>标签检查一个变量，如果这个变量为真（即变量存在，非空，不是布尔值假），系统会显示在<code>if</code>和<code>endif</code>之间的任何内容。此外，还有一个可选的<code>else</code>标签，但是<strong>没有</strong><code>elif</code>标签，所以如果需要多个分支条件，可以使用嵌套的<code>if</code>标签来代替。<code>if</code>标签可以接受<code>and</code>，<code>or</code>或<code>not</code>关键字来对多个变量做判断，并且<strong>不允许在同一个标签中同时使用and和or，因为逻辑上可能模糊的</strong>。</li><li><p><code>{% for %} {% endfor %}</code>允许我们在一个序列上迭代，每一次循环中，模板系统会渲染在<code>for</code>和<code>endfor</code>之间的所有内容。每个for循环里还有一个称为<code>forloop</code>的模板变量，这个变量有一些提示循环进度信息的属性，关于这个变量的详细用法可以参照<a href="http://djangobook.py3k.cn/appendixF/" target="_blank" rel="noopener">这篇文章</a>的for一节。下面一段示例代码给出和for标签结合使用的reverse（反向遍历）和empty（列表为空的情况）标签的用法：</p>    {% for athlete in athlete_list reverse%}    <p>{{ athlete.name }}</p>    {% empty %}    <p>There are no athletes. Only computer programmers.</p>    {% endfor %}    </li><li><p><code>{% ifequal VARIABLE CONSTANT %} {% endifequal %}</code>标签比较VARIABLE和CONSTANT两个值，当他们相等时，显示在<code>ifequal</code> 和<code>endifequal</code>之中所有的值</p></li><li><code>{# #}</code>是Django模板语言的代码注释</li><li>就像前面提到的一样，模板过滤器是在变量被显示前修改它的值的一个简单方法，而且一个过滤器管道的输出又可以作为下一个管道的输入。常用的过滤器有<code>first</code>，<code>upper</code>，<code>truncatewords</code>等等，详情同样参照<a href="http://djangobook.py3k.cn/appendixF/" target="_blank" rel="noopener">这篇文章</a>。</li></ol><h1 id="2-在视图中使用模板"><a href="#2-在视图中使用模板" class="headerlink" title="2. 在视图中使用模板"></a>2. 在视图中使用模板</h1><h2 id="2-1-配置模板路径"><a href="#2-1-配置模板路径" class="headerlink" title="2.1 配置模板路径"></a>2.1 配置模板路径</h2><p>为了减少模板加载调用过程及模板本身的冗余代码，Django提供了一种使用方便且功能强大的API，用于从磁盘中加载模板，要使用此模板加载API，首先你必须将模板的保存位置告诉框架。假设项目根目录是mysite，一般会在这个目录下建立一个templates文件夹，专门存放模板。然后在setting.py中设置<code>TEMPLATE_DIRS</code>这一项。</p><pre><code>TEMPLATE_DIRS = (    &apos;templates/&apos;,)</code></pre><h2 id="2-2-渲染模板"><a href="#2-2-渲染模板" class="headerlink" title="2.2 渲染模板"></a>2.2 渲染模板</h2><p>Django提供了一个捷径，让你一次性地载入某个模板文件，渲染它，然后将此作为HttpResponse返回。我们以下面这样一个模板文件（current_datetime.html）为例。</p>    <html><body>It is now {{ current_date }}.</body></html><p>那么现在的视图views.py可以这样写。</p><pre><code>from django.shortcuts import render_to_responseimport datetimedef current_datetime_view(request):    # 获取填充模板的变量，这里经常会是调用Model层的方法访问数据库    now = datetime.datetime.now()    # 第一个参数是要使用的模板名称，第二个参数是一个字典，用于填充模板    return render_to_response(&apos;current_datetime.html&apos;, {&apos;current_date&apos;: now})</code></pre><p>以上模板加载、上下文创建、模板解析和HttpResponse创建工作均在对均被<code>render_to_response()</code>的调用给包办了了，因为这个函数返回了HttpResponse对象，所以我们仅需在视图中 return该值。</p><h1 id="3-模板的编写原则"><a href="#3-模板的编写原则" class="headerlink" title="3. 模板的编写原则"></a>3. 模板的编写原则</h1><p>在介绍了模板加载机制之后，我们再介绍一个利用该机制的内建模板标签：<code>{% include %}</code> 。该标签允许在（模板中）包含其它的模板的内容。标签的参数是所要包含的模板名称，可以是一个变量，也可以是用单/双引号硬编码的字符串。每当在多个模板中出现相同的代码时，就应该考虑是否要使用<code>include</code>来减少重复，这也是为了提高代码的可重用性。</p><p>在实际应用中，经常会用Django模板系统来创建整个HTML页面。这就带来一个常见的 Web 开发问题：在整个网站中，如何减少共用页面区域（比如站点导航）所引起的重复和冗余代码？</p><p>解决该问题的传统做法是使用服务器端的includes，你可以先编写各小部分（比如导航栏、header、footer、各功能区块等等），然后在一个base.html中搭出网页的HTML骨架，然后用<code>include</code>像拼拼图一样各个模板组装成最后的大页面。但是用Django解决此类问题的首选方法是使用更加优雅的策略——<em>模板继承</em>。你可以对那些<strong>不同</strong>的代码段进行定义，而不是定义<strong>相同</strong>的代码段。</p><p>第一步是定义<em>基础模板base.html</em>，该模板之后将由<em>子模板</em>继承。</p>    {% load staticfiles %}    <!DOCTYPE html>    <head><meta name="generator" content="Hexo 3.8.0">        <title>            {% block title %} The Default Title {% endblock %}        </title>        {% block css %}         <link href="{% static " css base.css" %}" rel="stylesheet" type="text/css">        {% endblock %}    </head>    <body>        <div id="wrapper">            {% block header %}            {% include 'partial/header.html' %}            {% endblock %}            {% block content %} {% endblock %}            {% block footer %}            {% include 'partial/footer.html' %}            {% endblock %}        </div>        {% block js %}         <script type="text/javascript" src="{% static " js jquery.min.js" %}"></script>        {% endblock %}    </body><p>所有的<code>block</code>标签告诉模板引擎，子模板可以重载这些部分，如果子模板不重载这些部分，则将按默认的内容显示。（顺便提一下，模板中的<code>load staticfiles</code>表示加载静态资源，这个一般用于加载CSS,JS等静态文件时用到）上面的基础模板中定义了6个block，当我们的页面有变化时，随时可以对这些block做出修改，看看下面的首页index.html：</p>    {% extends "base.html" %}    {% load staticfiles %}    {% block css %}     {{ block.super }}    <link href="{% static " css page index.css" %}" rel="stylesheet" type="text/css">    {% endblock %}    {% block content %}    <p>Hello world!</p>    {% include "partial/index/product_list.html" %}    {% endblock %}<p>在index.html中，首先用<code>extends</code>标签声明这个模板继承的父模板（必须保证其为模板中的第一个模板标记）。接着重定义css这个block，在包含了父模板的基础上（<code>block.super</code>）引入了新的CSS文件（也就是说，这里最终会加载base.css和index.css两个文件）；替换了content这个block。这就是子模板所做的全部工作。注意：<strong>继承并不会影响到模板的上下文。换句话说，任何处在继承树上的模板都可以访问到你传到模板中的每一个模板变量。</strong></p><p>最后总结一下Django模板的编写原则。你可以根据需要使用任意多的继承次数。使用继承的一种常见方式是下面的三层法：</p><ol><li>创建base.html模板，在其中定义站点的主要外观感受。这些都是不常修改甚至从不修改的部分。</li><li>为网站的每个区域创建base_SECTION.html模板(例如, base_photos.html和base_forum.html)。这些模板对base.html进行拓展，并包含区域特定的风格与设计。</li><li>为每种类型的页面创建独立的模板，例如论坛页面或者图片库。这些模板拓展相应的区域模板。</li></ol><p>这个方法可最大限度地重用代码，并使得向公共区域（如区域级的导航）添加内容成为一件轻松的工作。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django学习笔记（2）——Django的模型</title>
      <link href="/tech/language/python/django-note-2/"/>
      <url>/tech/language/python/django-note-2/</url>
      
        <content type="html"><![CDATA[<p>在Django中，视图负责处理一些业务逻辑，然后返回响应结果。在当代Web应用中，业务逻辑经常牵涉到与数据库的交互，在后台连接数据库服务器，从中取出一些数据，然后在Web页面用漂亮的格式展示这些数据。这个网站也可能会向访问者提供修改数据库数据的方法。</p><p>在这一篇博文中，我们将以MySQL数据库为例，先看看不使用Django模型的数据库查询方法，然后开始学习Django的模型。</p><a id="more"></a><h1 id="1-不使用模型的数据库查询方法"><a href="#1-不使用模型的数据库查询方法" class="headerlink" title="1. 不使用模型的数据库查询方法"></a>1. 不使用模型的数据库查询方法</h1><p>假如我们不采用Django的模型，如何从数据库中获取数据呢？通常的做法就是在视图（View）层中连接数据库，写SQL语句查询数据库，然后把数据渲染给浏览器。在本例的视图中，我们使用了MySQLdb类库（可以从<a href="http://www.djangoproject.com/r/python-mysql/" target="_blank" rel="noopener">这里</a>获得）来连接MySQL数据库，取回一些记录，将它们提供给模板以显示一个网页代码看起来像下面这样：</p><pre><code># view.pyfrom django.http import HttpResponseimport MySQLdbdef book_list_view(request):    db = MySQLdb.connect(user=&apos;me&apos;, db=&apos;mydb&apos;, passwd=&apos;secret&apos;, host=&apos;localhost&apos;)    cursor = db.cursor()    cursor.execute(&apos;SELECT name FROM books ORDER BY name&apos;)    names = [row[0] for row in cursor.fetchall()]    db.close()    return HttpResponse(names)</code></pre><p>这个方法可以达成目标，但存在着一些问题：将数据库连接参数硬编码于代码之中。 理想情况下，这些参数应当保存在 Django 配置中；我们不得不重复同样的代码：创建数据库连接、创建数据库游标、执行某个语句、然后关闭数据库；它把我们栓死在MySQL之上。如果过段时间，我们要从MySQL换到PostgreSQL，就不得不使用不同的数据库适配器（例如psycopg而不是MySQLdb），改变连接参数，根据SQL语句的类型可能还要修改SQL。理想情况下，应对所使用的数据库服务器进行抽象，这样一来只在一处修改即可变换数据库服务器。</p><p>接下来我们将开始学习Django中的模型，它提供了一种优雅的方法来抽象数据库层面的操作。</p><h1 id="2-Django的模型"><a href="#2-Django的模型" class="headerlink" title="2. Django的模型"></a>2. Django的模型</h1><h2 id="2-1-数据库配置"><a href="#2-1-数据库配置" class="headerlink" title="2.1 数据库配置"></a>2.1 数据库配置</h2><p>假定你已经完成了数据库服务器的安装，并且已经在其中创建了数据库（我是直接装了WAMP，然后启动MySQL服务）。那么只需要在settings.py文件里面设置连接数据库的参数即可，下面是以MySQL为例。</p><pre><code>DATABASE_ENGINE = &apos;mysql&apos;DATABASE_NAME = &apos;db_my_database&apos;DATABASE_USER = &apos;root&apos;DATABASE_PASSWORD = &apos;123456&apos;DATABASE_HOST = &apos;127.0.0.1&apos;DATABASE_PORT = &apos;3306&apos;</code></pre><p>输入下面这些命令来测试你的数据库配置：</p><pre><code>from django.db import connectioncursor = connection.cursor()</code></pre><p>如果没有显示什么错误信息，那么你的数据库配置是正确的。否则，你就得查看错误信息来纠正错误。详情可参考<a href="http://djangobook.py3k.cn/2.0/chapter05/" target="_blank" rel="noopener">这里</a>的表5-2。</p><h2 id="2-2-创建一个app"><a href="#2-2-创建一个app" class="headerlink" title="2.2 创建一个app"></a>2.2 创建一个app</h2><p>Django规定，如果要使用模型，必须要创建一个app。在上一篇中我们创建的是project，project和app的区别就是：一个project包含很多个Django app以及对它们的配置，一个app是一套Django功能的集合，通常包括模型和视图，按Python的包结构的方式存在。下面的语句创建了一个名为books的app，这个目录包含了这个app的模型models.py和视图views.py，它们都是空的。</p><pre><code>python manage.py startapp books</code></pre><h2 id="2-3-定义模型"><a href="#2-3-定义模型" class="headerlink" title="2.3 定义模型"></a>2.3 定义模型</h2><p>下面我们围绕一个关于书的例子来设计数据库。想象一下这样一个最简化的保存书籍信息的数据库：<em>书</em>有“书名”“作者”“出版社”“出版日期”，<em>作者</em>有“名字”“年龄”“Email”，<em>出版社</em>有“名字”“地址”，其中<em>书</em>可以有多个<em>作者</em>（多对多关系），但只能有一个<em>出版社</em>（一对多关系）。</p><p>如果你之前接触过数据库，对这些一定不陌生。首先你应该会设计3个表分别表示<em>书</em>、<em>作者</em>、<em>出版社</em>，然后开始着手写创建表的SQL语句（如果你要像我一样偷懒，甚至直接开个Navicat就开始创建表了），接下来就是常见的增删查改，你在你的网站的逻辑中写各种“INSERT INTO”“DELETE”“SELECT”“UPDATE”SQL语句来操作数据库。当网站的规模增长到一定程度，你可能会觉得不断重复写各种SQL语句会显得特别繁琐。下面我们来看看Django是如何定义模型的。</p><pre><code># models.pyfrom django.db import modelsclass Publisher(models.Model):    name = models.CharField(max_length=30)    address = models.CharField(max_length=50, blank = True)  # blank为True表明可空class Author(models.Model):    name = models.CharField(max_length=30)    age = models.IntegerField()    email = models.EmailField()class Book(models.Model):    title = models.CharField(max_length=100)    author = models.ManyToManyField(Author)    publisher = models.ForeignKey(Publisher)    publication_date = models.DateField()</code></pre><p>看着这段代码，你可以这样理解：这里定义的每个类都继承了models.Model，代表数据库中的表；类里面的字段代表数据表中的字段，数据类型则由CharField（相当于varchar）、DateField（相当于datetime）这样显而易见的类加上属性（如max_length限定长度）来定义；表与表之间的关系则由ManyToManyField（多对多）、ForeignKey（外键，一对多）和OneToOneFiled（一对一）来限定。</p><p>接下来在settings.py中找到INSTALLED_APPS这一项，如下：</p><pre><code>INSTALLED_APPS = (    &apos;django.contrib.auth&apos;,    &apos;django.contrib.contenttypes&apos;,    &apos;django.contrib.sessions&apos;,    &apos;django.contrib.sites&apos;,    &apos;mysite.books&apos;,   # 加上这一句，mysite是project，books是app)</code></pre><p>在命令行中运行<code>python manage.py syncdb</code>，看到几行“Creating table…”的字样，你的数据表就创建好了。只要你定义了模型的类和字段，Django将全部自动帮你创建好数据库。</p><p>syncdb命令是同步你的模型到数据库的一个简单方法。它会根据INSTALLED_APPS里设置的app来检查数据库，如果表不存在，它就会创建它。需要注意的是，syncdb并不能将模型的修改或删除同步到数据库；如果你修改或删除了一个模型，并想把它提交到数据库，syncdb并不会做出任何处理。如果你觉得这很不方便，可以使用一个Django的第三方的app——South——来同步数据库，使用方法可参考<a href="http://www.cnblogs.com/BeginMan/p/3324774.html" target="_blank" rel="noopener">这篇文章</a></p><h1 id="3-常用的数据库操作"><a href="#3-常用的数据库操作" class="headerlink" title="3. 常用的数据库操作"></a>3. 常用的数据库操作</h1><p>下面直接在代码里面注释说明，Django设计的简洁可以让你一看代码就知道怎么通过模型去访问数据库。</p><pre><code>from books.models import Publisher# 先创建对象，然后再save，相当于SQL中的INSERTp1 = Publisher(name=&apos;Apress&apos;, address=&apos;2855 Telegraph Avenue&apos;)p1.save()# 注意：尽管我们没有在models给表设置主键，但是Django会自动添加一个id作为主键# 通过objects这个模型管理器的all()获得所有数据行，相当于SQL中的SELECT * FROMpublisher_list = Publisher.objects.all()for publisher in publisher_list:    # 对每个publisher做处理# 修改其中一个字段，再save，相当于SQL中的UPDATE（但这里会更新所有列）p1.name = &apos;Apress Publishing&apos;p1.save()# 如果只需要更新一列，可以用update方法，并应用于结果集上更新多个数据Publisher.objects.all().update(address=&apos;USA&apos;)# 删除掉数据库中的一行，相当于SQL中的DELETEp1.delete()# filter相当于SQL中的WHERE，可设置条件过滤结果p2 = Publisher.objects.filter(name=&apos;Apress&apos;)    #单条件查询p2 = Publisher.objects.filter(name=&apos;Apress&apos;, address__contains=&apos;Telegraph&apos;)    # 多条件查询，双下划线表明会进行一些魔术般的操作，contains部分会被翻译成WHERE address LIKE &apos;%Telegraph%&apos;# 用get来获取单个结果，注意如果没有结果或结果不唯一会抛异常try:    p = Publisher.objects.get(name=&apos;Apress&apos;)except Publisher.DoesNotExist:    print &quot;Apress isn&apos;t in the database yet.&quot;else:    print &quot;Apress is in the database.&quot;# 按name字段来排序，相当于SQL中的ORDER BY，如果换成&quot;-name&quot;则是逆序result = Publisher.objects.order_by(&quot;name&quot;)# 上面的方法可以连锁使用Publisher.objects.filter(country=&quot;U.S.A.&quot;).order_by(&quot;-name&quot;)# 用索引限定数据行数，相当于SQL中的OFFSET 0 LIMIT 2Publisher.objects.order_by(&apos;name&apos;)[0:2]# 直接通过字段外键来访问数据，这有点类似于SQL中的JOINfrom books.models import Bookpublisher_addr = Book.objects.get(id=1).publisher.address# 对于用&quot;ForeignKey&quot;定义的关系，关系的另一端也能反向追溯回来。通过字段名加_set的方式可以访问到p = Publisher.objects.get(name=&apos;Apress Publishing&apos;)p.book_set.all()# 注意到Publisher类里面没有定义book这个字段，但因为定义了外键，Django已经帮我们生成了book_set这个属性# 多对多和外键工作方式相同，只不过我们处理的是QuerySet而不是模型实例b = Book.objects.get(id=1).author.all()# 反向查询还是字段名加_set，例如要查看一个作者的所有书籍a = Author.objects.get(name=&apos;Adrian&apos;)a.book_set.all()</code></pre><h1 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h1><p>从上面的介绍可以看到Django的模型已经帮我们干了非常多的事情，比如我们可以通过访问对象的属性和方法来操作数据库，这种技术叫做<a href="http://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84" target="_blank" rel="noopener">对象关系映射</a>（ORM，Object Relational Mapping）。本文仅仅介绍了Django模型最基础的部分，其他高级的用法比如增加额外的Manager方法，添加修改数据库字段等应用可以参照<a href="http://djangobook.py3k.cn/2.0/chapter10/" target="_blank" rel="noopener">这里</a>。虽然Django给我们提供了如此方便的工具，但它还是需要一定的学习成本的，比如以前你简简单单写个SQL语句就可以搞定的事情，现在要转换为对象的思维，然后去定义模型，学习模型的API。而且听别人说，在涉及到比较复杂的数据库查询和优化的时候，ORM会显得力不从心，所幸Django可以支持原始SQL查询（同样请参见上面的链接）。在日常使用和中小型应用中，使用Django的ORM已经游刃有余，毕竟开发效率才是王道。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django学习笔记（1）——开始Django</title>
      <link href="/tech/language/python/django-note-1/"/>
      <url>/tech/language/python/django-note-1/</url>
      
        <content type="html"><![CDATA[<p>最近需要对某个产品展示网站的数据库做一些修改，之前也听说过各种python的Web框架，正好可以拿来学习和练练手。貌似对初学者来说，django是一个比较老牌而且功能也很强大的框架，虽然它有很多缺点，但还是决定先从这个框架入手学习。本系列是一个简单的学习笔记，供以后参考。</p><p>网站的后台原来是用PHP的CodeIgniter框架写的，数据库只有4个表，涉及最基本的产品的增删查改和切图等操作。现在换用django后，所有后台包括模板都得重写。虽然看起来工作量很大，但实际做起来也就花三天学了下django，然后再用三天把所有后台重写（不包括部署到蛋疼的SAE的繁琐过程），可见django的开发效率是如此之高。</p><a id="more"></a><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Django是一个由Python写成的，开源的并采用了MVC设计模式的Web应用框架。但是在Django中，控制器接受用户输入的部分由框架自行处理，所以Django里更关注的是模型（Model）、模板(Template)和视图（Views），称为MTV模式。它们各自的职责如下：</p><ul><li>模型（Model），数据存取层：处理与数据相关的所有事务，即如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。</li><li>模板(Template)，表现层：处理与表现相关的决定，即如何在页面或其他类型文档中进行显示。</li><li>视图（View），业务逻辑层：存取模型及调取恰当模板的相关逻辑。模型与模板之间的桥梁。</li></ul><p>Django的MVC编程方式不同于CodeIgniter那样把业务逻辑都放在控制器中，Django的MVC控制器部分由URLconf来实现。URLconf机制是使用正则表达式匹配URL，然后调用合适的Python函数。它比MVC框架考虑的问题要深一步，因为我们程序员大都写程序在控制层。现在这个工作交给了框架，仅需写很少的调用代码，大大提高了工作效率。</p><h2 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h2><p>Django框架的核心包括：一个面向对象的映射器，用作数据模型（以Python类的形式定义）和关联性数据库间的媒介；一个基于正则表达式的URL分发器；一个视图系统，用于处理请求；以及一个模板系统。核心框架中还包括：</p><ul><li>一个轻量级的、独立的Web服务器，用于开发和测试。</li><li>一个表单序列化及验证系统，用于HTML表单和适于数据库存储的数据之间的转换。</li><li>一个缓存框架，并有几种缓存方式可供选择。</li><li>中间件支持，允许对请求处理的各个阶段进行干涉。</li><li>内置的分发系统允许应用程序中的组件采用预定义的信号进行相互间的通信。</li><li>一个序列化系统，能够生成或读取采用XML或JSON表示的Django模型实例。</li><li>一个用于扩展模板引擎的能力的系统。</li></ul><p>（以上引用自维基百科）</p><h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h2><p>我学习Django的时候都是看这本<a href="http://code.google.com/p/luaforwindows/downloads/list" target="_blank" rel="noopener">The Django Book</a>，很适合快速入门，强烈推荐。说明：以下都是基于Windows7，<a href="http://www.python.org/download/releases/2.7.6/" target="_blank" rel="noopener">Python 2.7.6</a>和<a href="https://www.djangoproject.com/download/" target="_blank" rel="noopener">Django 1.6.1</a>，安装的时候注意一下系统和框架的版本。Django请按照官网所给的方式安装，数据库则以MySQL为例，其他如有出入则参照上面的Django Book吧。</p><p>安装完成后打开python解释器，输入以下语句，若显示版本号则安装成功。</p><pre><code>&gt;&gt;&gt; import django&gt;&gt;&gt; django.VERSION</code></pre><h2 id="2-2-创建Django项目"><a href="#2-2-创建Django项目" class="headerlink" title="2.2 创建Django项目"></a>2.2 创建Django项目</h2><p>Django安装成功后，会自带一个django-admin.py的管理脚本（默认已添加到系统变量PATH中），如果控制台无法直接运行，可以到<code>python安装目录\Scripts</code>中找到这个文件。运行命令<code>django-admin.py startproject mysite</code>。这样会在你的当前目录下创建一个目录mysite。</p><p>startproject 命令创建的目录，包含4个文件：<strong>init</strong>.py（让Python把该目录当成一个开发包 ，即一组模块所需的文件。 这是一个空文件，一般你不需要修改它）、manage.py（一种命令行工具，允许你以多种方式与该 Django 项目进行交互）、settings.py（该Django项目的设置或配置）、urls.py（Django项目的URL设置，可视其为你的django网站的目录），</p><p>创建完成之后，在mysite目录下运行<code>python manage.py runserver</code>启动一个本地服务器，然后在浏览器中访问<code>http://127.0.0.1:8000/</code>，就可以看到新创建项目的初始页面了。</p><p>接下来一章将讲解Django最基本的URL配置。</p><h1 id="3-URL配置"><a href="#3-URL配置" class="headerlink" title="3 URL配置"></a>3 URL配置</h1><p>首先我们在项目文件夹中创建views.py文件，以备后用。</p><pre><code># views.py    from django.http import HttpResponsedef hello_view(request):    return HttpResponse(&quot;Hello world&quot;)</code></pre><p>我们创建了一个最简单最基本的视图，只有一个名为hello的函数，并返回一个HttpResponse对象。尽管我们实际在项目中不会这么写，但它足以支持Django基本的运行：在页面显示一句“Hello world”。接下来的URL配置才是重点。</p><p>URL配置就像是Django所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表。你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。例如，当用户访问/foo/时，调用视图函数foo_view()，这个视图函数存在于Python模块文件view.py中。编辑urls.py并输入以下内容。</p><pre><code>from django.conf.urls.defaults import *from mysite.views import hello_viewurlpatterns = patterns(&apos;&apos;,    (&apos;^hello/$&apos;, hello_view),)</code></pre><p>只要在浏览器中访问<code>http://127.0.0.1:8000/hello</code>就可以看到你的第一个页面了。这里面最关键的就是用正则表达式来匹配URL，上面的模式包含了一个尖号(^)和一个美元符号((<span>$</span>)，分别表示对字符串的头部和尾部进行匹配。例如“^hello/”，那么任何以/hello/开头的如“/hello/foo”的URL将会匹配。又比如，“^$”代表一个空串，匹配根URL。</p><p>大多数动态web应用程序，URL通常都包含有相关的参数，例如你点击某个帖子跳转到该帖子的详细页面（/list/123），这里可以使用d+来匹配1个以上的数字，用\d{1,2}来匹配一或两位数字，对应的配置如下：</p><pre><code>urlpatterns = patterns(&apos;&apos;,    (&apos;^$&apos;, index_view),    (&apos;^hello/$&apos;, hello_view),    (&apos;^list/\d{1,2}/$&apos;, list_view))</code></pre><p>当这样设置URL的时候，相应的view函数应该增加一个参数来接收，如上例所示的view函数形如<code>def list_view(request, id): requestId = int(id)</code>。</p><p>这就是URL的基本配置，结合其他正则表达式的表达方法基本可以满足日常所需，更详细的请参见<a href="http://djangobook.py3k.cn/2.0/chapter03/" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2013年秋季学期总结</title>
      <link href="/daily/2013-autumn-summary/"/>
      <url>/daily/2013-autumn-summary/</url>
      
        <content type="html"><![CDATA[<p>我们实验室正常来说应该是1月24日放假，但由于我之前暑假没有放假，所以调了一周加在寒假上得以提前一周放假。但由于在火车上实在是太无聊了，只好掏出电脑趴在床上写写学期总结。</p><a id="more"></a><h1 id="平淡无奇的研究生生活"><a href="#平淡无奇的研究生生活" class="headerlink" title="平淡无奇的研究生生活"></a>平淡无奇的研究生生活</h1><p>这学期开始真正进入了研究生生活。但实际谈起来却也是平淡无奇，每天基本上都是寝室、实验室、食堂三点一线，大部分时间都是泡在实验室（包括正常工作和晚上娱乐）。很多人问研究生不是要上课么？只能说研究生的课程比本科生还要坑爹。但是，我喜欢！这样意味着90%以上的时间都可以在实验室做真正有意义的事情而不是在课堂上浪费时间（除了一些经常要点名的课非去不可）。整个学期大概五六门课，只有矩阵论是真正需要突击复习一两周的；像中特、自然辩证法这种文科课是开卷考试而且考前给一个论述题，先写好大概1500字打印出来带进去抄就完事；剩下的就都是交篇综述性论文的类型。研究生嘛，主题还是放在跟着导师学姿势上，理论课什么的真心都是渣渣。</p><h1 id="Heatmap到Markboom的蜕变"><a href="#Heatmap到Markboom的蜕变" class="headerlink" title="Heatmap到Markboom的蜕变"></a>Heatmap到Markboom的蜕变</h1><p>可以说整个学期的工作全部投入到了这个项目的开发，也就是之前说的Heatmap 2.0 到3.0（后暂定新名称为Markboom）的升级。从当初最核心的在大图上做标记和在线聊天的功能，逐渐扩展外围成为一个真正的Web系统；从完成原型稿到UI设计稿和交互的优化，耗时将近4个月。直到我放假的前一天，还一直在调优，改bug和交接。最后向BOSS展示最新的产品成果，各种酷炫的UI效果一展示出来，大家都觉得长期的努力总算没有白费。</p><p>这个项目延续了暑期的工作，从国庆我放假回来后，开发团队算是定型下来：我、橘子、张曼、苏塔可（设计师）、赵老板（后台），其中前三个都是前端开发人员，可见这个项目的前端是有多重。在产品的原型稿出来之后，我主要负责前端核心功能的开发，诸如把大图控件从IIPImage换成OpenSeadragon，在大图控件上打标记，完善在线聊天的功能，还有后来老板提出的最新功能——用WebRTC实现在线视频聊天等等。在项目V0.1 release出来之后，我还研究了一下用grunt这个神器来优化整个前端项目。最后一个月UI设计稿出来后还挑起了一部分传统前端的改版工作。总之，这个学期虽然所有时间都投入到了一个项目上面，但是我的前端技术能力可谓是突飞猛进，也坚定了以后走前端的路线。</p><p>再具体说下项目中涉及的各个技术难点。</p><p>第一个是大图控件，原先2.0采用的是一个比较老的控件IIPImage，后来发现这个控件可扩展性比较差，对图像的预览也不够平滑，更关键的是对图片格式的支持相当挑剔而且图片的尺寸也过大，在经过一番调研之后决定换用<a href="http://openseadragon.github.io" target="_blank" rel="noopener">OpenSeadragon</a>和<a href="http://msdn.microsoft.com/zh-cn/library/cc645050.aspx" target="_blank" rel="noopener">Deep Zoom</a>格式的图片。事实证明这款控件非常简单易用，提供的丰富的API给我们的项目扩展带来了极大的方便。</p><p>第二个是在大图上打标记的功能。从只能打“点”这一种标记，扩展到了“矩形”“圆形”和“线”，还要可以变换颜色、尺寸和位置。网上找到的绘图控件虽然很炫，但要么需要收费，要么难以适应项目需求。后来实在没辙，我只好用HTML5的canvas怒写了一个jQuery插件——<a href="https://github.com/raytaylorlin/jQuery-markTools" target="_blank" rel="noopener">jQuery.markTools.js</a>——这也算是我第一个比较正式的开源repo。经过多番调优后，既能满足项目要求，又学了一个写jQuery插件的技能，实在是一举两得。这也意味着这个项目正式成为了一个HTML5产品。后来在做视觉优化的时候，我又尝试了用LESS把这个插件涉及到的CSS全部重构了一遍，代码瞬间变得干净清爽，也上手了LESS这个强大的工具。</p><p>第三个是老板提出的新需求，用WebRTC实现在线视频聊天。WebRTC名称源自网页实时通信，是一个支持网页浏览器进行实时语音对话或视频对话的API。这个东西是新型的，所以比较挑浏览器，不过由于我们第一期开发都是基于Chrome和Firefox，也没特别在意兼容性的问题。WebRTC的工作原理和API研究起来还挺复杂的，后来找了一圈决定选择<a href="http://simplewebrtc.com/" target="_blank" rel="noopener">SimpleWebRTC</a>这个简洁的封装库，再加上实验室进了一批摄像头，在线多人视频聊天就可以很简单地实现了。</p><p>最后一个是用grunt来优化前端项目。这东西真心好用，像JS、CSS代码检查、优化、压缩，图片压缩，基于require.js的模块合并等等就不用说了，只要配置好后就可以一键部署。后期做视觉优化的时候，还有个很强大的拼雪碧图的grunt插件，也是相当好用。这估计也是我们实验室首次尝试用grunt来部署前端项目，效果还是很拔群的。</p><p>总而言之，这学期除了维护个人的一些小项目之外，绝大部分时间都投入在实验室的大项目上，从各种前端控件，到传统的设计稿转换到网页的工作，再到整个前端项目的重构、优化和部署都参与了，在此期间前端技术方方面面都得到很扎实地锻炼。另外，Github也保持着慢速稳步增长。希望以后能够专精于前端技术的道路。</p><h1 id="本学期技术关键词（按重要度排序）"><a href="#本学期技术关键词（按重要度排序）" class="headerlink" title="本学期技术关键词（按重要度排序）"></a>本学期技术关键词（按重要度排序）</h1><p>jQuery插件、CSS、LESS、Grunt</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket.IO进阶</title>
      <link href="/tech/web/nodejs/socket-io-advanced/"/>
      <url>/tech/web/nodejs/socket-io-advanced/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博文<a href="/Tech/web/Nodejs/socket-io-tutorial">Socket.IO</a>中，我简要介绍了Socket.IO的基本使用方法并创建了一个简单的聊天室DEMO。本篇在入门篇的基础上，继续探讨Socket.IO的进阶用法。本篇将从配置、房间、事件等方面入手，介绍一些Socket.IO中实用的API和注意事项。</p><a id="more"></a><h1 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h1><p>Socket.IO提供了4个配置的API：io.configure, io.set, io.enable, io.disable。其中io.set对单项进行设置，io.enable和io.disable用于单项设置布尔型的配置。io.configure可以让你对不同的生产环境（如devlopment，test等等）配置不同的参数。以下定义了development和release两种环境下Socket.IO的不同配置：</p><pre><code>var io = require(&apos;socket.io&apos;).listen(80);io.configure(&apos;development&apos;, function(){    io.enable(&apos;browser client etag&apos;);    io.set(&apos;log level&apos;, 1);});io.configure(&apos;release&apos;, function(){    io.set(&apos;transports&apos;, [&apos;websocket&apos;]);});</code></pre><p>下面列举一些常用的配置项，具体配置参数参见<a href="https://github.com/LearnBoost/Socket.IO/wiki/Configuring-Socket.IO" target="_blank" rel="noopener">官方WIKI</a></p><ul><li>transports(默认<code>[&#39;websocket&#39;, &#39;htmlfile&#39;, &#39;xhr-polling&#39;, &#39;jsonp-polling&#39;]</code>)：一个包含通信方法类型的数组。Socket.IO支持多种实现在线即时通信的方式，如websocket、polling等等，该配置能让你自行选择备用的通信方式。</li><li>log level(默认<code>3</code>)：日志输出的最低级别，0为error，1为warn，2为info，3为debug，默认即输出所有类型的日志。</li><li>heartbeat interval(默认<code>25</code>秒)：心跳包发送间隔，客户端需要在此时间段之内向服务器发送一个心跳包才能保持通信。</li></ul><h1 id="2-房间"><a href="#2-房间" class="headerlink" title="2. 房间"></a>2. 房间</h1><p>房间是Socket.IO提供的一个非常好用的功能。房间相当于为指定的一些客户端提供了一个命名空间，所有在房间里的广播和通信都不会影响到房间以外的客户端。</p><p>在入门篇中，我们知道<code>socket.join(&#39;room name&#39;)</code>可用于客户端进入房间，<code>socket.leave(&#39;room name&#39;)</code>用于离开房间。当客户端进入一个房间之后，可以通过以下两种方式在房间里广播消息：</p><pre><code>//1. 向my room广播一个事件，提交者会被排除在外（即不会收到消息）io.sockets.on(&apos;connection&apos;, function (socket) {    //注意：和下面对比，这里是从客户端的角度来提交事件    socket.broadcast.to(&apos;my room&apos;).emit(&apos;event_name&apos;, data);}//2. 向another room广播一个事件，在此房间所有客户端都会收到消息//注意：和上面对比，这里是从服务器的角度来提交事件io.sockets.in(&apos;another room&apos;).emit(&apos;event_name&apos;, data);//向所有客户端广播io.sockets.emit(&apos;event_name&apos;, data);</code></pre><p>除了向房间广播消息之外，还可以通过以下API来获取房间的信息。</p><pre><code>//获取所有房间的信息//key为房间名，value为房间名对应的socket ID数组io.sockets.manager.rooms//获取particular room中的客户端，返回所有在此房间的socket实例io.sockets.clients(&apos;particular room&apos;)//通过socket.id来获取此socket进入的房间信息io.sockets.manager.roomClients[socket.id]</code></pre><h1 id="3-事件"><a href="#3-事件" class="headerlink" title="3. 事件"></a>3. 事件</h1><p>Socket.IO内置了一些默认事件，我们在设计事件的时候应该避开默认的事件名称，并灵活运用这些默认事件。</p><p>服务器端事件：</p><ul><li><code>io.sockets.on(&#39;connection&#39;, function(socket) {})</code>：socket连接成功之后触发，用于初始化</li><li><code>socket.on(&#39;message&#39;, function(message, callback) {})</code>：客户端通过<code>socket.send</code>来传送消息时触发此事件，message为传输的消息，callback是收到消息后要执行的回调</li><li><code>socket.on(&#39;anything&#39;, function(data) {})</code>：收到任何事件时触发</li><li><code>socket.on(&#39;disconnect&#39;, function() {})</code>：socket失去连接时触发（包括关闭浏览器，主动断开，掉线等任何断开连接的情况）</li></ul><p>客户端事件：</p><ul><li><code>connect</code>：连接成功</li><li><code>connecting</code>：正在连接</li><li><code>disconnect</code>：断开连接</li><li><code>connect_failed</code>：连接失败</li><li><code>error</code>：错误发生，并且无法被其他事件类型所处理</li><li><code>message</code>：同服务器端message事件</li><li><code>anything</code>：同服务器端anything事件</li><li><code>reconnect_failed</code>：重连失败</li><li><code>reconnect</code>：成功重连</li><li><code>reconnecting</code>：正在重连</li></ul><p>在这里要提下客户端socket发起连接时的顺序。当第一次连接时，事件触发顺序为：connecting-&gt;connect；当失去连接时，事件触发顺序为：disconnect-&gt;reconnecting（可能进行多次）-&gt;connecting-&gt;reconnect-&gt;connect。</p><h1 id="4-授权"><a href="#4-授权" class="headerlink" title="4. 授权"></a>4. 授权</h1><ul><li><p>向所有客户端广播：<code>socket.broadcast.emit(&#39;broadcast message&#39;);</code></p></li><li><p>进入一个房间（<strong>非常好用！相当于一个命名空间，可以对一个特定的房间广播而不影响在其他房间或不在房间的客户端</strong>）：<code>socket.join(&#39;your room name&#39;);</code></p></li><li><p>向一个房间广播消息（发送者<em>收不到</em>消息）：<code>socket.broadcast.to(&#39;your room name&#39;).emit(&#39;broadcast room message&#39;);</code></p></li><li><p>向一个房间广播消息（<em>包括发送者</em>都能收到消息）（<strong>这个API属于io.sockets</strong>）：<code>io.sockets.in(&#39;another room name&#39;).emit(&#39;broadcast room message&#39;);</code></p></li><li><p>强制使用WebSocket通信：（客户端）<code>socket.send(&#39;hi&#39;)</code>，（服务器）用<code>socket.on(&#39;message&#39;, function(data){})</code>来接收。</p></li></ul><p>Socket.IO的进阶用法介绍基本就到这里。个人感觉在日常使用的时候这些基本API已经够用了，这也体现了Socket.IO极其简洁易用的设计哲学。本文只是抛砖引玉，当在实际运用中遇到解决不了的问题时，再去查看官方详细的WIKI会比较好。</p><p>参考文献：<a href="https://github.com/learnboost/socket.io/wiki" target="_blank" rel="noopener">Socket.IO官方WIKI</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> Socket.IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket.IO入门</title>
      <link href="/tech/web/nodejs/socket-io-tutorial/"/>
      <url>/tech/web/nodejs/socket-io-tutorial/</url>
      
        <content type="html"><![CDATA[<p>暑假的时候Heatmap项目组需要对在线即时通信和协作进行技术探索，于是我开始研究Web在线聊天的实现方式。在充分对Comet技术进行了研究之后（详见我之前写的一篇<a href="/Tech/other/comet-intro/">Comet简介的博文</a>），在丁基友的提示之下决定尝试使用Socket.IO。一个是考虑以后HTML5做网络通信需要用到WebSocket现在可以提前接触一下，另外一个是这个东西的服务器端要用到Node.js，之前就对node很有兴趣正好借此提升下功力。</p><a id="more"></a><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>首先是Socket.IO的官方网站：<a href="http://socket.io" target="_blank" rel="noopener">http://socket.io</a></p><p>官网非常简洁，甚至没有API文档，只有一个简单的“How to use”可以参考。因为Socket.IO就跟官网一样简洁好用易上手。</p><p>那么Socket.IO到底是什么呢？Socket.IO是一个WebSocket库，包括了客户端的js和服务器端的nodejs，它的目标是构建可以在不同浏览器和移动设备上使用的实时应用。它会自动根据浏览器从WebSocket、AJAX长轮询、Iframe流等等各种方式中选择最佳的方式来实现网络实时应用，非常方便和人性化，而且支持的浏览器最低达IE5.5，应该可以满足绝大部分需求了。</p><h1 id="2-安装部署"><a href="#2-安装部署" class="headerlink" title="2. 安装部署"></a>2. 安装部署</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>首先安装非常简单，在node.js环境下只要一句：</p><pre><code>npm install socket.io</code></pre><h2 id="2-2-结合express来构建服务器"><a href="#2-2-结合express来构建服务器" class="headerlink" title="2.2 结合express来构建服务器"></a>2.2 结合express来构建服务器</h2><p>express是一个小巧的Node.js的Web应用框架，在构建HTTP服务器时经常使用到，所以直接以Socket.IO和express为例子来讲解。</p><pre><code>var express = require(&apos;express&apos;)    , app = express()    , server = require(&apos;http&apos;).createServer(app)    , io = require(&apos;socket.io&apos;).listen(server);server.listen(3001);</code></pre><p>若不使用express，请参考socket.io/#how-to-use</p><h1 id="3-基本使用方法"><a href="#3-基本使用方法" class="headerlink" title="3. 基本使用方法"></a>3. 基本使用方法</h1><p>主要分为服务器端和客户端两段代码，都非常简单。</p><p>Server（app.js）：</p><pre><code>//接上面的代码app.get(&apos;/&apos;, function (req, res) {    res.sendfile(__dirname + &apos;/index.html&apos;);});io.sockets.on(&apos;connection&apos;, function (socket) {    socket.emit(&apos;news&apos;, { hello: &apos;world&apos; });    socket.on(&apos;other event&apos;, function (data) {        console.log(data);    });});</code></pre><p>首先io.sockets.on函数接受字符串”connection”作为客户端发起连接的事件，当连接成功后，调用带有socket参数的回调函数。我们在使用socket.IO的时候，基本上都在这个回调函数里面处理用户的请求。</p><p>socket最关键的是emit和on两个函数，前者提交（发出）一个事件（事件名称用字符串表示），事件名称可以自定义，也有一些默认的事件名称，紧接着是一个对象，表示向该socket发送的内容；后者接收一个事件（事件名称用字符串表示），紧接着是收到事件调用的回调函数，其中data是收到的数据。</p><p>在上面的例子中，我们发送了news事件和收到了other event事件，那么客户端应该会有对应的接收和发送事件。没错，客户端代码和服务器正好相反，而且非常相似。</p><p>Client（client.js）</p><pre><code>&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var socket = io.connect(&apos;http://localhost&apos;);    socket.on(&apos;news&apos;, function (data) {        console.log(data);        socket.emit(&apos;other event&apos;, { my: &apos;data&apos; });    });&lt;/script&gt;</code></pre><p>有两点要注意的：<strong>socket.io.js路径要写对</strong>，这个js文件实际放在了服务器端的node_modules文件夹中，在请求这个文件时会重定向，因此不要诧异服务器端不存在这个文件但为什么还能正常工作。<strong>当然，你可以把服务器端的socket.io.js这个文件拷贝到本地，使它成为客户端的js文件，这样就不用每次都向Node服务器请求这个js文件，增强稳定性。</strong>第二点是要用<code>var socket = io.connect(&#39;网站地址或ip&#39;);</code>来获取socket对象，接着就可以使用socket来收发事件。关于事件处理，上面的代码表示收到“news”事件后，打印收到的数据，并向服务器发送“other event”事件。</p><p>注：内置默认的事件名例如“disconnect”表示客户端连接断开，“message”表示收到消息等等。自定义的事件名称，尽量不要跟Socket.IO中内置的默认事件名重名，以免造成不必要的麻烦。</p><h1 id="4-其他常用API"><a href="#4-其他常用API" class="headerlink" title="4. 其他常用API"></a>4. 其他常用API</h1><ul><li><p>向所有客户端广播：<code>socket.broadcast.emit(&#39;broadcast message&#39;);</code></p></li><li><p>进入一个房间（<strong>非常好用！相当于一个命名空间，可以对一个特定的房间广播而不影响在其他房间或不在房间的客户端</strong>）：<code>socket.join(&#39;your room name&#39;);</code></p></li><li><p>向一个房间广播消息（发送者<em>收不到</em>消息）：<code>socket.broadcast.to(&#39;your room name&#39;).emit(&#39;broadcast room message&#39;);</code></p></li><li><p>向一个房间广播消息（<em>包括发送者</em>都能收到消息）（<strong>这个API属于io.sockets</strong>）：<code>io.sockets.in(&#39;another room name&#39;).emit(&#39;broadcast room message&#39;);</code></p></li><li><p>强制使用WebSocket通信：（客户端）<code>socket.send(&#39;hi&#39;)</code>，（服务器）用<code>socket.on(&#39;message&#39;, function(data){})</code>来接收。</p></li></ul><h1 id="5-使用Socket-IO构建一个聊天室"><a href="#5-使用Socket-IO构建一个聊天室" class="headerlink" title="5. 使用Socket.IO构建一个聊天室"></a>5. 使用Socket.IO构建一个聊天室</h1><p>最后，我们通过一个简单的实例来结束本篇。用Socket.IO构建一个聊天室就是50行左右的代码的事情，实时聊天效果也非常好。以下贴出关键代码：</p><p>Server（socketChat.js）</p><pre><code>//一个客户端连接的字典，当一个客户端连接到服务器时，//会产生一个唯一的socketId，该字典保存socketId到用户信息（昵称等）的映射var connectionList = {};exports.startChat = function (io) {    io.sockets.on(&apos;connection&apos;, function (socket) {        //客户端连接时，保存socketId和用户名        var socketId = socket.id;        connectionList[socketId] = {            socket: socket        };        //用户进入聊天室事件，向其他在线用户广播其用户名        socket.on(&apos;join&apos;, function (data) {            socket.broadcast.emit(&apos;broadcast_join&apos;, data);            connectionList[socketId].username = data.username;        });        //用户离开聊天室事件，向其他在线用户广播其离开        socket.on(&apos;disconnect&apos;, function () {            if (connectionList[socketId].username) {                socket.broadcast.emit(&apos;broadcast_quit&apos;, {                    username: connectionList[socketId].username                });            }            delete connectionList[socketId];        });        //用户发言事件，向其他在线用户广播其发言内容        socket.on(&apos;say&apos;, function (data) {            socket.broadcast.emit(&apos;broadcast_say&apos;,{                username: connectionList[socketId].username,                text: data.text            });        });    })};</code></pre><p>Client(socketChatClient.js)</p><pre><code>var socket = io.connect(&apos;http://localhost&apos;);//连接服务器完毕后，马上提交一个“加入”事件，把自己的用户名告诉别人socket.emit(&apos;join&apos;, {    username: &apos;Username hehe&apos;});//收到加入聊天室广播后，显示消息socket.on(&apos;broadcast_join&apos;, function (data) {    console.log(data.username + &apos;加入了聊天室&apos;);});//收到离开聊天室广播后，显示消息socket.on(&apos;broadcast_quit&apos;, function(data) {    console.log(data.username + &apos;离开了聊天室&apos;);});//收到别人发送的消息后，显示消息socket.on(&apos;broadcast_say&apos;, function(data) {    console.log(data.username + &apos;说: &apos; + data.text);});//这里我们假设有一个文本框textarea和一个发送按钮.btn-send//使用jQuery绑定事件$(&apos;.btn-send&apos;).click(function(e) {    //获取文本框的文本    var text = $(&apos;textarea&apos;).val();    //提交一个say事件，服务器收到就会广播    socket.emit(&apos;say&apos;, {        username: &apos;Username hehe&apos;        text: text    });});</code></pre><p>这就是一个简单的聊天室DEMO，你可以根据你的需要随意扩展。Socket.IO基本上就是各种事件的提交和接收处理，思想非常简单。</p><p>参考文献：<a href="http://socket.io/#how-to-use" target="_blank" rel="noopener">Socket.IO How to use</a></p><p>参考文献：<a href="https://github.com/learnboost/socket.io/wiki" target="_blank" rel="noopener">Socket.IO官方WIKI</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> Socket.IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Grunt完成前端项目自动化构建工作</title>
      <link href="/tech/web/nodejs/grunt-tutorial/"/>
      <url>/tech/web/nodejs/grunt-tutorial/</url>
      
        <content type="html"><![CDATA[<p>Java世界里的Maven提供了强大的包依赖管理和构建生命周期管理。在JavaScript的世界里，随着Node.js的流行，JavaScript原生的构建工具已经成为可能。Grunt的生态系统在迅速的成长，目前已经有上百种插件发布在NPM上可供选择。同时，任何人都可以方便的发布自己的插件到NPM上供其他人使用。通过提供通用的接口以进行代码规范检验（Lint）、合并、压缩、测试及版本控制等任务，Grunt使入门门槛大大降低了。</p><a id="more"></a><h1 id="1-关于Grunt"><a href="#1-关于Grunt" class="headerlink" title="1. 关于Grunt"></a>1. 关于Grunt</h1><p>一言以蔽之，Grunt是一个基于Node.js的Javascript任务运行器。当你完成前端项目的开发之后，你需要将代码部署并发布，这时候你可能会重复地执行像压缩，编译，单元测试，代码检查，打包发布的任务。在一个项目过程中，我们不仅要专注于编写代码，还要处理这些重复而枯燥的琐事，实在是不能忍！于是我们需要一个自动化的构建工具，而Grunt就是这样一款可以让我们脱离苦海的自动化构建工具。</p><p>你所需要做的只是选择你需要的Grunt插件，配置好Grunt，然后把前端自动化构建的工作交给Grunt来完成即可。</p><p><a href="http://gruntjs.com/" target="_blank" rel="noopener">Grunt官方网站</a><br><a href="http://gruntjs.cn/" target="_blank" rel="noopener">Grunt中文网</a></p><h1 id="2-安装Grunt"><a href="#2-安装Grunt" class="headerlink" title="2. 安装Grunt"></a>2. 安装Grunt</h1><ol><li><p>Grunt和Grunt插件都是通过Node.js包管理器npm来安装和管理的。所以使用Grunt之前，需要先安装<a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a>，Grunt 0.4.x要求 0.8.0+的Node.js版本。</p></li><li><p>接下来是安装grunt-cli。<strong>如果你之前安装过旧版本（0.3.x）的Grunt，需要先<code>npm uninstall grunt -g</code>来卸载旧版本的Grunt。</strong> 执行以下语句安装全局的grunt-cli。</p></li></ol><pre><code>npm install grunt-cli -g</code></pre><ol start="3"><li>安装grunt-init（可选）。grunt-init是个脚手架工具，它可以帮你完成项目的自动化创建，包括项目的目录结构，每个目录里的文件等。实际项目中往往目录结构已经搭建好，只需要直接配置并使用Grunt，限于篇幅本文就不展开讨论grunt-init的使用方法，有兴趣可以到<a href="http://gruntjs.com/project-scaffolding" target="_blank" rel="noopener">这里</a>了解更多。</li></ol><h1 id="3-准备新建Grunt项目"><a href="#3-准备新建Grunt项目" class="headerlink" title="3. 准备新建Grunt项目"></a>3. 准备新建Grunt项目</h1><p>一个标准的配置过程只需要给项目添加两个文件：package.json和Gruntfile.js。</p><p>package.json: 该文件用于保存作为npm模块发布的项目元数据。需要在该文件的devDependencies 中列出项目所依赖的Grunt版本和Grunt插件。</p><p>Gruntfile: 该文件一般命名为Gruntfile.js或Gruntfile.coffee，用于配置或定义任务和加载Grunt插件。</p><p>下面是一个package.json的示例，一般我们就在这上面的基础上修改或添加新的插件依赖即可。</p><pre><code>{    &quot;name&quot;: &quot;my-project-name&quot;,    &quot;version&quot;: &quot;0.1.0&quot;,    &quot;devDependencies&quot;: {        &quot;grunt&quot;: &quot;~0.4.1&quot;,        &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;,        &quot;grunt-contrib-jshint&quot;: &quot;~0.6.3&quot;,        &quot;grunt-contrib-uglify&quot;: &quot;~0.2.2&quot;    }}</code></pre><h1 id="4-选择并安装Grunt插件"><a href="#4-选择并安装Grunt插件" class="headerlink" title="4. 选择并安装Grunt插件"></a>4. 选择并安装Grunt插件</h1><p>Grunt的任务其实就是各种插件的组合使用，你需要的构建功能基本上官网都已经提供了相应的插件，详情可参见<a href="http://gruntjs.com/plugins" target="_blank" rel="noopener">插件列表</a>。下面列举几款常用的插件：</p><ul><li>grunt-contrib-clean: 用于清理指定文件（夹），一般是构建之前或之后进行</li><li>grunt-contrib-concat: 连接源文件，减少HTTP请求</li><li>grunt-contrib-copy: 用于复制文件或目录</li><li>grunt-contrib-jshint: JS代码质量检查工具，类似jsLint</li><li>grunt-contrib-watch: 监视磁盘文件，一旦更改就会重新运行指定的任务，例如使http服务器重新加载源文件</li><li>grunt-contrib-uglify: 压缩JS源文件，提高运行时性能</li><li>grunt-contrib-mincss: 用于CSS压缩</li><li>grunt-contrib-csslint: CSS代码质量检查工具</li><li>grunt-contrib-htmlmin: 用于HTML压缩</li><li>grunt-contrib-imagemin: 用于压缩PNG、JPEG、GIF等图像<br>……</li></ul><p>每个Grunt插件都是一个Node.js模块，都可以用<code>npm install &lt;module&gt; --save-dev</code>命令来安装（使用–save-dev参数可以在安装模块的同时将依赖关系添加到package.json中的devDependencies）。</p><h1 id="5-配置Gruntfile"><a href="#5-配置Gruntfile" class="headerlink" title="5. 配置Gruntfile"></a>5. 配置Gruntfile</h1><p>安装完插件后，需要配置Gruntfile来添加你所需要的自动化任务。Gruntfile一般由这几部分组成：“wrapper”函数，项目和任务配置，要加载的插件，自定义任务。Gruntfile文件的结构最后应该是类似下面这样四个部分：</p><pre><code>// 1. wrapper函数，你的所有Grunt代码都必须写在这个函数里面module.exports = function(grunt) {    // 2. 项目和任务配置    grunt.initConfig({        pkg: grunt.file.readJSON(&apos;package.json&apos;),        concat: {            options: {                //定义一个用于插入合并输出文件之间的字符                separator: &apos;\n&apos;            },            dist: {                //用于连接的文件                src: [&apos;src/*.js&apos;],                //返回的JS文件位置                dest: &apos;release/&lt;%= pkg.name %&gt;.js&apos;            }        },        jshint: {            //定义用于检测的文件            files: [&apos;gruntfile.js&apos;, &apos;src/*.js&apos;]        },        uglify: {            options: {                //生成一个banner注释并插入到输出文件的顶部                banner: &apos;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;dd-mm-yyyy&quot;) %&gt; */\n&apos;            },            dist: {                files: {                    &apos;release/&lt;%= pkg.name %&gt;.min.js&apos;: [&apos;&lt;%= concat.dist.dest %&gt;&apos;]                }            }        }    });    // 3. 加载各种任务所需的插件    grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;);    grunt.loadNpmTasks(&apos;grunt-contrib-jshint&apos;);    grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);    // 4. 自定义任务    grunt.registerTask(&apos;default&apos;, [&apos;jshint&apos;, &apos;concat&apos;, &apos;uglify&apos;]);    grunt.registerTask(&apos;concat&apos;, [concat&apos;, &apos;uglify&apos;]);};</code></pre><p>上面的代码最后自定义了两个任务，当执行<code>grunt default</code>的时候，Grunt就会按照配置依次检查js代码，连接代码，并压缩js，同理当执行<code>grunt concat</code>的时候，只会执行最后两个步骤。</p><p>最后总结一下，Grunt的使用流程基本上就是：下载需要的插件，配置项目和插件，最后自定义你需要的任务执行各种插件功能。本文只是抛砖引玉，至于更详细的用法，参见比较详细的中文教程<a href="http://gruntjs.cn/getting-started/" target="_blank" rel="noopener">Grunt入门指南</a>。</p><p>参考文献：<a href="http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201307/216460.shtml" target="_blank" rel="noopener">Grunt打造前端自动化工作流</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> Grunt </tag>
            
            <tag> 自动化构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改文件后Node.js应用自动重新启动</title>
      <link href="/tech/web/nodejs/nodejs-restart-on-file-change/"/>
      <url>/tech/web/nodejs/nodejs-restart-on-file-change/</url>
      
        <content type="html"><![CDATA[<p>在开发或调试Node.js应用程序的时候，当你修改js文件后，总是要按下CTRL+C终止程序，然后再重新启动，即使是修改一点小小的参数，也总是要不断地重复这几个很烦人的操作。有没有办法做到当文件修改之后，Node.js自动重新启动（或重新加载文件）以节省时间呢？一开始我是想到用grunt的watch模块来监控文件变化，但后来在网上一查，原来我们想到的，别人早已想到，并且已经做得很好。<a href="https://github.com/isaacs/node-supervisor" target="_blank" rel="noopener">Node Supervisor</a>正是这样一个可以实现这种需求的Node.js模块。</p><a id="more"></a><p>根据Github上的说明，Node Supervisor原本是用于服务器上Node.js应用崩溃的时候，自己重新启动。当然它也可以监控你的项目的js（或CoffeeScript）文件变化，进而重启来方便我们调试应用程序。</p><p>安装方法（以全局模块安装）：</p><pre><code>npm install supervisor -g</code></pre><p>假设你的Node.js程序主入口是app.js，那么只需要执行以下命令，即可开始监控文件变化。</p><pre><code>supervisor app.js</code></pre><p>Supervisor还支持多种参数，列举如下：</p><pre><code>//要监控的文件夹或js文件，默认为&apos;.&apos;-w|--watch &lt;watchItems&gt;//要忽略监控的文件夹或js文件  -i|--ignore &lt;ignoreItems&gt;//监控文件变化的时间间隔（周期），默认为Node.js内置的时间-p|--poll-interval &lt;milliseconds&gt;//要监控的文件扩展名，默认为&apos;node|js&apos;-e|--extensions &lt;extensions&gt;//要执行的主应用程序，默认为&apos;node&apos;-x|--exec &lt;executable&gt;//开启debug模式（用--debug flag来启动node）--debug//安静模式，不显示DEBUG信息-q|--quiet</code></pre><p>例子：</p><pre><code>supervisor myapp.jssupervisor -w py_scripts -e &apos;py&apos; -x python myapp.pysupervisor -w lib, server.js, config.js, server.js</code></pre><p>实现同样功能的类似产品还有<a href="https://github.com/DTrejo/run.js" target="_blank" rel="noopener">Run.js</a>和<a href="https://github.com/remy/nodemon" target="_blank" rel="noopener">Nodeman</a>，这两个我都没用过。但是从文档上来看，前者和Supervisor一样都是极简的5分钟就可以上手的那种，功能比Supervisor稍弱；后者的feature比较多，对应的文档就特别长，估计要研究透也得至少半个小时。选择哪一个，全看项目需求和个人喜好。</p><p>参考文献：<a href="http://www.hacksparrow.com/node-js-restart-on-file-change.html" target="_blank" rel="noopener">Node.js Restart on File Change</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git指南（2）——处理历史与错误</title>
      <link href="/tech/tool/git/git-tutorial-2/"/>
      <url>/tech/tool/git/git-tutorial-2/</url>
      
        <content type="html"><![CDATA[<p>上一篇介绍了Git的一些最常用的基本命令，如果只是日常的提交，那些命令已经够用了。但是平时写代码的时候总难免会需要查看你以前写过的代码，或者当你进行了一些误操作的时候，总会希望可以安全地撤销你的操作。本篇将介绍如何处理历史记录，在各个版本之间跳转（签出），以及如何撤销你的之前的提交、更改等操作。</p><a id="more"></a><h1 id="1-处理历史记录"><a href="#1-处理历史记录" class="headerlink" title="1. 处理历史记录"></a>1. 处理历史记录</h1><h2 id="1-1-查看"><a href="#1-1-查看" class="headerlink" title="1.1 查看"></a>1.1 查看</h2><p>以下命令用来取得项目之前所有提交的列表</p><pre><code>git log</code></pre><p>当然，可以用很多参数来精确控制历史记录的显示方式，这里推荐一种格式输出（参数意义自行查阅）</p><pre><code>git log --pretty=format:&quot;%h %ad | %s%d [%an]&quot; --graph --date=short# 输出例子：# d14ff74 2013-09-12 | First Commit (HEAD, master) [水月轻枫]</code></pre><p>但是每次都要输入这一长串命令太不现实了，所幸Git提供别名功能，可以简化这个命令。</p><h2 id="1-2-别名（alias）"><a href="#1-2-别名（alias）" class="headerlink" title="1.2 别名（alias）"></a>1.2 别名（alias）</h2><p><code>git status</code>，<code>git add</code>，<code>git commit</code>和<code>git checkout</code>这些命令太常用了，包括上面提到那个格式化的<code>git log</code>，缩写一下会大大提高效率。</p><p>要使用别名，把下面的内容加到你$HOME目录下的.gitconfig文件即可（Windows下的$HOME目录一般是“C:\Users\你的Windows用户名\”）。</p><pre><code>[alias]    co = checkout    cm = commit    st = status    br = branch    hist = log --pretty=format:\&quot;%h %ad | %s%d [%an]\&quot; --graph --date=short</code></pre><p>接下来，你就可以使用<code>git cm</code>来代替<code>git commit</code>，使用<code>git hist</code>来输出格式化的历史记录等等，方便吧。</p><h2 id="1-3-获取旧版本"><a href="#1-3-获取旧版本" class="headerlink" title="1.3 获取旧版本"></a>1.3 获取旧版本</h2><p>如果你已经配置了上述的查看历史命令的别名<code>git hist</code>，就可以很方便地使用这个命令来查看历史提交的列表。注意到每个提交的第一项都是一串简写的SHA1 hash值（完整的hash值可以说是一次提交的唯一标识），可以用以下命令来获取旧版本</p><pre><code># 此处&lt;hash&gt;只需要前几个字符即可，如d14ff74git checkout &lt;hash&gt;</code></pre><p>成功运行之后你的repo应该就处于对应的旧版本了。如果你需要返回主分支的最新版本，可以运行以下命令</p><pre><code>git checkout master</code></pre><p>“master”是主分支默认的名字，如果checkout的是一个分支的名字，就会得到这个分支的最新版本。</p><h2 id="1-4-给版本打标签"><a href="#1-4-给版本打标签" class="headerlink" title="1.4 给版本打标签"></a>1.4 给版本打标签</h2><p>使用以下命令</p><pre><code>git tag v1</code></pre><p>可以给当前版本打上标签“v1”。如果需要给过去的版本打标签，应先<code>git checkout</code>出以前的版本再打标签。</p><p><em>小贴士：使用<code>git checkout v1^</code>可以签出v1的<strong>上一个</strong>版本，符号“^”表示“上一个版本”</em></p><p>使用以下命令可以查看有哪些可用的标签</p><pre><code>git tag</code></pre><p>使用<code>git hist master --all</code>可以在历史记录中看到标签信息。</p><h1 id="2-处理错误"><a href="#2-处理错误" class="headerlink" title="2. 处理错误"></a>2. 处理错误</h1><h2 id="2-1-在提交之前撤销更改"><a href="#2-1-在提交之前撤销更改" class="headerlink" title="2.1 在提交之前撤销更改"></a>2.1 在提交之前撤销更改</h2><p>这里假定一个场景：你刚提交了一个新版本，然后对你的文件hello.py做了一些更改，随后你对刚才的更改不满意了，想将其恢复到提交时状态。这里分为两种情况：</p><ul><li><p>本地修改（你还没用add或stage跟踪修改）：用<code>git checkout hello.py</code>即可恢复该文件，可见git checkout可以还原特定的文件。</p></li><li><p>已跟踪修改：用<code>git reset HEAD hello.py</code>把跟踪区重置到和HEAD版本一致的状态。注意：<strong>reset命令（默认）不修改当前工作目录，所以工作目录里依旧会保留你的更改。</strong>可以用git checkout命令来撤销工作目录中你不想要的修改。<strong>这里需要你头脑很清晰地分辨跟踪区和工作目录的区别。</strong></p></li></ul><h2 id="2-2-撤销已提交的更改"><a href="#2-2-撤销已提交的更改" class="headerlink" title="2.2 撤销已提交的更改"></a>2.2 撤销已提交的更改</h2><p>有时你会突然意识到你刚刚提交的修改有问题，希望撤销这次提交。有好几种方法可以做到这一点，其中一种方法就是，就是再提交一次撤销了之前修改的新修改。</p><pre><code># --no-edit选项指定不打开编辑器# 只要把HEAD换成其他hash值就可以恢复对应的版本git revert HEAD --no-edit</code></pre><p>执行之后用git hist看一下记录，会发现有一次新的提交，这次提交覆盖了上一次的提交的内容。</p><p>上面这种方法虽然可以撤销更改，但是错误提交还是出现在git log里，这对于有强迫症的程序猿来说是多么不能忍！下面这个方法可以让这次错误的提交看起来像是完全没发生。</p><p>假定git hist输出以下内容</p><pre><code># Oops是错误提交，Revert是用revert命令撤销的提交，注意到错误提交之前的版本带有v1标签$ git hist# 输出：# ee1237e 2011-09-20 | Revert &quot;Oops, we didn&apos;t want this commit&quot; (HEAD, master) [Jim Weirich]# 8021312 2011-09-20 | Oops, we didn&apos;t want this commit [Jim Weirich]# 1b303b2 2011-09-20 | Added a comment (v1) [Jim Weirich]</code></pre><p>首先用<code>git tag oops</code>标记最后的提交，然后</p><pre><code># --hard表示将当前工作目录更新到和新分支的最新版本一致git reset --hard v1</code></pre><p>这时再查看历史记录，你会发现错误提交（Oops…）和撤销提交（Revert…）已经“消失”了。当然，<strong>错误的提交并没有消失，它们还在库里。只是它们现在不会列在主分支里了，如果使用<code>git hist --all</code>还是可以看到记录。</strong></p><p>最后，不要忘了删除oops那个标签，以便<strong>它所引用的提交可以被垃圾收集机制清理掉</strong></p><pre><code>git tag -d oops# 现在你用git hist --all也看不到了</code></pre><h2 id="2-3-修正提交"><a href="#2-3-修正提交" class="headerlink" title="2.3 修正提交"></a>2.3 修正提交</h2><p>假设你刚刚用<code>git commit -m &quot;No comment&quot;</code>做了一次提交，然后马上意识到你在某个地方少添加了一句注释，但你确实不想为了这点屁大的事再做一次单独的提交，因此可以使用“修正提交”的方法。先加入你的注释，然后</p><pre><code># --amend允许你修正最近一次提交# 不要忘记提交前git stage一下git commit --amend -m &quot;Now add a comment&quot;</code></pre><p>再查看一下历史记录，你会发现“No comment”那次提交不见了，取而代之的是“Now add a comment”这次提交。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git指南（1）——安装与基本用法</title>
      <link href="/tech/tool/git/git-tutorial-1/"/>
      <url>/tech/tool/git/git-tutorial-1/</url>
      
        <content type="html"><![CDATA[<p>现在很多开发团队，包括我所在实验室，使用的版本控制系统都是SVN。Git作为一个新兴的快速的分布式版本控制系统，却很少有人知道或使用。我使用Git的时间不长，平时使用的命令也就那么几个，但深知Git是一个前途无量的东西，因此决定尝试着坚持使用并让更多的人知道它。</p><p>之前从来没有对Git进行过系统的学习，只了解其中的一点皮毛原理和使用方式。这次正好借这个机会完整地学习一下，并把本系列作为一个教程或学习笔记。如果你对Git有兴趣，这个系列可以作为入门的参考指南。（注：本系列均以Windows版本为例，Linux或Mac下的命令可能有点不同，请自行查阅；另外，本系列所讲的都是Git的命令行，如果你使用小乌龟客户端GitTortoise，那么只需要动几下鼠标就可以完成操作）</p><a id="more"></a><h1 id="1-为什么使用Git"><a href="#1-为什么使用Git" class="headerlink" title="1. 为什么使用Git"></a>1. 为什么使用Git</h1><p>关于Git的优缺点，与SVN的对比网上的资料有非常多，这里只列举几点比较重要的。</p><ul><li>分布式版本控制，文件变更的历史记录不再存在一个集中服务器，如果服务器故障，或者没有网络，几乎所有操作都可以在本地执行，在任何地方都可以愉快地提交更改。</li><li>版本的分支（branch）和合并（merge）十分方便。</li><li>有一个全世界最大的开源社区——github，上面可以看到各种优秀的各种语言的代码，并且越来越多的项目由github托管。</li></ul><h1 id="2-参考材料"><a href="#2-参考材料" class="headerlink" title="2. 参考材料"></a>2. 参考材料</h1><ul><li><a href="http://iissnan.com/progit/index.html" target="_blank" rel="noopener">Pro Git中文版</a></li><li>一个极其简洁明了的Git教程网站<a href="http://gitimmersion.com/" target="_blank" rel="noopener">Git Immersion</a></li><li><a href="http://gitbook.liuhui998.com/index.html" target="_blank" rel="noopener">Git Community Book 中文版</a></li></ul><h1 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h1><p>安装Git Windows客户端（命令行界面）：<a href="http://msysgit.github.io/" target="_blank" rel="noopener">msysgit</a></p><p>用SVN的人一定对小乌龟客户端很熟悉，Git也有对应的版本：<a href="https://code.google.com/p/tortoisegit/" target="_blank" rel="noopener">GitTortoise</a></p><p>Linux或Mac用户请自寻谷歌安装方法。</p><h1 id="4-基本用法"><a href="#4-基本用法" class="headerlink" title="4. 基本用法"></a>4. 基本用法</h1><h2 id="3-1-配置"><a href="#3-1-配置" class="headerlink" title="3.1 配置"></a>3.1 配置</h2><p>在使用Git之前，需要打开命令行客户端</p><p>1.设置名字和信箱</p><pre><code>git config --global user.name &quot;你的名字&quot;git config --global user.email &quot;your_email@whatever.com&quot;</code></pre><p>2.设置换行符参数</p><pre><code># 提交时转换为LF，检出时转换为CRLFgit config --global core.autocrlf true# 拒绝提交包含混合换行符的文件git config --global core.safecrlf true</code></pre><h2 id="3-2-流程"><a href="#3-2-流程" class="headerlink" title="3.2 流程"></a>3.2 流程</h2><p>在你的工程文件夹下，执行以下命令创建代码仓库（Repository，就是在网上经常看到的repo）</p><pre><code>git init</code></pre><p>假设你的工程有一个index.html文件，以下命令将其添加到跟踪改动状态（stage）</p><pre><code>git add index.html# git add . 可以跟踪所有文件# 此处也可以使用git stage来跟踪改动</code></pre><p>查看状态</p><pre><code>git status# 此时你应该看到输出提示add了index.html，其他状态还有modified（修改）等等</code></pre><p>查看与上一次提交的差异（具体参考<a href="http://gitbook.liuhui998.com/3_5.html" target="_blank" rel="noopener">这里</a>）</p><pre><code>git diff# 加上--cached参数，git diff会显示当前你所有已跟踪的修改git diff branch-name    # 查看当前工作目录与指定分支的差别</code></pre><p>然后提交</p><pre><code># -a表示跟踪所有文件的改动（相当于先做了一次git add .，再commit），-m 后面跟着提交的说明git commit -a -m &quot;First Commit&quot;</code></pre><h2 id="3-3-需要特别注意的问题"><a href="#3-3-需要特别注意的问题" class="headerlink" title="3.3 需要特别注意的问题"></a>3.3 需要特别注意的问题</h2><p><strong>每一次你对文件做了改动（包括删除），都需要使用<code>git add</code>或<code>git stage</code>来跟踪改动，只有被跟踪改动了的文件才可以使用<code>git commit</code>提交。</strong></p><p>增加跟踪改动（stage）主要有两个好处，一个是分批、分阶段递交，一个是进行快照，便于回退。</p><p>1.分批提交：比如，你修改了a.py, b.py, c.py三个文件，其中a.py和c.py 是功能1的相关修改，b.py属于功能2的相关修改。那么你就可以采用以下方式分批提交。</p><pre><code>git stage a.py c.pygit commit -m &quot;function 1&quot;git stage b.pygit commit -m &quot;function 2&quot;</code></pre><p>2.分阶段提交<br>比如你修改了a.py，然后<code>git stage a.py</code>，相当于对当前的a.py 做了一个快照，然后又做了一些修改，这时候，如果直接采用<code>git commit</code>递交，则只会对第一次的快照进行递交，当前内容还保存在工作区。需要再做一次 <code>git stage</code>，才能提交。</p><p>3.文件快照，便于回退<br>当文件加入了stage区以后，如果要从stage区删除，则使用 reset，此时工作区的文件不做任何修改，比如：</p><pre><code># 这个命令就是git stage a.py的反操作git reset a.py</code></pre><p>当文件加入了 stage 区以后，后来又做了一些修改，这时发现后面的修改有问题，想回退到stage的状态，使用checkout命令</p><pre><code>git checkout a.py</code></pre><p>4.忽略某些文件</p><p>一般一个项目总会有些文件无需纳入Git的管理，比如一些自动生成的日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为<code>.gitignore</code>的文件，列出要忽略的文件模式。下面是一个例子：</p><pre><code># 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO# 忽略 build/ 目录下的所有文件build/# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt</code></pre><p>本篇就先讲到这里，下一篇将会讲Git的历史操作。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2013年春季学期总结</title>
      <link href="/daily/2013-spring-summary/"/>
      <url>/daily/2013-spring-summary/</url>
      
        <content type="html"><![CDATA[<p>再过几天就要开始研究生的新学期了，趁着还有点时间赶紧把大四下学期回顾一下。话说回来我是把暑假也算入这个学期里头了，因此现在来回顾还不算晚。都说大四的毕业生除了混毕业论文之外，过得是最清闲最快乐的，但现在看来，这学期恰恰是我本科生涯最长的一个学期——由于暑期做某个项目而调假，我从二月初到八月底超过半年没有回过家，真心是破纪录了。这学期远远没有普遍大四毕业生过得那么潇洒，其中也发生了不少事情，现在就来把一些重要的事梳理一遍。</p><a id="more"></a><h1 id="还是关于实验室"><a href="#还是关于实验室" class="headerlink" title="还是关于实验室"></a>还是关于实验室</h1><p>过完了短暂的两周的寒假，我们实验室在约定好的二月份全员到齐，开始新学期的工作。虽然是大四下学期，不过既然是保研进来的，我也得开始按正式研究生的时间开始了周一到周五“朝九晚五”，周末休息的“上班”生活了。关于“上班”时间实验室还是比较人道的，只要求早上九点准时到，其他时间都不做要求，中午休息的时间亦有了一定保障。当然，“上班”则意味着规律的生活，以及更少的自由时间，还有偶尔的晚上或周末加班，这也算是提前适应未来真正的上班生活吧。</p><h1 id="首个正式Android项目——欢喜淘"><a href="#首个正式Android项目——欢喜淘" class="headerlink" title="首个正式Android项目——欢喜淘"></a>首个正式Android项目——欢喜淘</h1><p>到二月底的时候，向来Idea超多的老师某一天突然提出了开发一个针对学生的校园二手市场APP的想法，并展开了一系列调研。从最开始提出这个产品的概念到最后确定产品的定义，也就花了不到两周的时间，期间开了N次会议讨论诸如“学生到底需要什么样的二手市场”“能吸引学生使用的亮点”之类的问题。最后确定下来的这个APP叫做“欢喜淘”，大概就是主要面向本校的学生，特别是我们这群即将毕业的大四学生，在毕业季的时候会有很多东西要甩卖，这个时候推出肯定能吸引很多学生使用，让学生淘得欢喜。再加上一个所谓的创新亮点——赠送抽奖功能——可以通过使用这个APP来赠送那些不想要又不舍得丢的东西，其他人可以向这件赠送品投入金币（下注），最后就开奖以决定谁可以获得这件赠送品。通过这种游戏的互动，使用户参与度更高。</p><p>作为一个专注于技术开发的人，我对产品本身没有太大的兴趣，即使它的潜在用户是我这种毕业生。既然老师如此上心，我只要乖乖照着干就是了。我们的开发团队有一位靠谱的产品经理LYY学长，一位靠谱的UI设计师学姐，一位靠谱的技术大神松老师，再加上还是Android开发新手的我，阵容也还不错。像这种普通的APP，编码人员维持在一两个的水平是比较稳妥的。</p><p>这个项目算是我第一次接触真正的Android APP应用开发（以前做的那些都不能算是实际意义上的APP），一开始摸索还是有一定难度的。为了搞这个还特地换了个Android的手机。从开发测试环境的熟悉，到各种XML布局的掌握，再到基本的Java后台看，花了大概两周时间去适应。中间还好几次遇到技术瓶颈，比如菜单下拉刷新啊，侧滑栏菜单什么的，虽然网上有很多范例但实际用起来就是很不顺手，项目越做就越觉得Android开发让人蛋疼（以前两度接触Android开发到现在感觉依旧不变）。所幸有技术大神松老师罩着，项目的进展还算比较顺利。产品经历了几轮的迭代，实际工期总是要比预期长，在经历了连续一个多月没日没夜的加班和赶工之后，产品总算达到可以发布初版的状态。</p><p>本来这个产品预定是要在毕业季大约六月份的时候推出，但后来出于某些原因，为了不让产品在刚推出的时候就夭折，老师选择了不推出产品，这个项目也就不了了之了。反正我对这个产品兴趣也不大，结果如何我也无所谓，倒是这期间整套Android的基本开发都被啃下来了，也算是不小的收获。总之，这蛋疼的Android我已经扯得够多了，也不想多说什么，现在APP的开发者实在是泛滥，除了蛋疼还是蛋疼。</p><h1 id="“发现杯”软件大奖赛"><a href="#“发现杯”软件大奖赛" class="headerlink" title="“发现杯”软件大奖赛"></a>“发现杯”软件大奖赛</h1><p>大概四月初的时候，在我忙开发欢喜淘忙得焦头烂额的时候，突然接到达内公司的一个通知——我当选了“发现杯”软件大奖赛的全国十强选手，让我赴杭州一星期去参加决赛，而且全国十强已经有了保底的奖金，路费各种报销，若能进总决赛还会有更大的奖励。我之前做的模仿Doodle Jump的挫得一逼的游戏Suwako Jump居然也能进决赛，再加上达内这个培训机构名气不是很大，一度让我对这个比赛是否是骗局产生了顾虑。由于手头有欢喜淘的任务，我一开始也不太想去，后来和老师商量之后，老师同意放我去参加这个比赛，毕竟是一次长见识的机会，并叮嘱我做好万全的心理准备，出门小心。于是老夫便买了赴杭的软卧，独自上路。</p><p>第一次独自出远门去一个陌生的城市，心里还是比较忐忑的。达内似乎为了拿出诚意和打消我们选手的疑虑，带队老师也是一路给我们各种报销和解决各种生活上的难题，各个选手之间相处还是比较和谐的。从第二天开始老师就把我们拉到杭州下沙开发区一座新盖好的大楼做封闭培训。第一轮选手轮流展示各自的作品之后，大家对彼此也就知根知底了。11组选手均来自全国各地，一本二本三本乃至大专各个阶层都有，年级多集中于大四到毕业一年。看过其他人的作品之后，我才发现我做的那款破游戏那生动活泼的场面还算是比较有吸引力的。说到底这个比赛因为是第一届，提交的作品确实是比较水（这个主办方后来也承认了），不是我夸张，只要提交一个可以运行的不崩溃的Android程序，基本就可以进决赛拿到至少5Q的奖金。所以说我们第一届算是幸运儿，后面这比赛估计就不是那么水了。</p><p>为期七天的决赛大概分两个阶段，前两天在11组中选出了6组参加最后的总决赛，剩下的人就和前6名的选手组为一队，给他们提供帮助。后面剩余的时间就是前6名不断地改善作品的UI界面，锻炼演讲能力，做PPT，因为总决赛的时候是前6名在各个老总和杭州的媒体前展示作品。具体的准备过程在此就不赘述了，以后有机会的话我再考虑放出那一段时间的日记记录。总而言之，这七天啥都没搞，就锻炼了presentation的能力，还有认识了一帮人。整个过程我都显得比较仙脚，因为打一开始就对这个比赛有潜在的抵触心理，尤其是得知可以进入总决赛后，就更加地不上心。别人都是拼了老命在练习和修改，我还有闲心在外地继续做欢喜淘的项目。</p><p>最后的结果也还算是比较满意，拿了第三名。这里不得不提一点就是决赛的前一晚我们大概排练到11点左右，带队老师给我们每人发了一份协议，我一看就知道尼玛达内这一手果然非常狠，比赛最后拿奖需要签一份协议。协议的具体内容这里不便透露，后来也是花了好大的功夫才把这个事搞定，如果有兴趣的话可以私底下找我了解。</p><h1 id="毕业课设与论文"><a href="#毕业课设与论文" class="headerlink" title="毕业课设与论文"></a>毕业课设与论文</h1><p>从杭州回来后本应该开始准备毕业设计的事，但是老师一直让我参与很多杂项目所以基本上没怎么动。毕设这个项目本应由我和另一个学长共同完成的，由于各种杂事缠身所以我也没怎么参与。6月8日答辩，老师要求我们6月1日才开始写论文，记得我当时答辩完发了一条状态“七天之内论文、开题报告、翻译、日记、答辩一条龙= =|”，这就是本科终极一战的实况。当然论文要求1W5字最后飚了2W4也是蛮爽的，论文的题目还是很老套很装逼的套路，叫《在线聚类分析及可视化系统的设计与实现》，说白了就是一个吓唬行外人的战五渣。。。</p><h1 id="毕业季"><a href="#毕业季" class="headerlink" title="毕业季"></a>毕业季</h1><p>答辩完后实验室给放了两周的毕业季假，一学期紧绷的神经总算得以放松。接下来就是各种休闲活动啊班级聚餐啊晚会啊。比较值得一提的有一场说走就走的旅行——去恩施班级旅行，和室友天天打求生之路三国杀愉快地度过最后的本科时光，还有经历华科的传统毕业泼水节等等。其他的，倒也没太多可讲。</p><h1 id="贯穿整个学期的坑——Heatmap项目"><a href="#贯穿整个学期的坑——Heatmap项目" class="headerlink" title="贯穿整个学期的坑——Heatmap项目"></a>贯穿整个学期的坑——Heatmap项目</h1><p>这个项目就是我之前说的“生物信息组”提出的项目，从上学期末就在开始做计划，一直持续到现在，这也是我放假没有回去的原因。如果说我的本科毕业设计完成的是Heatmap 1.0——完成了用户信息和工程管理，上传基因数据文件，在线聚类分析，聚类结果可视化（太懒直接贴论文摘要了= =|），那么暑假要攻关的就是2.0（目前已基本完工），然后还有即将要动工的正在等待设计的大型工程3.0。</p><p>Heatmap 2.0的目标依旧是为论文服务，所完成的工作大概就是在1.0的功能基础上，增加了在线房间聊天互动，在大图heatmap上做各种标记（pin和mark）等功能，并且对UI界面进行了大幅的重设计，整个项目基本上持续了八月份一整个月。由于之前的1.0完全是为了实现而实现，所以代码写得比较混乱。而Heatmap 3.0是准备作为一款大型社交产品发布的，为了让2.0顺利过渡到3.0，在2.0上我们团队都比较谨慎地设计了架构。在八月前两个星期，我和YYS童鞋对整个Heatmap项目进行了代码重构，他负责后台我负责前端。最后整个项目被部署到了实验室新搞的专门用于生物信息的服务器上，并采用了PHP框架CodeIgniter，前端的JS代码采用了require.js和模块化写法。除了负责部分的前端代码之外，我还负责了在线聊天的模块，用了Node.js和Socket.io，感觉效果还不错。一直到现在，Heatmap 2.0基本上算是告一段落，项目本身没什么感觉，倒是在前端技术上有了一定的飞跃。</p><p>3.0的话目前正在紧锣密鼓地筹备中，貌似是要引入社交元素，并打造一个国外的大型图片在线协作的社交平台，预测的用户量大概希望达到十万级以上。嘛，愿望和憧憬是美好的，未来走向究竟如何，现在项目还没开始动工不好说，就拭目以待吧。</p><h1 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h1><p>这学期除了几个比较大的项目之外，个人的老师布置的大大小小还有一些比较杂的项目或小任务。正是这些杂项，我才能接触到更广范围和更新的技术。下面就挑几个重要的记录一下吧。</p><ul><li>个人新版博客：就是现在看到的这个托管在Github Page的静态博客以及新发布的主题，涉及的技术有：Hexo、Markdown、EJS、Stylus（后两个是制作主题用的模板语言）。</li><li>一个小游戏：拖延已久至今仍未完工，这学期基本没什么时间去增加新的东西，只能抽空采用新的引擎和架构重构。不过收获也是蛮大的，比如第一次接触游戏引擎，还有对js的模块化有了更深的理解等等。目前重构工作已基本完成，下一步目标就是赶紧把这个东西开发完。涉及的技术有：Cocos2D-HTML5、Sea.js模块化。</li><li>声音识别：这是老师额外布置的和一位牛逼学长合作的研究工作，做的东西大概就是录一段音乐然后去识别是哪首曲子，也就是所谓的“哼唱识别”。为此还特意去研究了国外著名应用Shazom相关的论文，并把哼唱识别算法实现出来。算法的东西基本上是学长用Matlab和Java搞定，我的重点主要是后期海量数据的处理。这也是在实际中第一次碰到大数据量的问题——用MySQL存储千万级的数据时开始出现性能瓶颈，对此学了不少数据库的优化方法，最后还是采用了MongoDB解决了这个问题。涉及的技术有：MySQL的性能优化、MongoDB。</li></ul><h1 id="本学期技术关键词（按重要度排序）"><a href="#本学期技术关键词（按重要度排序）" class="headerlink" title="本学期技术关键词（按重要度排序）"></a>本学期技术关键词（按重要度排序）</h1><p>Javascript模块化、HTML/CSS、Android、Cocos2D-HTML5、MongoDB</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新版个人博客2.0，Hexo主题Raytaylorism 1.0a上线！</title>
      <link href="/daily/hexo-theme-raytaylorism/"/>
      <url>/daily/hexo-theme-raytaylorism/</url>
      
        <content type="html"><![CDATA[<p>开始使用hexo搭建博客已经一个多月了，使用hexo+markdown写博客和发博客一切都是那么流畅自然。只是这段时间一直在忙实验室各种项目，堆了一堆博文想发但都没时间写。后来在网上查hexo资料的时候，偶然发现了<a href="http://yangjian.me" target="_blank" rel="noopener">yangjian.me</a>这个（目测是技术大牛）博客，其扁平化和清爽风格的主题（这个主题叫<a href="https://github.com/A-limon/pacman" target="_blank" rel="noopener">Pacman</a>）一下子就吸引了我。看着自己原先使用的那个主题modernist <a href="http://heroicyang.com/" target="_blank" rel="noopener">DEMO</a>突然觉得自己的博客实在是弱爆了。我开始思考自己的博客为什么不给自己设计一个主题呢？别人的博客主题虽然也是开源的，但作为一个geeker，直接拿别人的东西过来用始终有点不爽。于是我开始着手构想和设计自己的主题。</p><a id="more"></a><p>今年扁平化是设计界流行的一大趋势，为了跟（zhuang）风（bi）我也准备设计主题的时候往这上面靠。说实话一开始我还真不知道扁平化为何物，查了很多资料看了很多案例，才渐渐领悟了其内涵，包括布局、色彩、图标、字体等等。我不是UI设计师，很多东西都是凭现学现用和个人的审美来做，完全达不上专业的水准。不过个人博客嘛，自己看着舒爽就行了，只要旁人怎么看，萝卜青菜各有所爱，随他们怎么说。</p><p>不过为了在设计的过程中少走歪路，我还是特地请了位学建筑设计的朋友<strong>Nix</strong>帮忙，新版博客的诞生少不了他的帮忙。在此对他的倾情帮助表示感谢！</p><p>新版博客的改版工作基本上就在于制作主题上，从设计到编码前后大概花了两周。Hexo主题的制作需要使用默认的模板语言<a href="https://github.com/visionmedia/ejs" target="_blank" rel="noopener">EJS</a>和<a href="http://learnboost.github.io/stylus/" target="_blank" rel="noopener">Stylus</a>，所幸这两个东西看似很牛逼，但其实还是蛮容易学。EJS是HTML和Javascript的结合，有点类似于用PHP来写网页的模板，而Stylus是一种CSS模板语言，语法基本遵循CSS的语法，并加上一些更方便使用的东西，这个和现今使用的lesscss的思想是一致的。说到底，制作一个新主题基本上就是在别人的主题框架上，对前端代码进行修改，所以一款精美的主题最重要的还是在UI设计层面。因此虽说是改版自己的博客，但学到的东西还是很多的，比如前端的技术又前进了一步，扁平化设计的经验也上升了一些等等。</p><p>当然，这款raytaylorism（译：Ray Taylor主义）主题最主要还是针对我自己的个人喜好来设计，因此没有过多地考虑实用性和可扩展性，应该说是一款个性比较强的主题。如果你喜欢这款Hexo主题，可以直接从这个主题的<a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism" target="_blank" rel="noopener">Github Repo</a> 上fork过去，随意地修改成你喜欢的风格。我已经把大部分的配色通过一个文件分离了出来，可以非常方便地实现换肤。这款主题现在只是1.0alpha版本，后续我还会继续添加新的功能。此外，使用Hexo来写博客这个方法我会一直坚持下去，后续我会逐步写一些使用Hexo搭建博客的方法，大家可以关注一下。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客从Wordpress进化到Hexo啦</title>
      <link href="/daily/wordpress-to-hexo/"/>
      <url>/daily/wordpress-to-hexo/</url>
      
        <content type="html"><![CDATA[<p>之前在衡天小张那购买的主机过期了，虽说在主机上搭建的Wordpress使用起来非常方便，不过使用了一年之后感觉那个主机响应速度略慢，所以就懒得继续掏钱了。考虑到丁基友的博客就是用静态页面托管到Github上的，简单可靠又免费，同时也想要学习一下markdown并用它来写博客，所以准备尝试转向静态博客的路。</p><a id="more"></a><p>丁基友的那个博客采用的是Octopress，于是自然而然开始看起Octopress的教程来。这货居然要装RUBY，好吧为了博客只好忍了，在装了几个RUBY之后明明按照教程一步步做了结果连第一页的安装教程都继续不下去，老是卡在一个地方出错了，好吧在Windows下搞和RUBY有关的东西真的很蛋疼，只好放弃Octopress了。</p><p>然后在网上查静态博客的解决方案的时候，无意中发现hexo这个东西，而且还看到有的博文说从Wordpress转向Octopress最后用上hexo之后，知道了这个东西的口碑还可以。上了官网一看目测还不错，好像是台湾人做的，教程特别简洁明了还有中文翻译。当然由于太过于简洁，有一些比较关键的细节没有谈到导致在配置的时候饶了一点弯路。在搞了大半天之后，终于成功把第一个测试页面推送到Github上并访问，总算没有白折腾。</p><p>忙了两天终于把原先在Wordpress上的文章转成markdown格式并应用到实际中，现在迁移工作已经基本完成，对hexo和markdown也开始熟悉起来，接下来的工作就是把官方推荐的主题修改到自己满意为止。话说hexo这个东西确实不错，基于node.js使得它生成页面速度非常快，能支持markdown，可以很方便地部署到Github Pages上，据说还支持Octopress的插件。等博客新版上线稳定之后，我会开始整理一下用hexo搭建博客的教程，敬请期待。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Comet：基于 HTTP 长连接的“服务器推”技术简介</title>
      <link href="/tech/complex/mixed/comet-intro/"/>
      <url>/tech/complex/mixed/comet-intro/</url>
      
        <content type="html"><![CDATA[<p>最近实验室生物信息Heatmap项目正在考虑做一个这样的功能：一个用户在heatmap（一张超大的可能是GB级别大小的图片）上做一个标注，另一个在线的用户可以马上就看得出来，相当于在线协作。其实这功能的原理就有点类似现在很多网站上的即时通讯，比如Web QQ和网页版的阿里旺旺。按照学长的指示，我开始接触到一种叫Comet的技术，也就是本文所要汇总的内容。</p><a id="more"></a><p>关于Comet的入门介绍，这里有一篇很好的<a href="http://www.ibm.com/developerworks/cn/web/wa-lo-comet/" target="_blank" rel="noopener">文章</a>。</p><p>接下来是5篇很详细的博文，从Comet各种实现方式的介绍，到WebSocket，到各种常用的Comet框架介绍都有。</p><ol><li><a href="http://blog.csdn.net/coderjiang/article/details/8675120" target="_blank" rel="noopener">反向Ajax第1部分——Comet介绍</a></li><li><a href="http://blog.csdn.net/coderjiang/article/details/8675539" target="_blank" rel="noopener">反向Ajax第2部分——WebSocket</a></li><li><a href="http://blog.csdn.net/coderjiang/article/details/8676823" target="_blank" rel="noopener">反向Ajax第3部分——Web服务器和Socket.IO</a></li><li><a href="http://blog.csdn.net/coderjiang/article/details/8676882" target="_blank" rel="noopener">反向Ajax第4部分——Atmosphere和CometD</a></li><li><a href="http://blog.csdn.net/coderjiang/article/details/8676923" target="_blank" rel="noopener">反向Ajax第5部分——事件驱动的Web开发</a></li></ol><p>以上如果想要快速了解概况以及各种技术的对比，看第1部分就够了（包括后面几部分其中涉及的Java代码基本上不用看）。第2部分涉及较新的HTML5的WebSocket也是非常强大，值得关注。第3部分介绍了Socket.IO这个很强大的js库，简单好用，也是我初步决定采用的即时通讯技术方案。最后两部分还没细看，目测也用不着。</p><p>看了几天的文章之后，初步对Comet技术有了大体的认识，也了解到目前使用最多的实现方式应该是采用ajax长轮询，而较新且更强大的是使用WebSocket。而在丁基友的推荐下，我可是接触Socket.IO这个东西，貌似可以兼容大部分常见浏览器，并自动采用最佳方式来满足这种即时通讯的需要，于是决定了下一步开始对Socket.IO展开研究。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 综合 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Comet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA 12.0中文显示问题解决方案</title>
      <link href="/tech/tool/IDE/intellij-idea-chinese-display/"/>
      <url>/tech/tool/IDE/intellij-idea-chinese-display/</url>
      
        <content type="html"><![CDATA[<p>IntelliJ IDEA是一个非常强大的IDE，但是只有英文版，且默认的中文显示有一定问题。本文介绍了IntelliJ IDEA 12.0中文显示问题解决方案。</p><a id="more"></a><h3 id="1-IDE本身的中文乱码"><a href="#1-IDE本身的中文乱码" class="headerlink" title="1. IDE本身的中文乱码"></a>1. IDE本身的中文乱码</h3><p>这个问题体现在IDE本身，比如打开文件浏览目录的时候，中文名的文件或目录会显示成方块。</p><p>解决方法：  </p><ol><li>进入设置页。File-&gt;Settings。  </li><li>进入IDE Settings里的File Encodings项，把IDE Encoding项设置成UTF-8。确定。  </li><li>进入IDE Settings里的Appearance项，选中Override default fonts by，把Name设置为你喜欢的字体（我使用的是Yahei Consolas Hybrid），Size根据自己喜好设置（我一般设为 14）。确定。</li></ol><p>以上应该可以保证中文显示没有问题了。</p><h3 id="2-编辑器的中文问题"><a href="#2-编辑器的中文问题" class="headerlink" title="2. 编辑器的中文问题"></a>2. 编辑器的中文问题</h3><p>这个问题体现在代码编辑区中写中文时，可能会乱码或者中文汉子全部重叠在一起。</p><p>首先要确定你正在编辑的文件是UTF-8编码的，有很多文件可能默认是ANSI编码。</p><p>至于中文重叠那是因为你所选用的默认中文字体不对，一直以来我写代码都是用的consolas，但是这个字体不支持中文，Intellij IDEA 12中如果使用默认的中文字体（不知道是哪个字体）就会重叠在一起，在网上找了好久，终于找到一个神一般的字体<em>Yahei Consolas Hybrid</em>，即微软雅黑和consolas的混合！</p><p>于是乎，File-&gt;Settings IDE Settings-&gt;Editor-&gt;Color &amp; Fonts-&gt;Font，设置字体为Yahei Consolas Hybrid即可。</p><p><strong><a href="http://pan.baidu.com/s/1c0lAVfE" target="_blank" rel="noopener">神一般的字体Yahei Consolas Hybrid下载</a></strong></p><p>如果发现安装了这个字体但是在设置中找不到的话，尝试使用以下这个方法：<br>按图所示，保存为另外一个名字，由你喜欢。最好是英文字母组成，这里我们保存为Darcula1。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/IDE/Intellij%20IDEA%2012%20%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93.jpg" alt="Intellij IDEA 12 设置字体">  </p><p>在此路径（win7）“C:\Users\你的计算机名\.IntelliJIdea12\config\colors”找到Darcula1.xml文件。<br>用记事本打开Darcula1.xml文件，把第8行  </p><pre><code>&lt;option name=&quot;EDITOR_FONT_NAME&quot; value=&quot;你之前保存的字体&quot; /&gt;</code></pre><p>改为  </p><pre><code>&lt;option name=&quot;EDITOR_FONT_NAME&quot; value=&quot;YaHei Consolas Hybrid&quot; /&gt;</code></pre><p>然后重启IntelliJ IDEA 12.0，中文字符问题解决，效果如下图。</p><p><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/IDE/Intellij%20IDEA%2012%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E6%98%BE%E7%A4%BA%E6%95%88%E6%9E%9C.jpg" alt="Intellij IDEA 12中文字符显示效果"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具 </category>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2012年秋季学期总结</title>
      <link href="/daily/2012-autumn-summary/"/>
      <url>/daily/2012-autumn-summary/</url>
      
        <content type="html"><![CDATA[<p>学期末了，做点简短的总结，以回顾一下这半年都做了什么东西。</p><a id="more"></a><h1 id="保研那点事"><a href="#保研那点事" class="headerlink" title="保研那点事"></a>保研那点事</h1><p>9月份刚开学就开始各方面打听关于保研的事情。关于保研的前因后果来龙去脉写下来都能另外开一篇博文了，经验之谈什么的就不在这里写了，有兴趣的再私底下交流吧，在这里就简单说下感受。</p><p>由于国庆节前九月底保研名单就敲定了，开学之后一般都会有一个星期浑浑噩噩处于过渡时期嘛，系里保研的相关消息也是快到中旬才有，所以真正参与在保研战斗中也就两三周。当然正常人都是一开学就开始看书复习，也不排除有些学霸在暑假就开始复习的= =| 那蛋疼的八二开成绩计算方式不用说，为了那微妙的几分笔试成绩重刷专业课课本不用说，面试中发挥得自我感觉良好不用说，填写志愿大家都在为了那几个有限的保研名额各种勾心斗角竞争的就更不用说了。总而言之，我各种加分堆上去之后专业排第19，除掉那些保外的，我算是顺利拿到了保内学硕的资格。整个九月份都花在了保研这件事上，虽然很累，但为了过上猪一般的生活，累其实是很值的。</p><h1 id="过渡时期"><a href="#过渡时期" class="headerlink" title="过渡时期"></a>过渡时期</h1><p>有一句话说：“大四的学生里面，保研的过着猪一般的生活，找工作的过着狗一般的生活，考研的过着猪狗不如的生活。”我觉得十月份从家里回到学校之后，这句话并不使用于我。嘛，保研之前甚至大三的时候就已经想好了保研之后要怎么过了。个人感觉大学前三年最缺的就是大段的空闲时间学自己想学的东西，做自己想做的事情，罪魁祸首就是各种考试！难得保完研终于脱身，各种TODO就开始提上日程了。</p><p>十月份的主要正事就是进实验室，参加为期近一个月的Java培训，其余时间则过着半度假式的半天学习半天休息的生活。当然这段时期妹子要试考公务员，于是天天泡图书馆也看了不少技术书（都没看完实在是捉急= =|）。即使保完研，生活依旧可以过得很充实。</p><h1 id="两个游戏"><a href="#两个游戏" class="headerlink" title="两个游戏"></a>两个游戏</h1><p>这个学期里出于练手和兴趣爱好，前后一共编写了两个小游戏。作品最后的结果如何其实不重要，在此期间锻炼的技术，开拓的视野才是不可估量的财富。<br>第一个游戏（10月下旬-11月中旬）诞生于实验室Java培训期间。那段时间比较迷恋玩Doodle Jump，于是在培训的过程中也萌生了自己实现一遍游戏的欲望。Java语法本来就跟C#差不多转型没什么压力，再加上之前对游戏流程比较熟悉，所以制作过程中相当顺手。题材的话我还是习惯性地往东方同人方向去靠拢，考虑到是一款跟弹跳有关的游戏，我自然而然等想到萌萌的青蛙子，于是这个游戏就定下名称为Suwako Jump（Suwako为诹访子，青蛙子的本名）。</p><p>当然由于是一个练手的项目，我一开始就没打算要把这个游戏做完整，只要实现基本功能（踩着各种板子往上跳）就够看了，什么道具啊怪物啊都没有去考虑。尽管原型涂鸦弹跳看似很简单，但是在做的过程中碰上的场景平滑下降的问题还是让我蛋疼了一阵子。</p><p>做到最后，刚好碰上实验室培训尾声阶段学长要求我们每个人独立完成一个Java大作业，题目自定，于是直接拿游戏交差了事，也算是一个小惊喜吧。这充分证明了平时多做积累多做准备，很多机会来到面前就可以及时地抓住。以前我是挺鄙视Java的，不过在被逼无奈的情况下完成了一个成品之后，我对语言的厌恶感似乎减少了那么一点，这是后话。</p><p>一开始也没有想到过这个游戏会做两期。第一期即Java大作业，用swing做窗体。后来那个坑爹软件大奖赛稀里糊涂地进了什么中国100强，然后为了角逐10强，需要提交个android项目，于是为了图方便省事开始做移植工作，于是Suwako Jump第二期安卓移植版（13年整个1月份）开始启动。</p><p>原本以为同是Java程序，大三暑假也摸过一点安卓开发，应该很好移植，但实际操作起来异常蛋疼，比如开发环境配置得超久，效率严重低下的模拟器，框架的大改动，多设备分辨率的适应性等等。最后搞下来还是决定用真机调试，问题是这么讨厌安卓系统的我怎么会有机子呢！所以一开始是找妹子借了平板调试，后来妹子回家了就到处跟同学借手机= =|</p><p>做这玩意一开始也是抱着早做完早超生，应付一下比赛了事的想法，因此各种功能还是计划得非常简单能够一周之内做完最好。但是做到后半部分的时候开始觉得投入的时间很多，既然要参加比赛就要争取拿到好的名次，于是开始完善各种UI界面。断断续续磨了两周多，最后总算是把一个完整的游戏，从起始界面到选关到游戏界面等等一条龙全都做起来了。看截图就知道了，UI当然比不过专业团队，游戏性也不是很强，但有UI和声音看起来起码不会那么苍白，也不知道这玩意能够拿到什么样的名次，听天由命吧。<br>最后游戏是做出来了，装到实机上玩还是挺带感的，过几天我就把它上线到安卓市场（比赛的要求），但我还是很讨厌安卓，以后也不想碰安卓开发，哼= =|</p><p>如果说第一个游戏从头到尾都只是应付了事，那么第二个游戏应该算比较精致了，在其上也投入了很多精力。没错，这个游戏就是那个以工作室圣诞节专题为背景的HTML5打雪仗游戏Reindy vs. Santy（传送门：xmas.sicun.org）。这是我第一次在工作室带项目，包括我一共5人，两个前端两个美工一个运营策划，后来还有丁基友的鼎力相助帮忙写了服务器端。游戏不大，但是编码起来压力还是很大的，因为另外一位童鞋没接触过HTML5，所以只能我独自一人承担所有游戏逻辑，他来负责前端WEB的布局。为了赶在圣诞节那天上线，连续两晚在工作室刷夜的日子实在不堪回首。工作量次大的应该是辛苦的美工妹子了，在大一有很多考试的情况下还一直被我催着交稿，确实是很辛苦。游戏中所看到的80%以上的图像全都是妹子的手绘，的确非常给力。为了吸引访问量我们还特地搞了排行榜并设置了奖品，但是服务器端找不到人手写，幸得丁基友友情相助搞定了这一块。还有策划的童鞋负责其它一些事务性的工作，总而言之这个项目的完成离不开项目组中的每一个人。</p><p>从11月末到圣诞节，在这个项目上投入的精力确实很多，技术当然得到很多磨练，也增长了不少很重要的见识。这个项目发放奖品的活动的持续时间是圣诞节到元旦，这期间访问量可能不是很多，但毕竟这是我第一个公开的应用，还是很有纪念意义的。期间还是有很多热心的玩家不断在排行榜上刷新纪录，也让我相当欣慰。游戏下线之后，我已经有了做打雪仗第二代的打算，下一次会做好更充足的准备，做出一个更完整的作品来。</p><h1 id="本学期技术关键词（按重要度排序）"><a href="#本学期技术关键词（按重要度排序）" class="headerlink" title="本学期技术关键词（按重要度排序）"></a>本学期技术关键词（按重要度排序）</h1><p>HTML5、Intellij IDEA、Javascript、Java、Github、Android</p><h1 id="关于实验室"><a href="#关于实验室" class="headerlink" title="关于实验室"></a>关于实验室</h1><p>保研之后虽说进了实验室，不过也就打打酱油，直到学期末导师才开始布置任务和明确目标。简单来说，一开始我是被分在了“生物信息”组（大概是叫这个名字吧），研究的方向大概是利用信息技术处理和研究基因与疾病的关系。反正老师说本科生一开始进实验室都是分配什么干什么，旨在磨合和熟悉工作环境，等到以后再慢慢转型，所以关于研究方向我也说不了什么。导师很强势，目标感也很强，这有好也有坏，不管怎么说，现在还是先休息一段时间要紧，到下学期再投入到实验室的项目中去。</p><h1 id="寒假计划"><a href="#寒假计划" class="headerlink" title="寒假计划"></a>寒假计划</h1><p>两大目标：重构打雪仗游戏，算法！（说了几个学期要重修了还是没修成T_T）</p><p>能达成上面两个目标就挺不容易了，还有其他一堆杂事如果有时间有精力的话也要处理，比如生物信息组的项目，看代码，尝试着把某XX SGA平台做成一个通用组件（听起来很装逼是不是= =|）；比如学下CSS（确实自己不会前台处处受气很被动啊）；比如如果能顺利看完算法还能看下游戏AI啊一直都对这玩意超感兴趣的（不会算法还是要处处受气T_T）；杂事一大堆啊。。。。。</p><p>当然寒假还是要好好休息一下，要不然下学期高负荷工作会跪掉的，再把Hitman5打通关，挑战全收集所有关卡能SA的都SA神马的，完美主义作祟啊实在是没办法= =|</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas快速入门</title>
      <link href="/tech/web/html5/canvas-quick-start/"/>
      <url>/tech/web/html5/canvas-quick-start/</url>
      
        <content type="html"><![CDATA[<p>本文是一个Canvas快速入门，亦是<a href="http://book.douban.com/subject/7162014/" target="_blank" rel="noopener">Rob Hawkes《HTML5 Canvas基础教程》人民邮电出版社</a>一书的读书笔记。</p><a id="more"></a><h1 id="1-Canvas元素"><a href="#1-Canvas元素" class="headerlink" title="1. Canvas元素"></a>1. Canvas元素</h1><p>以下html代码定义了一个canvas元素。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Canvas快速入门&lt;/title&gt;    &lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;canvas id=&quot;mainCanvas&quot; width=&quot;640&quot; height=&quot;480&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>通过以下Javascript语句访问canvas元素：</p><pre><code>//DOM写法window.onload = function () {    var canvas = document.getElementById(&quot;mainCanvas&quot;);    var context = canvas.getContext(&quot;2d&quot;);};//jQuery写法$(document).ready(function () {    var canvas = $(&quot;#mainCanvas&quot;);    var context = canvas.get(0).getContext(&quot;2d&quot;);});//接下来就可以调用context的方法来调用绘图API</code></pre><h1 id="2-基础API"><a href="#2-基础API" class="headerlink" title="2. 基础API"></a>2. 基础API</h1><h2 id="2-1-坐标系统"><a href="#2-1-坐标系统" class="headerlink" title="2.1 坐标系统"></a>2.1 坐标系统</h2><p>Canvas 2D渲染上下文采用平面笛卡尔坐标系统，左上角为原点(0,0)，坐标系统的1个单位相当于屏幕的1个像素。具体如下图：<br><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/HTML5/HTML5%20Canvas%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F.jpg" alt="HTML5 Canvas坐标系统"></p><h2 id="2-2-绘制基本图形"><a href="#2-2-绘制基本图形" class="headerlink" title="2.2 绘制基本图形"></a>2.2 绘制基本图形</h2><h3 id="2-2-1-矩形"><a href="#2-2-1-矩形" class="headerlink" title="2.2.1 矩形"></a>2.2.1 矩形</h3><pre><code>//绘制一个填充矩形context.fillRect(x, y, width, height)//绘制一个边框矩形context.strokeRect(x, y, width, height)//清除一个矩形区域context.clearRect(x, y, width, height)</code></pre><h3 id="2-2-2-线条"><a href="#2-2-2-线条" class="headerlink" title="2.2.2 线条"></a>2.2.2 线条</h3><p>绘制线条与绘制图形有一些区别，线条实际上称为路径。要绘制一条简单的路径，首先必须调用beginPath方法，接着调用moveTo设置路径的起点坐标，然后调用lineTo设置线段终点坐标（可多次设置），再调用closePath完成路径绘制。最后调用stroke绘制轮廓（或调用fill填充路径）。以下为例子：</p><pre><code>//示例context.beginPath();    //开始路径context.moveTo(40, 40);    //移动到点(40,40)context.lineTo(300, 40);    //画线到点(300,30)context.lineTo(40, 300);    //画线到点(40,300)context.closePath();    //结束路径context.stroke();    //绘制轮廓//或者填充用context.fill();</code></pre><h3 id="2-2-3-圆形"><a href="#2-2-3-圆形" class="headerlink" title="2.2.3 圆形"></a>2.2.3 圆形</h3><p>Canvas实际上并没有专门绘制圆形的方法，可以通过画圆弧来模拟圆形。由于圆弧是一种路径，所以画圆弧的API应该包含在beginPath和closePath之间。</p><pre><code>/* 绘制一条圆弧 * @param x,y 圆心的横纵坐标 * @param radius 圆的半径 * @param startAngle 起始角度，以弧度为单位，x轴方向为0 * @param endAngle 结束角度，以弧度为单位 * @param anticlockwise 布尔值，表示是否按逆时针方向绘制 */context.arc(x, y, radius, startAngle, endAngle, anticlockwise)</code></pre><p>更多用法参见<a href="https://developer.mozilla.org/en-US/docs/HTML/Canvas/Tutorial/Drawing_shapes?redirectlocale=en-US&amp;redirectslug=Canvas_tutorial%2FDrawing_shapes" target="_blank" rel="noopener">Drawing shapes(MDN)</a>。</p><h2 id="2-3-样式"><a href="#2-3-样式" class="headerlink" title="2.3 样式"></a>2.3 样式</h2><h3 id="2-3-1-修改线条颜色"><a href="#2-3-1-修改线条颜色" class="headerlink" title="2.3.1 修改线条颜色"></a>2.3.1 修改线条颜色</h3><pre><code>var color;//指定RGB值color = &quot;rgb(255, 0, 0)&quot;;//指定RGBA值（最后一个参数为alpha值，取值0.0~1.0）color = &quot;rgba(255, 0, 0, 1)&quot;;//指定16进制码color = &quot;#FF0000&quot;;//用单词指定color = &quot;red&quot;;//设置填充颜色context.fillStyle = color;//设置边框颜色context.strokeStyle = color;</code></pre><h3 id="2-3-2-修改线宽"><a href="#2-3-2-修改线宽" class="headerlink" title="2.3.2 修改线宽"></a>2.3.2 修改线宽</h3><pre><code>//指定线宽值var value= 3;//设置边框颜色context.linewidth = value;</code></pre><p>更多样式介绍参见<a href="https://developer.mozilla.org/en-US/docs/HTML/Canvas/Tutorial/Applying_styles_and_colors" target="_blank" rel="noopener">Applying styles and colors(MDN)</a>。</p><h2 id="2-4-绘制文本"><a href="#2-4-绘制文本" class="headerlink" title="2.4 绘制文本"></a>2.4 绘制文本</h2><pre><code>//指定字体样式context.font = &quot;italic 30px 黑体&quot;;//在点(40,40)处画文字context.fillText(&quot;Hello world!&quot;, 40, 40);</code></pre><h2 id="2-5-绘制图像"><a href="#2-5-绘制图像" class="headerlink" title="2.5 绘制图像"></a>2.5 绘制图像</h2><p>在绘制图像之前，需要先定义图像并加载。</p><pre><code>var img = new Image();img.src = &quot;myImage.png&quot;;img.onload = function () {    //图像加载完毕执行};</code></pre><p>以下是drawImage API解释：</p><pre><code>//在(x,y)出绘制图像imagecontext.drawImage(image, x, y)//在(x,y)出绘制width*height的图像imagecontext.drawImage(image, x, y, width, height)//在image的(sx,sy)处截取sWidth*sHeight的图像，在(dx,dy)处绘制dWidth*dHeight的图像context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</code></pre><h1 id="3-高级功能"><a href="#3-高级功能" class="headerlink" title="3. 高级功能"></a>3. 高级功能</h1><h2 id="3-1-使Canvas填满浏览器窗口"><a href="#3-1-使Canvas填满浏览器窗口" class="headerlink" title="3.1 使Canvas填满浏览器窗口"></a>3.1 使Canvas填满浏览器窗口</h2><p>最简单的方式是将canvas元素的宽度和高度精确设置为浏览器窗口的宽度和高度，用CSS消去白色空隙。</p><p>CSS代码：</p><pre><code>* {    margin: 0;    padding: 0;}html, body {    height: 100%;    width: 100%;}canvas {    display: block;}</code></pre><p>Javascript代码：</p><pre><code>function resizeCanvas() {    //canvas由jQuery获取    canvas.attr(&quot;width&quot;, $(window).get(0).innerWidth);    canvas.attr(&quot;height&quot;, $(window).get(0).innerHeight);    context.fillRect(0, 0, canvas.width(), canvas.height());}$(window).resize(resizeCanvas);resizeCanvas();</code></pre><h2 id="3-2-绘图状态"><a href="#3-2-绘图状态" class="headerlink" title="3.2 绘图状态"></a>3.2 绘图状态</h2><p>在canvas中，绘图状图指的是描述某一时刻2D渲染上下文外观的整套属性，包括：变换矩阵、裁剪区域、globalAlpha、globalCompositeOperation、strokeStyle、fillStyle、lineWidth、lineCap、lineJoin、miterLimit、shadowOffsetX、shadowOffsetY、shadowBlur、shadowColor、font、textAlign和textBaseline。</p><p>当需要改变画布全局状态时，一般先将当前状态保存起来——调用save方法将状态推入绘图状态栈），做完操作之后，再调用restore方法回复绘图状态。</p><pre><code>//示例context.save();context.globalAlpha = 0.5;context.fillRect(0, 0, 200, 100);context.restore();</code></pre><h2 id="3-3-变形"><a href="#3-3-变形" class="headerlink" title="3.3 变形"></a>3.3 变形</h2><h3 id="3-3-1-平移"><a href="#3-3-1-平移" class="headerlink" title="3.3.1 平移"></a>3.3.1 平移</h3><p>将2D渲染上下文的原点从一个位置移动到另一个位置。注意，这里移动的是坐标原点即全局绘图位置，API如下：</p><pre><code>//将坐标原点移动到(x,y)context.translate(x, y)</code></pre><h3 id="3-3-2-缩放"><a href="#3-3-2-缩放" class="headerlink" title="3.3.2 缩放"></a>3.3.2 缩放</h3><pre><code>//将全局横纵尺寸缩放至x,y倍（即在原有数值乘上倍乘因子）context.scale(x, y)</code></pre><h3 id="3-3-3-旋转"><a href="#3-3-3-旋转" class="headerlink" title="3.3.3 旋转"></a>3.3.3 旋转</h3><pre><code>//将画布绕着原点旋转radius弧度context.rotate(radius)</code></pre><p>更多高级特性参见<a href="https://developer.mozilla.org/en-US/docs/HTML/Canvas/Tutorial/Transformations?redirectlocale=en-US&amp;redirectslug=Canvas_tutorial%2FTransformations" target="_blank" rel="noopener">Transformations(MDN)</a>。</p><p>参考文献：<a href="http://book.douban.com/subject/7162014/" target="_blank" rel="noopener">Rob Hawkes《HTML5 Canvas基础教程》人民邮电出版社</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web前端 </category>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua学习笔记（3）——Lua语句</title>
      <link href="/tech/language/lua/lua-note-3/"/>
      <url>/tech/language/lua/lua-note-3/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了Lua的基本语句，并依次介绍了Lua程序的顺序结构和控制结构。</p><a id="more"></a><h1 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1. 顺序结构"></a>1. 顺序结构</h1><h2 id="1-1-赋值"><a href="#1-1-赋值" class="headerlink" title="1.1. 赋值"></a>1.1. 赋值</h2><p>除了普通的用“=”赋值之外，Lua还允许多重赋值，每个值和每个变量之间用逗号分隔。<strong>Lua总会将等号右边值的个数调整到与左边变量个数一致，若值个数少了，则多余的变量将赋予nil；若值个数多了，则多余的值会被丢弃。</strong>如<code>a, b = 10, 2 * x</code>，<code>x, y = y, x</code>（交换）。多重赋值一般用于交换两个变量的值，或者接受一个函数的多个返回值。</p><h2 id="1-2-局部变量与程序块"><a href="#1-2-局部变量与程序块" class="headerlink" title="1.2. 局部变量与程序块"></a>1.2. 局部变量与程序块</h2><p>相对于全局变量，Lua还提供了局部变量，给变量加上限定词local即可。局部变量的作用域仅限于声明它们的那个程序块（如控制结构的执行体、函数等）。</p><p><strong>注意，在交互模式中每行输入内容自身就形成了一个程序块，因此单句local声明没有效果。可以显式界定一个块，将内容放入一对do-end关键字中即可，这个方法也可以用于严格控制某些局部变量的作用域。</strong></p><p>有一种习惯写法<code>local foo = foo</code>，创建一个局部变量foo并用全局变量foo的值初始化它。若后续其他函数改变全局变量foo的值，可以在这里先将其保存起来。</p><h1 id="2-控制结构"><a href="#2-控制结构" class="headerlink" title="2. 控制结构"></a>2. 控制结构</h1><p>所有控制结构语句都有一个显示的终止符：if、for、和while以end结尾，repeat以until结尾。</p><h2 id="2-1-if-then-else-elseif-语句"><a href="#2-1-if-then-else-elseif-语句" class="headerlink" title="2.1. if then else(elseif)语句"></a>2.1. if then else(elseif)语句</h2><pre><code>格式：if &lt;条件1&gt; then &lt;内容1&gt; elseif &lt;条件2&gt; then &lt;内容2&gt; else &lt;内容3&gt; end</code></pre><p><strong>Lua中不支持switch语句，所以一连串if elseif语句是很常见的。</strong></p><h2 id="2-2-while和repeat语句"><a href="#2-2-while和repeat语句" class="headerlink" title="2.2. while和repeat语句"></a>2.2. while和repeat语句</h2><pre><code>格式：while &lt;条件&gt; do &lt;循环体&gt; end格式：repeat &lt;循环体&gt; until &lt;条件&gt;</code></pre><p>在Lua中，一个声明在循环体内的局部变量的作用域包括循环的条件测试。</p><h2 id="2-3-数字型for语句"><a href="#2-3-数字型for语句" class="headerlink" title="2.3. 数字型for语句"></a>2.3. 数字型for语句</h2><pre><code>格式：for var=exp1, exp2, exp3 do &lt;循环体&gt; end</code></pre><p>上式表示var从exp1变化到exp2，以exp3作为步长递增var。其中exp3是可选的，若不指定则默认步长为1。如果将exp2设为math.huge，则为无限循环。</p><p>有一些细节需要注意。for的3个表达式是在循环开始前一次性求值的，以后将不再求值。另外，控制变量会被自动地声明为for语句的局部变量，仅在循环体内可见。</p><h2 id="2-4-泛型for语句"><a href="#2-4-泛型for语句" class="headerlink" title="2.4. 泛型for语句"></a>2.4. 泛型for语句</h2><p>泛型for循环通过一个迭代器来遍历所有值，如<code>for i,v in ipairs(tableA) do print(v) end</code>，其中i被赋予索引值，而v被赋予对应的元素值。<strong>其中<code>ipairs(array)</code>函数用于遍历数组并返回数字下标-元素值对，<code>pairs(table)</code>函数用于遍历table并返回键-值对，<code>string.gmatch(string)</code>迭代字符串中的单词。</strong></p><p>泛型for的一个应用是创建逆向table，即新table的键值与原table键值反转。</p><h2 id="2-5-break和return语句"><a href="#2-5-break和return语句" class="headerlink" title="2.5. break和return语句"></a>2.5. break和return语句</h2><p>这两个语句都用于跳出当前的语句块，break结束一层循环，return结束一个函数的执行。如果刚定义了一个function然后直接要在一开始就跳出函数作为调试用，可以用一个显示的do块来包含return语句，即<code>function foo() do return end end</code>。</p><p>参考文献：电子工业出版社《Lua程序设计（第2版）》第4章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua学习笔记（2）——变量类型与表达式</title>
      <link href="/tech/language/lua/lua-note-2/"/>
      <url>/tech/language/lua/lua-note-2/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了Lua的变量类型与表达式，着重强调各种类型需要注意的地方。本文介绍了Lua的变量类型与表达式，着重强调各种类型需要注意的地方。</p><a id="more"></a><h1 id="1-Lua类型"><a href="#1-Lua类型" class="headerlink" title="1. Lua类型"></a>1. Lua类型</h1><h2 id="1-1-基本类型"><a href="#1-1-基本类型" class="headerlink" title="1.1 基本类型"></a>1.1 基本类型</h2><p>Lua是一种动态类型语言，没有类型定义的语法。Lua一共有8种基础类型：nil（空）、boolean（布尔）、number（数字）、string（字符串）、userdata（自定义类型）、function（函数）、thread（线程）、table（表）。</p><p><strong>函数type可根据一个值返回其类型名称（字符串），如<code>print(type(print))</code>，输出“function”；<code>print(type(type(X)))</code> ，输出“string”。（这里不管X有没有定义，type(X)总是返回字符串）</strong></p><h2 id="1-2-各类型要注意的地方"><a href="#1-2-各类型要注意的地方" class="headerlink" title="1.2 各类型要注意的地方"></a>1.2 各类型要注意的地方</h2><ol><li><p>关于boolean</p><p> 在Lua中，false和nil视为“false”，其它值均视为“true”（包括数字0和空字符串）。</p></li><li><p>关于number</p><p> 该类型用于表示实数（双精度double），整数也用此类型表示。</p></li><li><p>关于string</p><p> 字符串不能像C语言一样直接修改某个字符，必要时应通过string库创建一个新的字符串。字符串可以用一对匹配的单引号或双引号来界定。可以实用类C语言的转义序列。</p><p> 此外，可以用双方括号<code>[[内容]]</code>来界定，其中的换行字符均被忽略，适用于包含一整段的字符串。<strong>若在左边的两个方括号间加入任意数量的等号，如<code>[===[</code>，则字符串右边应该匹配带相同数量等号的方括号，如<code>]===]</code>，这样做就可以在不加转义的情况下直接嵌入任意内容的字符串。同理注释也可以这样使用，如<code>--[==[</code>匹配<code>--]==]</code>。</strong></p><p> Lua提供运行时的数字与字符串自动转换。如<code>print(&quot;10&quot;+1)</code> –&gt; 11，<code>print(10 ..20)</code> –&gt; 1020（“..”是字符串连接符，上例将数字转换成字符串并连接，<strong>数字和..之间应该留一个空格</strong>）。</p><p> 建议尽量少用自动转换，如有需要可用强制转换。<strong>函数<code>tonumber(x)</code>尝试将x转换成数字，若失败则返回nil，函数<code>tostring(x)</code>将x转换成字符串。在字符串前放置“#”可获得字符串的长度，如<code>print(#&quot;length&quot;)</code> –&gt; 6</strong>。</p></li><li><p>关于table</p><p> Table是一种具有特殊索引方式的数组，可以实用除nil外的其他类型的值作为索引，其增长与删减均通过自动内存管理来完成。<strong>Table是一个“对象”，程序仅持有一个对它们的引用，例如可以通过<code>a = {}</code>创建一个table并将它的引用存储到a，若再<code>b = a</code>，则b与a引用同一个table。</strong>若table的某个元素没有初始化，其值即为nil，可以通过赋nil来删除table的某个元素。</p><p> 有一种等价写法：<code>p[&quot;age&quot;]</code>等价于<code>p.age</code>。<strong>注意，p.age和p[age]并不等价。</strong></p><p> “#”可用于返回一个数组的最后一个索引值（或其大小）。例如<code>print(a[#a])</code>打印列表a的最后一个值，<code>a[#a+1] = io.read()</code>读入一个值并插入到列表a末尾。<strong>注意，Lua将nil作为界定数组结尾的标志，当一个数组中间含有nil时，#会认为第一个nil就是结尾，因此应避免对含“空隙”的数组使用#。</strong></p><p> <strong>在Lua中，一般默认table第一个索引为1而不是C语言中的0。</strong></p></li><li><p>Function、userdata和thread类型留到以后再讲。</p></li></ol><h1 id="2-表达式"><a href="#2-表达式" class="headerlink" title="2. 表达式"></a>2. 表达式</h1><h2 id="2-1-算术操作符"><a href="#2-1-算术操作符" class="headerlink" title="2.1. 算术操作符"></a>2.1. 算术操作符</h2><p>常规的操作符有：+加、-减、*乘、/除、^指数、%取模。其中^可用于任意实数，如<code>x ^ (-1 / 3)</code>计算x的立方根倒数。<strong>%可以这样使用：<code>x % 1</code>结果是x的小数部分，<code>x - x % 0.01</code>是x精确到小数点后两位的结果。</strong></p><h2 id="2-2-关系操作符"><a href="#2-2-关系操作符" class="headerlink" title="2.2. 关系操作符"></a>2.2. 关系操作符</h2><p>常规关系操作符有：&lt;小于、&gt;大与、&lt;=小于等于、&gt;=大于等于、==相等、~=不等。==和~=可用于任意两个值，若两个值具有不同类型则不相等，有相同类型则作正常比较（nil只与其自身相等）。对于对象则比较它们的引用。</p><h2 id="2-3-逻辑操作符"><a href="#2-3-逻辑操作符" class="headerlink" title="2.3. 逻辑操作符"></a>2.3. 逻辑操作符</h2><p>逻辑操作符有and、or和not。<strong>对and（or）来说，若第一个操作数为假（真），就返回第一个操作数，否则返回第二个操作数。</strong>如<code>print(4 and 5)</code> –&gt; 5，<code>print(false or 5)</code> –&gt; 5。</p><p><strong>有一些常用写法：x = x or v，可用在没有设置x的时候，将其设为一个默认值v。另一种写法<code>(a and b) or c</code>类似<code>a ? b : c</code>，如<code>max = (x &gt; y) and x or y</code>。</strong></p><h2 id="2-4-字符串连接符"><a href="#2-4-字符串连接符" class="headerlink" title="2.4. 字符串连接符"></a>2.4. 字符串连接符</h2><p>可用“..”（两个点）来连接两个字符串，若其中任一个为数字，Lua会自动转换，如<code>print(0 ..1)</code> –&gt; 01。连接字符串只会创建一个新字符串，不会对原操作数进行修改。</p><p>Lua运算符优先级顺序如下图所示。<br><img src="https://raytaylorlin-blog.oss-cn-shenzhen.aliyuncs.com/image/lua/Lua%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%A1%BA%E5%BA%8F.jpg" alt="Lua运算符优先级顺序"></p><h2 id="2-5-Table构造式"><a href="#2-5-Table构造式" class="headerlink" title="2.5. Table构造式"></a>2.5. Table构造式</h2><p>除了上述直接赋予{}创建空table以外，可以初始化其值，如<code>day = {&quot;S&quot;, &quot;M&quot;, &quot;T&quot;}</code>，或者<code>point = {x = 10, y = 20}</code>（即point.x=10，point.y=20）。以上两种初始化方式可以混用，还可以用分号代替逗号，来将列表部分和记录部分明显地分隔开，如<code>polyline = {color = &quot;blue&quot;; {x = 0, y = 0}, {x = 10, y = 10}, {x = 20, y = 30}}，则</code>print(polyline[2].x)` –&gt; 10。</p><p>更加通用的初始化格式，可以在方括号间声明索引值，如<code>opnames={[&quot;+&quot;] = &quot;add&quot;, [&quot;-&quot;] = &quot;minus&quot;}</code>。若某些情况真的需要以0作为一个数组的起始索引，可以这样<code>days={[0] = &quot;S&quot;, &quot;M&quot;, &quot;T&quot;}</code>。<strong>但是不推荐在Lua中以0作为索引起始值，因为大多数内建函数都假设数组起始于索引1。</strong></p><p>参考文献：电子工业出版社《Lua程序设计（第2版）》第2-3章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua学习笔记（1）——开始Lua</title>
      <link href="/tech/language/lua/lua-note-1/"/>
      <url>/tech/language/lua/lua-note-1/</url>
      
        <content type="html"><![CDATA[<p>Lua 是一种小巧的脚本语言。其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。本文是Lua学习笔记系列的开篇。</p><a id="more"></a><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><h2 id="1-1-目标"><a href="#1-1-目标" class="headerlink" title="1.1 目标"></a>1.1 目标</h2><p>Lua的目标是成为一个很容易嵌入其它语言中使用的语言。很多应用程序使用Lua作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。这其中包括大话西游II、仙境传说、魔兽世界、轩辕剑外传汉之云、愤怒的小鸟等等。</p><h2 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h2><p>Lua是一种轻量语言，它的官方版本只包括一个精简的核心和最基本的库。这使得Lua体积小、启动速度快。Lua可以很容易地被扩展：由宿主语言（通常是C或C++）提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。</p><p>Lua是一种多重编程范式的程式设计语言：它只提供了很小的一个特性集合来满足不同编辑范式的需要，而不是为某种特定的编辑范式提供繁杂的特性支持。例如，Lua并不提供继承这个特性，但是你可以用元表来模拟它。</p><p>Lua原生的数据类型非常之少，它只提供了数字（缺省是双精度浮点数，可配置）、布尔量、字符串、表、子程序、协程（coroutine）以及用户自定义数据这几种。但是其处理表和字符串的效率非常之高，加上元表的支持，可以高效的模拟出需要的复杂数据类型（比如集合、数组等）。Lua是一个动态弱类型语言，支持增量式垃圾收集策略。</p><p>（以上引用自维基百科）</p><h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h1><h2 id="2-1-一些常用的链接"><a href="#2-1-一些常用的链接" class="headerlink" title="2.1. 一些常用的链接"></a>2.1. 一些常用的链接</h2><p><a href="http://code.google.com/p/luaforwindows/downloads/list" target="_blank" rel="noopener">Lua for Windows下载地址</a></p><p><a href="http://manual.luaer.cn/" target="_blank" rel="noopener">Lua在线手册</a></p><p><a href="http://www.luaer.cn/" target="_blank" rel="noopener">Lua中国开发者</a></p><h2 id="2-2-程序块（chunk）"><a href="#2-2-程序块（chunk）" class="headerlink" title="2.2 程序块（chunk）"></a>2.2 程序块（chunk）</h2><p>一个程序块就是一连串的语句或命令。</p><p>在命令行下执行“lua”即可启动解释器（安装完后一般已配置好环境变量PATH），退出解释器可调用操作系统库的exit函数<code>os.exit()</code>。</p><p>有两种方式可以运行指定程序块：</p><ol><li>命令行启动：用命令<code>lua –i prog</code>运行后，先运行文件prog中的程序块再进入交互模式。</li><li><strong>dofile函数：<code>dofile(&quot;lib.lua&quot;)</code>可加载lib.lua文件。</strong></li></ol><h2 id="2-3-词法规范"><a href="#2-3-词法规范" class="headerlink" title="2.3 词法规范"></a>2.3 词法规范</h2><p>Lua中的标识符可以由任意字母、数字和下划线构成的字符串，但不能以数字开头。应当尽量避免使用以一个下划线开头并跟大写字母的标识符，因为Lua将这类标识符保留用作特殊用途。</p><p>行注释：以<code>--</code>开头，块注释：将代码放入<code>--[[</code>和<code>--]]</code>之间。</p><h2 id="2-4-全局变量与解释器"><a href="#2-4-全局变量与解释器" class="headerlink" title="2.4 全局变量与解释器"></a>2.4 全局变量与解释器</h2><p>全局变量不需要声明，只需将一个值赋予一个变量即可以创建。<strong>若一个变量未创建，则其值为nil，可以通过赋值nil来删除某个全局变量。</strong></p><p>Lua解释器程序的用法为</p><pre><code>lua [选项参数] [脚本[参数]]</code></pre><ol><li>参数-e：可以直接在-e后输入代码，需要用双引号括起，如<code>lua –e &quot;x=10&quot;</code>。</li><li>参数-l：用于加载库文件，后接文件名。</li><li>参数-i：运行完其他命令行参数后进入交互模式。</li><li>通过修改_PROMPT全局变量可以改变命令提示符（默认<code>_PROMPT=&quot;&gt;&quot;</code>）</li><li>全局变量arg可用来检索脚本的启动参数，如：<code>lua –e &quot;x=10&quot; script abc</code>，<br>则<code>arg[-3]=&quot;lua&quot;</code>  <code>arg[-2]=&quot;-e&quot;</code>  <code>arg[-1]=&quot;x=10&quot;</code>  <code>arg[0]=&quot;script&quot;</code>  <code>arg[1]=&quot;abc&quot;</code>。</li></ol><p>参考文献：电子工业出版社《Lua程序设计（第2版）》第1章</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to Ray Taylor Lin&#39;s world</title>
      <link href="/daily/welcome/"/>
      <url>/daily/welcome/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是林寿山，欢迎来到我的个人博客！</p><a id="more"></a><p>这个博客主要用于记录一些平时在技术上的心得体会，以及日常生活状况。以及涉及的一些技术的时候没有做整理，时间一长就会忘记，等到想要查阅的时候又得重新去搜索。因此为了有一个积累的过程，才萌生了开通这个博客的想法。</p><p>其实很早之前就已经有了开通技术博客的想法，但一方面苦于没有很好的资源（QQ空间和人人网显然不太适合担当这个职责），另一方面是因为这学期要拼书实在没有什么时间。如今期末考试和课设都结束了，总算有一段非常空闲的时间让我好好休整一下，顺便捣腾捣腾这个博客。这里将会作为一个技术的积累和笔记，陪伴我很长一段时间。<br>鉴于博客刚刚开通访问量还不是很大，我会在保持在人人网上同步这边的文章，希望大家多多支持。</p><p>最后是喜闻乐见的致谢——<br>感谢Frankfang和Emanon在空间申请和域名绑定的耐心解答，没有他们这个博客就看不到啦= =|<br>感谢ozawa酱的支持和怂恿，让我下定决心买了空间挂上博客&gt;_&lt;</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>大家好，我是林寿山，人称“寿寿”。欢迎来到我的个人技术博客。</p><p>这个博客主要记录了我平时一些关于编程技术的心得体会（或读书笔记），当然偶尔也会记录下生活总结。本人热爱技术，也喜欢ACG，未来的目标是当一个技术宅。</p><p>在技术方面，自我评价是小全栈（从UI到FE到RD到移动开发都略懂），万金油型，但除了Web前端之外，其他的基本上都只是了解的程度。我的技术的学习历程如下：</p><ul><li>高一：搞过一年的NOIP，但没有任何成绩。当时学的是PASCAL，算是入了编程和算法的门</li><li>大一至大三：加入思存工作室，学的是C#和.NET技术，方向偏重于桌面客户端开发</li><li>大三至大四：做了3年.NET开始觉得这一领域没什么发展前景，开始另谋出路，学过一阵子Java和Android开发后发现并不喜欢这玩意，后来尝试了Web前端后觉得非常有趣并成功转型。恰逢HTML5技术推出，开始尝试做一些小游戏。</li><li>大四至研二：保研至实验室后，基本上开始全职投入到Web前端技术的研究中。这期间多次担当实验室项目的前端负责人，在实验室推行多项主流前端技术，建立了一套前端培训体系。</li><li>研二至研三：找工作时突然决定要转游戏开发，于是抛弃最精通的Web前端，开始速学C++、Cocos2d-x、Unity3D，并做出勉强可以拿出手的作品。几经周折拿到了理想公司的offer，标识着正式转型最热爱的游戏开发。</li><li><strong>未来</strong>：借着Unity3D引擎的盛行，未来入职后应该会重拾老本行C#，这也说明了技多不压身。虽然从Web前端转型到游戏开发跨度有点大，但我相信曾经扎实的前端基础将会成为一笔不小的财富。游戏开发是一个全新的技术领域，未来将有许多新东西，如图形学、引擎、AI等等，等着我去学习。</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>读书</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      
        <content type="html"><![CDATA[<p>读书栏目终于上线了，以后就在这里跟大家交流一些好书。（博主很懒什么都不想写=。=）</p>]]></content>
      
    </entry>
    
    
  
</search>
